{"version":3,"file":"tf-backend-webgl.min.js","sources":["../src/canvas_util.ts","../src/tex_util.ts","../src/webgl_util.ts","../src/flags_webgl.ts","../src/glsl_version.ts","../src/shader_compiler_util.ts","../src/decode_matrix_gpu.ts","../src/decode_matrix_packed_gpu.ts","../src/encode_float_gpu.ts","../src/encode_float_packed_gpu.ts","../src/encode_matrix_gpu.ts","../src/encode_matrix_packed_gpu.ts","../src/gpgpu_util.ts","../src/gpgpu_context.ts","../src/shader_compiler.ts","../src/gpgpu_math.ts","../node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js","../src/kernel_utils/shared.ts","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js","../src/packing_util.ts","../src/pack_gpu.ts","../src/reshape_packed_gpu.ts","../src/texture_manager.ts","../src/unaryop_gpu.ts","../src/unaryop_packed_gpu.ts","../src/unpack_gpu.ts","../src/backend_webgl.ts","../src/webgl.ts","../src/base.ts","../src/binaryop_gpu.ts","../src/binaryop_packed_gpu.ts","../src/kernels/Identity.ts","../src/kernels/Complex.ts","../src/kernels/LeakyRelu.ts","../src/kernels/Prelu.ts","../src/kernel_utils/kernel_funcs_utils.ts","../src/mulmat_packed_gpu.ts","../src/binaryop_complex_gpu.ts","../src/kernels/Multiply.ts","../src/kernels/Reshape.ts","../src/kernel_utils/reshape.ts","../src/mean_gpu.ts","../src/reduce_gpu.ts","../src/kernel_utils/reduce.ts","../src/transpose_gpu.ts","../src/transpose_packed_gpu.ts","../src/kernels/Transpose_impl.ts","../src/kernels/Sum.ts","../src/kernels/Sum_impl.ts","../src/kernels/Transpose.ts","../src/kernels/BatchMatMul_impl.ts","../src/kernels/_FusedMatMul.ts","../src/kernels/Abs.ts","../src/kernels/Acos.ts","../src/kernels/Acosh.ts","../src/kernels/Add.ts","../src/addn_gpu.ts","../src/addn_packed_gpu.ts","../src/kernels/AddN.ts","../src/kernels/All.ts","../src/kernels/Any.ts","../src/argminmax_gpu.ts","../src/argminmax_packed_gpu.ts","../src/kernel_utils/arg_min_max.ts","../src/kernels/ArgMax.ts","../src/kernels/ArgMin.ts","../src/kernels/Asin.ts","../src/kernels/Asinh.ts","../src/kernels/Atan.ts","../src/kernels/Atan2.ts","../src/kernels/Atanh.ts","../src/pool_gpu.ts","../src/kernels/AvgPool.ts","../src/kernels/AvgPool3D.ts","../src/avg_pool_backprop_gpu.ts","../src/kernels/AvgPool3DGrad.ts","../src/kernels/AvgPoolGrad.ts","../src/kernels/BatchMatMul.ts","../src/batchnorm_gpu.ts","../src/batchnorm_packed_gpu.ts","../src/kernels/BatchNorm.ts","../src/slice_gpu.ts","../src/slice_packed_gpu.ts","../src/kernels/Slice.ts","../src/kernels/BatchToSpaceND.ts","../src/kernels/Bincount.ts","../src/kernels/NotEqual.ts","../src/kernels/Real.ts","../src/kernels/Cast.ts","../src/kernel_utils/int.ts","../src/kernels/Ceil.ts","../src/clip_gpu.ts","../src/clip_packed_gpu.ts","../src/kernels/ClipByValue.ts","../src/complex_abs_gpu.ts","../src/kernels/ComplexAbs.ts","../src/concat_gpu.ts","../src/concat_packed_gpu.ts","../src/kernels/Imag.ts","../src/kernels/Concat_impl.ts","../src/kernels/Concat.ts","../src/conv_gpu.ts","../src/im2col_packed_gpu.ts","../src/kernels/Conv2D_impl.ts","../src/kernels/Conv2D.ts","../src/conv_backprop_gpu.ts","../src/kernels/Conv2DBackpropFilter.ts","../src/kernels/Conv2DBackpropInput.ts","../src/kernels/Conv3D.ts","../src/kernels/Conv3DBackpropFilterV2.ts","../src/kernels/Conv3DBackpropInputV2.ts","../src/kernels/Cos.ts","../src/kernels/Cosh.ts","../src/crop_and_resize_gpu.ts","../src/kernels/CropAndResize.ts","../src/cumsum_gpu.ts","../src/kernels/Cumsum.ts","../src/kernels/DenseBincount.ts","../src/depth_to_space_gpu.ts","../src/kernels/DepthToSpace.ts","../src/conv_gpu_depthwise.ts","../src/conv_packed_gpu_depthwise.ts","../src/kernels/DepthwiseConv2dNative.ts","../src/conv_backprop_gpu_depthwise.ts","../src/kernels/DepthwiseConv2dNativeBackpropFilter.ts","../src/kernels/DepthwiseConv2dNativeBackpropInput.ts","../src/diag_gpu.ts","../src/kernels/Diag.ts","../src/dilation_gpu.ts","../src/kernels/Dilation2D.ts","../src/kernels/Einsum.ts","../src/kernels/Elu.ts","../src/kernels/EluGrad.ts","../src/kernels/Equal.ts","../src/kernels/Erf.ts","../src/kernels/Exp.ts","../src/kernels/ExpandDims.ts","../src/kernels/Expm1.ts","../src/fft_gpu.ts","../src/kernels/FFT_impl.ts","../src/kernels/FFT.ts","../src/fill_gpu.ts","../src/kernels/Fill.ts","../src/kernels/FromPixels.ts","../src/flip_left_right_gpu.ts","../src/kernels/FlipLeftRight.ts","../src/kernels/Floor.ts","../src/kernels/FloorDiv.ts","../src/kernels/FromPixels_utils/from_pixels_gpu.ts","../src/kernels/FromPixels_utils/from_pixels_packed_gpu.ts","../src/kernels/FusedConv2D.ts","../src/kernels/FusedDepthwiseConv2D.ts","../src/gather_nd_gpu.ts","../src/kernels/GatherNd.ts","../src/gather_gpu.ts","../src/kernels/GatherV2.ts","../src/kernels/Greater.ts","../src/kernels/GreaterEqual.ts","../src/kernels/IFFT.ts","../src/kernels/IsFinite.ts","../src/kernels/IsInf.ts","../src/kernels/IsNaN.ts","../src/kernels/Less.ts","../src/kernels/LessEqual.ts","../src/kernels/LinSpace.ts","../src/kernels/Log.ts","../src/kernels/Log1p.ts","../src/kernels/LogicalAnd.ts","../src/kernels/LogicalNot.ts","../src/kernels/LogicalOr.ts","../src/lrn_gpu.ts","../src/lrn_packed_gpu.ts","../src/kernels/LRN.ts","../src/lrn_grad_gpu.ts","../src/kernels/LRNGrad.ts","../src/kernels/Max.ts","../src/kernels/Max_impl.ts","../src/kernels/Maximum.ts","../src/kernels/MaxPool.ts","../src/kernels/MaxPool3D.ts","../src/max_pool_backprop_gpu.ts","../src/kernels/MaxPool3DGrad.ts","../src/kernels/MaxPoolGrad.ts","../src/kernels/MaxPoolWithArgmax.ts","../src/kernels/MaxPoolWithArgmax_impl.ts","../src/kernels/Mean.ts","../src/kernels/Mean_impl.ts","../src/kernels/Min.ts","../src/kernels/Minimum.ts","../src/mirror_pad_gpu.ts","../src/mirror_pad_packed_gpu.ts","../src/kernels/MirrorPad.ts","../src/kernels/Mod.ts","../src/multinomial_gpu.ts","../src/kernels/RealDiv.ts","../src/kernels/Sub.ts","../src/kernels/Softmax.ts","../src/kernels/Multinomial.ts","../src/kernels/Neg.ts","../src/kernels/NonMaxSuppressionV3.ts","../src/kernels/NonMaxSuppressionV4.ts","../src/kernels/NonMaxSuppressionV5.ts","../src/onehot_gpu.ts","../src/kernels/OneHot.ts","../src/kernels/ZerosLike.ts","../src/kernels/OnesLike.ts","../src/kernels/Pack.ts","../src/pad_gpu.ts","../src/pad_packed_gpu.ts","../src/kernels/PadV2.ts","../src/kernels/Pow.ts","../src/kernels/Prod.ts","../src/kernels/Range.ts","../src/kernels/Reciprocal.ts","../src/kernels/Relu.ts","../src/kernels/Relu6.ts","../src/resize_bilinear_gpu.ts","../src/resize_bilinear_packed_gpu.ts","../src/kernels/ResizeBilinear.ts","../src/resize_bilinear_backprop_gpu.ts","../src/kernels/ResizeBilinearGrad.ts","../src/resize_nearest_neighbor_gpu.ts","../src/resize_nearest_neighbor_packed_gpu.ts","../src/kernels/ResizeNearestNeighbor.ts","../src/resize_nearest_neighbor_backprop_gpu.ts","../src/kernels/ResizeNearestNeighborGrad.ts","../src/reverse_gpu.ts","../src/reverse_packed_gpu.ts","../src/kernels/Reverse.ts","../src/rotate_gpu.ts","../src/kernels/RotateWithOffset.ts","../src/kernels/Round.ts","../src/kernels/Rsqrt.ts","../src/scatter_gpu.ts","../src/kernels/ScatterNd.ts","../src/select_gpu.ts","../src/kernels/Select.ts","../src/kernels/Selu.ts","../src/kernels/Sigmoid.ts","../src/kernels/Sign.ts","../src/kernels/Sin.ts","../src/kernels/Sinh.ts","../src/kernels/Softplus.ts","../src/kernels/SpaceToBatchND.ts","../src/kernels/SparseFillEmptyRows.ts","../src/kernels/SparseReshape.ts","../src/kernels/SparseToDense.ts","../src/kernels/SplitV.ts","../src/kernels/Sqrt.ts","../src/kernels/Square.ts","../src/kernels/SquaredDifference.ts","../src/kernels/Step.ts","../src/strided_slice_gpu.ts","../src/kernels/StridedSlice.ts","../src/kernels/Tan.ts","../src/kernels/Tanh.ts","../src/tile_gpu.ts","../src/kernels/Tile.ts","../src/kernels/TopK.ts","../src/transform_gpu.ts","../src/kernels/Transform.ts","../src/kernels/Unique.ts","../src/kernels/Unpack.ts","../src/segment_gpu.ts","../src/register_all_kernels.ts","../src/kernels/UnsortedSegmentSum.ts","../src/version.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nconst contexts: {[key: string]: WebGLRenderingContext} = {};\n\nconst WEBGL_ATTRIBUTES: WebGLContextAttributes = {\n  alpha: false,\n  antialias: false,\n  premultipliedAlpha: false,\n  preserveDrawingBuffer: false,\n  depth: false,\n  stencil: false,\n  failIfMajorPerformanceCaveat: true\n};\n\nexport function clearWebGLContext(webGLVersion: number) {\n  delete contexts[webGLVersion];\n}\n\nexport function setWebGLContext(\n    webGLVersion: number, gl: WebGLRenderingContext) {\n  contexts[webGLVersion] = gl;\n}\n\nexport function getWebGLContext(webGLVersion: number): WebGLRenderingContext {\n  if (!(webGLVersion in contexts)) {\n    const newCtx = getWebGLRenderingContext(webGLVersion);\n    if (newCtx !== null) {\n      contexts[webGLVersion] = newCtx;\n    } else {\n      console.log('Could not get context for WebGL version', webGLVersion);\n      return null;\n    }\n  }\n  const gl = contexts[webGLVersion];\n  if (gl.isContextLost()) {\n    delete contexts[webGLVersion];\n    return getWebGLContext(webGLVersion);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return contexts[webGLVersion];\n}\n\nfunction createCanvas(webGLVersion: number) {\n  if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n    return new OffscreenCanvas(300, 150);\n  } else if (typeof document !== 'undefined') {\n    return document.createElement('canvas');\n  } else {\n    throw new Error('Cannot create a canvas in this context');\n  }\n}\n\nfunction getWebGLRenderingContext(webGLVersion: number): WebGLRenderingContext {\n  if (webGLVersion !== 1 && webGLVersion !== 2) {\n    throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n  }\n  const canvas = createCanvas(webGLVersion);\n\n  canvas.addEventListener('webglcontextlost', (ev: Event) => {\n    ev.preventDefault();\n    delete contexts[webGLVersion];\n  }, false);\n  if (webGLVersion === 1) {\n    return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES)) as\n        WebGLRenderingContext;\n  }\n  return canvas.getContext('webgl2', WEBGL_ATTRIBUTES) as WebGLRenderingContext;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataId, DataType, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nexport enum PackingScheme {\n  /**\n   * All values in a single texel are densely packed without any constraints.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 4]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   010|011   020|021\n   * -------   -------   -------\n   * 002|003   012|013   022|023\n   *\n   * 100|101   110|111   120|121\n   * -------   -------   -------\n   * 102|103   112|113   122|123\n   *\n   */\n  DENSE,\n\n  /**\n   * Single texels contain only values from the same batch, and from adjacent\n   * rows and columns.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 5]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   */\n  SHARED_BATCH\n}\n\nexport enum TextureUsage {\n  RENDER,\n  UPLOAD,\n  PIXELS,\n  DOWNLOAD\n}\n\nexport enum PhysicalTextureType {\n  UNPACKED_FLOAT16,\n  UNPACKED_FLOAT32,\n  PACKED_4X1_UNSIGNED_BYTE,\n  PACKED_2X2_FLOAT32,\n  PACKED_2X2_FLOAT16\n}\n\nexport interface TextureData {\n  // Required.\n  shape: number[];\n  dtype: DataType;\n\n  // Optional.\n  values?: backend_util.BackendValues;\n  texture?: WebGLTexture;\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensorInfos, with a parent joining the two with the\n  // complexTensors field. When this is defined, texture will be null.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo};\n  /** [rows, columns] shape of the texture. */\n  texShape?: [number, number];\n  usage?: TextureUsage;\n  isPacked?: boolean;\n\n  refCount: number;\n\n  // Available when the tensor has been sliced.\n  slice?: {\n    // Offset in the 'flat index' space.\n    flatOffset: number;\n    // Used for counting how many sliced tensors point to the same texture.\n    origDataId: DataId;\n  };\n}\n\nexport function getUnpackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns, rows];\n}\n\nexport function getUnpackedArraySizeFromMatrixSize(\n    matrixSize: number, channelsPerTexture: number): number {\n  return matrixSize * channelsPerTexture;\n}\n\nexport function getColorMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns * 4, rows];\n}\n\n/**\n * Get shape for densely packed RGBA texture.\n */\nexport function getDenseTexShape(shape: number[]): [number, number] {\n  const size = util.sizeFromShape(shape);\n  const texelsNeeded = Math.ceil(size / 4);\n  return util.sizeToSquarishShape(texelsNeeded);\n}\n\nexport function getMatrixSizeFromUnpackedArraySize(\n    unpackedSize: number, channelsPerTexture: number): number {\n  if (unpackedSize % channelsPerTexture !== 0) {\n    throw new Error(\n        `unpackedSize (${unpackedSize}) must be a multiple of ` +\n        `${channelsPerTexture}`);\n  }\n  return unpackedSize / channelsPerTexture;\n}\n\nexport function decodeMatrixFromUnpackedColorRGBAArray(\n    unpackedArray: Float32Array, matrix: Float32Array, channels: number) {\n  const requiredSize = unpackedArray.length * channels / 4;\n  if (matrix.length < requiredSize) {\n    throw new Error(\n        `matrix length (${matrix.length}) must be >= ${requiredSize}`);\n  }\n  let dst = 0;\n  for (let src = 0; src < unpackedArray.length; src += 4) {\n    for (let c = 0; c < channels; c++) {\n      matrix[dst++] = unpackedArray[src + c];\n    }\n  }\n}\n\nexport function getPackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [\n    Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n  ];\n}\n\nexport function getPackedRGBAArraySizeFromMatrixShape(\n    rows: number, columns: number): number {\n  const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return w * h * 4;\n}\n\nexport interface TextureConfig {\n  internalFormatFloat: number;\n  textureFormatFloat: number;\n  internalFormatPackedHalfFloat: number;\n  internalFormatHalfFloat: number;\n  internalFormatPackedFloat: number;\n\n  // The format to use during a gl.readPixels call.\n  downloadTextureFormat: number;\n  // How many channels need to be unpacked after a gl.readPixels call.\n  downloadUnpackNumChannels: number;\n\n  defaultNumChannels: number;\n  textureTypeHalfFloat: number;\n  textureTypeFloat: number;\n}\n\nexport function getTextureConfig(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension?: any): TextureConfig {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n\n  let internalFormatFloat: number;\n  let internalFormatHalfFloat: number;\n  let internalFormatPackedHalfFloat: number;\n  let internalFormatPackedFloat: number;\n  let textureFormatFloat: number;\n\n  let downloadTextureFormat: number;\n  let downloadUnpackNumChannels: number;\n\n  let defaultNumChannels: number;\n  let textureTypeHalfFloat: number;\n  let textureTypeFloat: number;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    internalFormatFloat = glany.R32F;\n    internalFormatHalfFloat = glany.R16F;\n    internalFormatPackedHalfFloat = glany.RGBA16F;\n    internalFormatPackedFloat = glany.RGBA32F;\n    textureFormatFloat = glany.RED;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 1;\n    textureTypeHalfFloat = glany.HALF_FLOAT;\n    textureTypeFloat = glany.FLOAT;\n  } else {\n    internalFormatFloat = gl.RGBA;\n    internalFormatHalfFloat = gl.RGBA;\n    internalFormatPackedHalfFloat = gl.RGBA;\n    internalFormatPackedFloat = glany.RGBA;\n    textureFormatFloat = gl.RGBA;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 4;\n    textureTypeHalfFloat = textureHalfFloatExtension != null ?\n        textureHalfFloatExtension.HALF_FLOAT_OES :\n        null;\n    textureTypeFloat = gl.FLOAT;\n  }\n  downloadTextureFormat = gl.RGBA;\n\n  return {\n    internalFormatFloat,\n    internalFormatHalfFloat,\n    internalFormatPackedHalfFloat,\n    internalFormatPackedFloat,\n    textureFormatFloat,\n    downloadTextureFormat,\n    downloadUnpackNumChannels,\n    defaultNumChannels,\n    textureTypeHalfFloat,\n    textureTypeFloat\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {getTextureConfig} from './tex_util';\n\nexport function callAndCheck<T>(gl: WebGLRenderingContext, func: () => T): T {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\n\nfunction checkWebGLError(gl: WebGLRenderingContext) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\n\nexport function canBeRepresented(num: number): boolean {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n      (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWebGLErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\n\nexport function getExtensionOrThrow(\n    gl: WebGLRenderingContext, extensionName: string): {} {\n  return throwIfNull<{}>(\n      gl, () => gl.getExtension(extensionName),\n      'Extension \"' + extensionName + '\" not supported on this browser.');\n}\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, vertexShaderSource: string): WebGLShader {\n  const vertexShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.VERTEX_SHADER),\n      'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\n\nexport function createFragmentShader(\n    gl: WebGLRenderingContext, fragmentShaderSource: string): WebGLShader {\n  const fragmentShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.FRAGMENT_SHADER),\n      'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(\n        fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\n\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(\n    shaderSource: string, shaderInfoLog: string) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map(\n      (line, lineNumber) =>\n          util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\n      `%c ${util.rightPad(errorLine[0], maxLineLength)}`,\n      'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl: WebGLRenderingContext): WebGLProgram {\n  return throwIfNull<WebGLProgram>(\n      gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\n\nexport function linkProgram(gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n\nexport function validateProgram(\n    gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\n\nexport function createStaticVertexBuffer(\n    gl: WebGLRenderingContext, data: Float32Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function createStaticIndexBuffer(\n    gl: WebGLRenderingContext, data: Uint16Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function getNumChannels(): number {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\n\nexport function createTexture(gl: WebGLRenderingContext): WebGLTexture {\n  return throwIfNull<WebGLTexture>(\n      gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\n\nexport function validateTextureSize(width: number, height: number) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if ((width <= 0) || (height <= 0)) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if ((width > maxTextureSize) || (height > maxTextureSize)) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error(\n        'Requested texture size ' + requested +\n        ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\n\nexport function createFramebuffer(gl: WebGLRenderingContext): WebGLFramebuffer {\n  return throwIfNull<WebGLFramebuffer>(\n      gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\n\nexport function bindVertexBufferToProgramAttribute(\n    gl: WebGLRenderingContext, program: WebGLProgram, attribute: string,\n    buffer: WebGLBuffer, arrayEntriesPerItem: number, itemStrideInBytes: number,\n    itemOffsetInBytes: number): boolean {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl,\n      () => gl.vertexAttribPointer(\n          loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes,\n          itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\n\nexport function bindTextureUnit(\n    gl: WebGLRenderingContext, texture: WebGLTexture, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\n\nexport function unbindTextureUnit(\n    gl: WebGLRenderingContext, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function getProgramUniformLocationOrThrow(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return throwIfNull<WebGLUniformLocation>(\n      gl, () => gl.getUniformLocation(program, uniformName),\n      'uniform \"' + uniformName + '\" not present in program.');\n}\n\nexport function getProgramUniformLocation(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return gl.getUniformLocation(program, uniformName);\n}\n\nexport function bindTextureToProgramUniformSampler(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    uniformSamplerLocation: WebGLUniformLocation, textureUnit: number) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\n\nexport function bindCanvasToFramebuffer(gl: WebGLRenderingContext) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\n\nexport function bindColorTextureToFramebuffer(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\n\nexport function unbindColorTextureFromFramebuffer(\n    gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\n\nexport function validateFramebuffer(gl: WebGLRenderingContext) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error(\n        'Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\n\nexport function getFramebufferErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull<T>(\n    gl: WebGLRenderingContext, returnTOrNull: () => T | null,\n    failureMessage: string): T {\n  const tOrNull: T|null = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl: WebGLRenderingContext, textureUnit: number) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [\n    shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n  ];\n}\n\nexport function getShapeAs3D(shape: number[]): [number, number, number] {\n  let shapeAs3D: [number, number, number] = [1, 1, 1];\n  const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n  if (!isScalar) {\n    shapeAs3D =\n        [getBatchDim(shape), ...getRowsCols(shape)] as [number, number, number];\n  }\n  return shapeAs3D;\n}\n\nexport function getTextureShapeFromLogicalShape(\n    logShape: number[], isPacked = false): [number, number] {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map(\n        (d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (\n      logShape.length === 2 && logShape[0] <= maxTexSize &&\n      logShape[1] <= maxTexSize) {\n    return logShape as [number, number];\n  } else if (\n      logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n      logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (\n      logShape.length === 3 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n      logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (\n      logShape.length === 4 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n\n      const batchDim = getBatchDim(logShape);\n      let rows = 2, cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2) as [number, number];\n    }\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n: number): boolean {\n  return n % 2 === 0;\n}\n\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1: number[], shape2: number[]): boolean {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {  // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n      shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {  // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) &&\n        (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE: number;\nlet MAX_TEXTURES_IN_SHADER: number;\n\nexport function getWebGLMaxTextureSize(webGLVersion: number): number {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\n\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\n\nexport function getMaxTexturesInShader(webGLVersion: number): number {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\n\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion: number):\n    number {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion: number;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n      webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\n\nexport function hasExtension(gl: WebGLRenderingContext, extensionName: string) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nexport function isWebGLVersionEnabled(webGLVersion: 1|2) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\n\nexport function isCapableOfRenderingToFloatTexture(webGLVersion: number):\n    boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion: number): boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension =\n          gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(\n          gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl: WebGLRenderingContext):\n    boolean {\n  const texConfig = getTextureConfig(gl);\n\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension: any): boolean {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion: number) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n\n  // tslint:disable-next-line:no-any\n  const isEnabled = (gl as any).fenceSync != null;\n  return isEnabled;\n}\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${opName} does not support complex64 tensors ` +\n              'in the WebGL backend.');\n    }\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {device_util, env} from '@tensorflow/tfjs-core';\n\nimport {getMaxTexturesInShader, getWebGLDisjointQueryTimerVersion, getWebGLMaxTextureSize, isCapableOfRenderingToFloatTexture, isDownloadFloatTextureEnabled, isWebGLFenceEnabled, isWebGLVersionEnabled} from './webgl_util';\n\nconst ENV = env();\n\n/**\n * This file contains WebGL-specific flag registrations.\n */\n\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);\n\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', () => {\n  if (isWebGLVersionEnabled(2)) {\n    return 2;\n  } else if (isWebGLVersionEnabled(1)) {\n    return 1;\n  }\n  return 0;\n});\n\n/** Whether to check for numerical representation problems. */\nENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', () => false);\n\nENV.registerFlag(\n    'WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);\n\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', () => true);\n\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);\n\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));\n\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the depthwise conv op. */\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack binary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack unary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack array ops. */\nENV.registerFlag(\n    'WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack image ops. */\nENV.registerFlag(\n    'WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURE_SIZE',\n    () => getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURES_IN_SHADER',\n    () => getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {\n  const webGLVersion = ENV.getNumber('WEBGL_VERSION');\n\n  if (webGLVersion === 0) {\n    return 0;\n  }\n  return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag(\n    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE',\n    () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n        !device_util.isMobile());\n\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag(\n    'WEBGL_RENDER_FLOAT32_CAPABLE',\n    () => isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {\n  return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n      false :\n      ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag(\n    'WEBGL_DOWNLOAD_FLOAT_ENABLED',\n    () => isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/** Whether the fence API is available. */\nENV.registerFlag(\n    'WEBGL_FENCE_API_ENABLED',\n    () => isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {\n  // Use uniform uploads only when 32bit floats are supported. In\n  // 16bit\n  // environments there are problems with comparing a 16bit texture value\n  // with a 32bit uniform value.\n  const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n  return useUniforms ? 4 : 0;\n});\n\n/**\n * If the total number of bytes allocated on the GPU is greater than this\n * number, we will aggressively delete textures upon disposal with\n * gl.deleteMatrixTexture, rather than making them available for reuse.\n *\n * Default value -1 indicates that we will never aggressively delete textures.\n */\nENV.registerFlag(\n    'WEBGL_DELETE_TEXTURE_THRESHOLD',\n    () => {\n      return -1;\n    },\n    threshold => {\n      if (threshold < 0 && threshold !== -1) {\n        throw new Error(\n            `WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` +\n            `delete) or at least 0, but got ${threshold}.`);\n      }\n    });\n\n/**\n * Trigger a manual GL command flush if the threshold of time has passed since\n * previous Kernel execution. This can be useful for Andorid device where GL\n * command flush are delayed un til the end of javascript task. This value is\n * measured in millisecond. Typically you want to set this value to close to 1.\n *\n * Default value 1 for mobile chrome, and -1 for rest cases. -1 indicates that\n * we will not enforce manual flush and depend on system default flush schedule.\n */\nENV.registerFlag(\n    'WEBGL_FLUSH_THRESHOLD',\n    () => {\n      return device_util.isMobile() && ENV.getBool('IS_CHROME') ? 1 : -1;\n    },\n    threshold => {\n      if (threshold < 0 && threshold !== -1) {\n        throw new Error(\n            `WEBGL_FLUSH_THRESHOLD must be -1 (indicating never ` +\n            `manual flush) or at least 0, but got ${threshold}.`);\n      }\n    });\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {env} from '@tensorflow/tfjs-core';\n\nexport type GLSL = {\n  version: string,\n  attribute: string,\n  varyingVs: string,\n  varyingFs: string,\n  texture2D: string,\n  output: string,\n  defineOutput: string,\n  defineSpecialNaN: string,\n  defineSpecialInf: string,\n  defineRound: string\n};\n\nexport function getGlslDifferences(): GLSL {\n  let version: string;\n  let attribute: string;\n  let varyingVs: string;\n  let varyingFs: string;\n  let texture2D: string;\n  let output: string;\n  let defineOutput: string;\n  let defineSpecialNaN: string;\n  let defineSpecialInf: string;\n  let defineRound: string;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    version = '#version 300 es';\n    attribute = 'in';\n    varyingVs = 'out';\n    varyingFs = 'in';\n    texture2D = 'texture';\n    output = 'outputColor';\n    defineOutput = 'out vec4 outputColor;';\n\n    // Use custom isnan definition to work across differences between\n    // implementations on various platforms. While this should happen in ANGLE\n    // we still see differences between android and windows (on chrome) when\n    // using isnan directly.\n    defineSpecialNaN = `\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;\n    // In webgl 2 we do not need to specify a custom isinf so there is no\n    // need for a special INFINITY constant.\n    defineSpecialInf = ``;\n    defineRound = `\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  } else {\n    version = '';\n    attribute = 'attribute';\n    varyingVs = 'varying';\n    varyingFs = 'varying';\n    texture2D = 'texture2D';\n    output = 'gl_FragColor';\n    defineOutput = '';\n    // WebGL1 has no built in isnan so we define one here.\n    defineSpecialNaN = `\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;\n    defineSpecialInf = `\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;\n    defineRound = `\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  }\n\n  return {\n    version,\n    attribute,\n    varyingVs,\n    varyingFs,\n    texture2D,\n    output,\n    defineOutput,\n    defineSpecialNaN,\n    defineSpecialInf,\n    defineRound\n  };\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(\n    coords: string[], shape: number[], index = 'index'): string {\n  const strides = util.computeStrides(shape);\n  return strides\n      .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\nfunction buildVec(x: string[]): string {\n  if (x.length === 1) {\n    return `${x[0]}`;\n  }\n  return `vec${x.length}(${x.join(',')})`;\n}\n\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x: string[], y: string[]): string {\n  if (x.length !== y.length) {\n    throw new Error(\n        `Vectors to be dotted must be of the same length -` +\n        `got ${x.length} and ${y.length}`);\n  }\n\n  const slices: string[] = [];\n  const nearestVec4 = Math.floor(x.length / 4);\n  const nearestVec4Remainder = x.length % 4;\n\n  for (let i = 0; i < nearestVec4; i++) {\n    const xSlice = x.slice(i * 4, i * 4 + 4);\n    const ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    let xSlice = x.slice(nearestVec4 * 4);\n    let ySlice = y.slice(nearestVec4 * 4);\n    if (xSlice.length === 1) {\n      xSlice = xSlice.map(d => `float(${d})`);\n      ySlice = ySlice.map(d => `float(${d})`);\n    }\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  return slices.map((d, i) => `dot(${d})`).join('+');\n}\n\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape: [number, number, number]): string {\n  const strides = util.computeStrides(shape).map(d => d.toString());\n\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\n\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {getDenseTexShape, PackingScheme} from './tex_util';\n\nexport class DecodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: [number, number, number];\n  packedInputs = false;\n  packedOutput = true;\n  outPackingScheme = PackingScheme.DENSE;\n\n  constructor(outputShape: [number, number, number]) {\n    const texShape = getDenseTexShape(outputShape);\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        shader_util.getLogicalCoordinatesFromFlatIndex(\n            ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {getDenseTexShape, PackingScheme} from './tex_util';\n\nexport class DecodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: [number, number, number];\n  outPackingScheme = PackingScheme.DENSE;\n\n  constructor(outputShape: [number, number, number]) {\n    const texShape = getDenseTexShape(outputShape);\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        shader_util.getLogicalCoordinatesFromFlatIndex(\n            ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = false;\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: [number, number, number]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nexport class EncodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(\n      outputShape: [number, number, number], texShape: [number, number],\n      inputIsUnsignedByte = false) {\n    const glsl = getGlslDifferences();\n    const [height, width] = texShape;\n    this.outputShape = outputShape;\n\n    let output = `result`;\n    if (inputIsUnsignedByte) {\n      output = `floor(result * 255. + 0.5)`;\n    }\n\n    this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${width};\n        int c = imod(flatIndex, ${width});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n        vec4 values = ${glsl.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${glsl.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\n\nexport class EncodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(\n      outputShape: [number, number, number], texShape: [number, number],\n      inputIsUnsignedByte = false) {\n    const glsl = getGlslDifferences();\n    const [height, width] = texShape;\n    this.outputShape = outputShape;\n\n    let mainLoop = '';\n    let output = 'result';\n    if (inputIsUnsignedByte) {\n      output = 'floor(result * 255. + 0.5)';\n    }\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        const channel = row * 2 + col;\n\n        mainLoop += `\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${outputShape[2]}) {\n            localCoords[2] += ${col};\n            if(localCoords[1] + ${row} < ${outputShape[1]}) {\n              localCoords[1] += ${row};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${width};\n              c = imod(flatIndex, ${width});\n              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n              values = ${glsl.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${channel}] = values[0];\n              } else if(offset == 1) {\n                result[${channel}] = values[1];\n              } else if(offset == 2) {\n                result[${channel}] = values[2];\n              } else {\n                result[${channel}] = values[3];\n              }\n            }\n          }\n        `;\n      }\n    }\n\n    this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${mainLoop}\n\n        ${glsl.output} = ${output};\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {PixelData, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {getGlslDifferences} from './glsl_version';\nimport * as tex_util from './tex_util';\nimport {TextureConfig} from './tex_util';\nimport * as webgl_util from './webgl_util';\n\nexport function createVertexShader(gl: WebGLRenderingContext): WebGLShader {\n  const glsl = getGlslDifferences();\n  const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n  return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\n\nexport function createVertexBuffer(gl: WebGLRenderingContext): WebGLBuffer {\n  // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n  const vertexArray = new Float32Array(\n      [-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\n\nexport function createIndexBuffer(gl: WebGLRenderingContext): WebGLBuffer {\n  // OpenGL (and WebGL) have \"CCW == front\" winding\n  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\n\nfunction createAndConfigureTexture(\n    gl: WebGLRenderingContext, width: number, height: number,\n    internalFormat: number, textureFormat: number,\n    textureType: number): WebGLTexture {\n  webgl_util.validateTextureSize(width, height);\n  const texture = webgl_util.createTexture(gl);\n\n  const tex2d = gl.TEXTURE_2D;\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.texImage2D(\n          tex2d, 0, internalFormat, width, height, 0, textureFormat,\n          textureType, null));\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n  return texture;\n}\n\nexport function getInternalFormatForFloat32MatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatFloat;\n}\n\nexport function createFloat32MatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat32MatrixTexture(textureConfig),\n      textureConfig.textureFormatFloat, gl.FLOAT);\n}\n\nexport function getInternalFormatForFloat16MatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatHalfFloat;\n}\n\nexport function createFloat16MatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat16MatrixTexture(textureConfig),\n      textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\n\nexport function getInternalFormatForUnsignedBytesMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.downloadTextureFormat;\n}\n\nexport function createUnsignedBytesMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA,\n      gl.UNSIGNED_BYTE);\n}\n\nexport function getInternalFormatForPackedMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatPackedFloat;\n}\n\nexport function createPackedMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig),\n      gl.RGBA, gl.FLOAT);\n}\n\nexport function getInternalFormatForFloat16PackedMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatPackedHalfFloat;\n}\n\nexport function createFloat16PackedMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA,\n      textureConfig.textureTypeHalfFloat);\n}\n\nexport function bindVertexProgramAttributeStreams(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    vertexBuffer: WebGLBuffer): boolean {\n  const posOffset = 0;               // x is the first buffer element\n  const uvOffset = 3 * 4;            // uv comes after [x y z]\n  const stride = (3 * 4) + (2 * 4);  // xyz + uv, each entry is 4-byte float.\n  webgl_util.callAndCheck(\n      gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n  const success = webgl_util.bindVertexBufferToProgramAttribute(\n      gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success &&\n      webgl_util.bindVertexBufferToProgramAttribute(\n          gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\n\nexport function uploadDenseMatrixToTexture(\n    gl: WebGLRenderingContext, texture: WebGLTexture, width: number,\n    height: number, data: TypedArray, textureConfig: TextureConfig) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n\n  let dataForUpload: TypedArray, texelDataType: number, internalFormat: number;\n  if (data instanceof Uint8Array) {\n    dataForUpload = new Uint8Array(width * height * 4);\n    texelDataType = gl.UNSIGNED_BYTE;\n    internalFormat = gl.RGBA;\n  } else {\n    dataForUpload = new Float32Array(width * height * 4);\n    texelDataType = gl.FLOAT;\n    internalFormat = textureConfig.internalFormatPackedFloat;\n  }\n\n  dataForUpload.set(data);\n\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.texImage2D(\n          gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA,\n          texelDataType, dataForUpload));\n\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function uploadPixelDataToTexture(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n    HTMLVideoElement|ImageBitmap) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n  if ((pixels as PixelData).data instanceof Uint8Array) {\n    webgl_util.callAndCheck(\n        gl,\n        () => gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA,\n            gl.UNSIGNED_BYTE, (pixels as PixelData).data));\n  } else {\n    webgl_util.callAndCheck(\n        gl,\n        () => gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,\n            pixels as ImageData | HTMLImageElement | HTMLCanvasElement |\n                HTMLVideoElement|ImageBitmap));\n  }\n\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function createBufferFromOutputTexture(\n    gl2: WebGL2RenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLBuffer {\n  // Create and bind the buffer.\n  const buffer = gl2.createBuffer();\n  webgl_util.callAndCheck(\n      gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n\n  // Initialize the buffer to the size of the texture in bytes.\n  const bytesPerFloat = 4;\n  const valuesPerTexel = 4;\n  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n\n  webgl_util.callAndCheck(\n      gl2,\n      () => gl2.bufferData(\n          gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n\n  // Enqueue a command on the GPU command queue to copy of texture into the\n  // buffer.\n  webgl_util.callAndCheck(\n      gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n\n  webgl_util.callAndCheck(\n      gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n\n  return buffer;\n}\n\nexport function downloadFloat32MatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer,\n    size: number): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget = new Float32Array(size);\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig) {\n  const [w, h] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n\n  const numChannels = 4;\n  const downloadTarget = new Uint8Array(\n      tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.readPixels(\n          0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE,\n          downloadTarget));\n\n  // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n  // decoding of the 4 bytes that back each 32 bit float.\n  return new Float32Array(downloadTarget.buffer);\n}\n\nexport function downloadPackedMatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer, batch: number, rows: number,\n    cols: number, physicalRows: number, physicalCols: number,\n    textureConfig: TextureConfig): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget =\n      new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(\n          physicalRows, physicalCols));\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadMatrixFromPackedOutputTexture(\n    gl: WebGLRenderingContext, physicalRows: number,\n    physicalCols: number): Float32Array {\n  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.readPixels(\n          0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n\n  return packedRGBA;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext, setWebGLContext} from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport {TextureConfig} from './tex_util';\nimport {WebGL1DisjointQueryTimerExtension, WebGL2DisjointQueryTimerExtension} from './webgl_types';\nimport * as webgl_util from './webgl_util';\n\nexport interface FenceContext {\n  query: WebGLQuery|WebGLSync;\n  isFencePassed(): boolean;\n}\n\nexport class GPGPUContext {\n  gl: WebGLRenderingContext;\n  textureFloatExtension: {};\n  textureHalfFloatExtension: {};\n  colorBufferFloatExtension: {};\n  colorBufferHalfFloatExtension: {};\n  disjointQueryTimerExtension: WebGL2DisjointQueryTimerExtension|\n      WebGL1DisjointQueryTimerExtension;\n  vertexBuffer: WebGLBuffer;\n  indexBuffer: WebGLBuffer;\n  framebuffer: WebGLFramebuffer;\n  outputTexture: WebGLTexture|null = null;\n  program: WebGLProgram|null = null;\n  private disposed = false;\n  private disjoint: boolean;\n  private vertexShader: WebGLShader;\n  textureConfig: TextureConfig;\n\n  constructor(gl?: WebGLRenderingContext) {\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n\n      this.textureFloatExtension =\n          webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support half float textures, yet the ' +\n            'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support color renderable half floats, yet ' +\n            'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n\n    this.textureConfig =\n        tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  private get debug(): boolean {\n    return env().getBool('DEBUG');\n  }\n\n  public dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n          ' This is probably a resource leak, delete the program with ' +\n          'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound output matrix ' +\n          'texture.  This is probably a resource leak, delete the output ' +\n          'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n          'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  public createFloat32MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createFloat16MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createUnsignedBytesMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public uploadPixelDataToTexture(\n      texture: WebGLTexture,\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      ImageBitmap) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  public uploadDenseMatrixToTexture(\n      texture: WebGLTexture, width: number, height: number, data: TypedArray) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(\n        this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  public createFloat16PackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createPackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public deleteMatrixTexture(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  public downloadByteEncodedFloatMatrixFromOutputTexture(\n      texture: WebGLTexture, rows: number, columns: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(\n            this.gl, rows, columns, this.textureConfig));\n  }\n\n  public downloadPackedMatrixFromBuffer(\n      buffer: WebGLBuffer, batch: number, rows: number, columns: number,\n      physicalRows: number, physicalCols: number): Float32Array {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(\n        this.gl, buffer, batch, rows, columns, physicalRows, physicalCols,\n        this.textureConfig);\n  }\n\n  public downloadFloat32MatrixFromBuffer(buffer: WebGLBuffer, size: number):\n      Float32Array {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  public createBufferFromTexture(\n      texture: WebGLTexture, rows: number, columns: number): WebGLBuffer {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(\n        this.gl as WebGL2RenderingContext, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  public createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let query: WebGLQuery|WebGLSync;\n    let isFencePassed: () => boolean;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl as WebGL2RenderingContext;\n\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED ||\n            status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (\n        env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(\n          query,\n          env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {query, isFencePassed};\n  }\n\n  public downloadMatrixFromPackedTexture(\n      texture: WebGLTexture, physicalRows: number,\n      physicalCols: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadMatrixFromPackedOutputTexture(\n            this.gl, physicalRows, physicalCols));\n  }\n\n  private vertexAttrsAreBound = false;\n\n  public createProgram(fragmentShaderSource: string): WebGLProgram {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    const fragmentShader: WebGLShader =\n        webgl_util.createFragmentShader(gl, fragmentShaderSource);\n    if (this.vertexShader == null) {\n      this.vertexShader = gpgpu_util.createVertexShader(gl);\n    }\n    const program: WebGLProgram = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(\n        gl, () => gl.attachShader(program, this.vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program);\n    }\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(\n          gl, this.program, this.vertexBuffer);\n    }\n    return program;\n  }\n\n  public deleteProgram(program: WebGLProgram) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  public setProgram(program: WebGLProgram|null) {\n    this.throwIfDisposed();\n    this.program = program;\n    if ((this.program != null) && this.debug) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  public getUniformLocation(\n      program: WebGLProgram, uniformName: string,\n      shouldThrow = true): WebGLUniformLocation {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(\n          this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(\n          this.gl, program, uniformName);\n    }\n  }\n\n  public getAttributeLocation(program: WebGLProgram, attribute: string):\n      number {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(\n        this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  public getUniformLocationNoThrow(program: WebGLProgram, uniformName: string):\n      WebGLUniformLocation {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  public setInputMatrixTexture(\n      inputMatrixTexture: WebGLTexture, uniformLocation: WebGLUniformLocation,\n      textureUnit: number) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(\n        this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  public setOutputMatrixTexture(\n      outputMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  public setOutputPackedMatrixTexture(\n      outputPackedMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.throwIfDisposed();\n    const [width, height] =\n        tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  public setOutputMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    this.setOutputMatrixWriteRegionDriver(\n        startColumn, startRow, numColumns, numRows);\n  }\n\n  public setOutputPackedMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  public debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  public executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(\n        gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  public blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  private getQueryTimerExtension(): WebGL1DisjointQueryTimerExtension\n      |WebGL2DisjointQueryTimerExtension {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension =\n          webgl_util.getExtensionOrThrow(\n              this.gl,\n              env().getNumber(\n                  'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                  'EXT_disjoint_timer_query_webgl2' :\n                  'EXT_disjoint_timer_query') as\n              WebGL1DisjointQueryTimerExtension |\n          WebGL2DisjointQueryTimerExtension;\n    }\n    return this.disjointQueryTimerExtension;\n  }\n\n  private getQueryTimerExtensionWebGL2(): WebGL2DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension();\n  }\n\n  private getQueryTimerExtensionWebGL1(): WebGL1DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension() as WebGL1DisjointQueryTimerExtension;\n  }\n\n  beginQuery(): WebGLQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT() as WebGLQuery;\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  public async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await util.repeatedTry(\n        () => this.disposed ||  // while testing contexts are created / disposed\n                                // in rapid succession, so without this check we\n                                // may poll for the query timer indefinitely\n            this.isQueryAvailable(\n                query,\n                env().getNumber(\n                    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(\n        query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  private getQueryTime(query: WebGLQuery, queryTimerVersion: number): number {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const timeElapsedNanos =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  private isQueryAvailable(query: WebGLQuery, queryTimerVersion: number):\n      boolean {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const available =\n          gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const available =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  private bindTextureToFrameBuffer(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(\n        this.gl, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  private unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(\n          this.gl, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  private downloadMatrixDriver(\n      texture: WebGLTexture,\n      downloadAndDecode: () => Float32Array): Float32Array {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n\n    return result;\n  }\n\n  private setOutputMatrixTextureDriver(\n      outputMatrixTextureMaybePacked: WebGLTexture, width: number,\n      height: number) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(\n        gl, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  private setOutputMatrixWriteRegionDriver(\n      x: number, y: number, width: number, height: number) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(\n        this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  private throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  private throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean,\n  resolveFn: () => void\n};\n\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nconst {getBroadcastDims} = backend_util;\nimport {getGlslDifferences, GLSL} from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\n\nexport type ShapeInfo = {\n  logicalShape: number[],\n  texShape: [number, number],\n  isUniform: boolean,\n  isPacked: boolean,\n  flatOffset: number\n};\n\nexport type InputInfo = {\n  name: string,\n  shapeInfo: ShapeInfo\n};\n\nexport function makeShader(\n    inputsInfo: InputInfo[], outputShape: ShapeInfo, userCode: string,\n    usesPackedTextures: boolean): string {\n  const prefixSnippets: string[] = [];\n  inputsInfo.forEach(x => {\n    const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n\n    // Snippet when we decided to upload the values as uniform.\n    if (x.shapeInfo.isUniform) {\n      prefixSnippets.push(\n          `uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);\n    } else {\n      prefixSnippets.push(`uniform sampler2D ${x.name};`);\n      prefixSnippets.push(`uniform int offset${x.name};`);\n    }\n  });\n  const inputPrefixSnippet = prefixSnippets.join('\\n');\n\n  const inputSamplingSnippet =\n      inputsInfo\n          .map(x => getInputSamplingSnippet(x, outputShape, usesPackedTextures))\n          .join('\\n');\n  const outTexShape = outputShape.texShape;\n  const glsl = getGlslDifferences();\n  const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n  let outputSamplingSnippet: string;\n  let floatTextureSetOutputSnippet: string;\n  let shaderPrefix = getShaderPrefix(glsl);\n\n  if (outputShape.isPacked) {\n    outputSamplingSnippet =\n        getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n  } else {\n    outputSamplingSnippet =\n        getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n  }\n\n  if (usesPackedTextures) {\n    shaderPrefix += SHADER_PACKED_PREFIX;\n  }\n\n  const source = [\n    shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n    inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode\n  ].join('\\n');\n  return source;\n}\n\nfunction getSamplerFromInInfo(inInfo: InputInfo): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getSamplerScalar(inInfo);\n    case 1:\n      return getSampler1D(inInfo);\n    case 2:\n      return getSampler2D(inInfo);\n    case 3:\n      return getSampler3D(inInfo);\n    case 4:\n      return getSampler4D(inInfo);\n    case 5:\n      return getSampler5D(inInfo);\n    case 6:\n      return getSampler6D(inInfo);\n    default:\n      throw new Error(\n          `${shape.length}-D input sampling` +\n          ` is not yet supported`);\n  }\n}\n\nfunction getPackedSamplerFromInInfo(inInfo: InputInfo): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getPackedSamplerScalar(inInfo);\n    case 1:\n      return getPackedSampler1D(inInfo);\n    case 2:\n      return getPackedSampler2D(inInfo);\n    case 3:\n      return getPackedSampler3D(inInfo);\n    default:\n      return getPackedSamplerND(inInfo);\n  }\n}\n\nfunction getInputSamplingSnippet(\n    inInfo: InputInfo, outShapeInfo: ShapeInfo,\n    usesPackedTextures = false): string {\n  let res = '';\n  if (usesPackedTextures) {\n    res += getPackedSamplerFromInInfo(inInfo);\n  } else {\n    res += getSamplerFromInInfo(inInfo);\n  }\n\n  const inShape = inInfo.shapeInfo.logicalShape;\n  const outShape = outShapeInfo.logicalShape;\n  if (inShape.length <= outShape.length) {\n    if (usesPackedTextures) {\n      res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n    } else {\n      res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n    }\n  }\n  return res;\n}\n\nfunction getPackedOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number]): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutputPacked1DCoords(outShape as [number], outTexShape);\n    case 2:\n      return getOutputPacked2DCoords(outShape as [number, number], outTexShape);\n    case 3:\n      return getOutputPacked3DCoords(\n          outShape as [number, number, number], outTexShape);\n    default:\n      return getOutputPackedNDCoords(outShape, outTexShape);\n  }\n}\n\nfunction getOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number]): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutput1DCoords(outShape as [number], outTexShape);\n    case 2:\n      return getOutput2DCoords(outShape as [number, number], outTexShape);\n    case 3:\n      return getOutput3DCoords(\n          outShape as [number, number, number], outTexShape);\n    case 4:\n      return getOutput4DCoords(\n          outShape as [number, number, number, number], outTexShape);\n    case 5:\n      return getOutput5DCoords(\n          outShape as [number, number, number, number, number], outTexShape);\n    case 6:\n      return getOutput6DCoords(\n          outShape as [number, number, number, number, number, number],\n          outTexShape);\n    default:\n      throw new Error(\n          `${outShape.length}-D output sampling is not yet supported`);\n  }\n}\n\nfunction getFloatTextureSampleSnippet(glsl: GLSL): string {\n  return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${glsl.texture2D}(textureSampler, uv).r;\n    }\n  `;\n}\n\nfunction getFloatTextureSetRSnippet(glsl: GLSL): string {\n  return `\n    void setOutput(float val) {\n      ${glsl.output} = vec4(val, 0, 0, 0);\n    }\n  `;\n}\n\nfunction getFloatTextureSetRGBASnippet(glsl: GLSL): string {\n  return `\n    void setOutput(vec4 val) {\n      ${glsl.output} = val;\n    }\n  `;\n}\n\nfunction getShaderPrefix(glsl: GLSL): string {\n  const SHADER_PREFIX = `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFs} vec2 resultUV;\n    ${glsl.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${glsl.defineSpecialNaN}\n    ${glsl.defineSpecialInf}\n    ${glsl.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;\n\n  return SHADER_PREFIX;\n}\n\nconst SAMPLE_1D_SNIPPET = `\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_2D_SNIPPET = `\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_3D_SNIPPET = `\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SHADER_PACKED_PREFIX = `\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;\n\nfunction getOutputScalarCoords() {\n  return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\n\nfunction getOutputPacked1DCoords(\n    shape: [number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (packedTexShape[0] === 1) {\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);\n      }\n    `;\n  }\n\n  if (packedTexShape[1] === 1) {\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);\n      }\n    `;\n  }\n\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);\n    }\n  `;\n}\n\nfunction getOutput1DCoords(\n    shape: [number], texShape: [number, number]): string {\n  if (texShape[0] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n  }\n  if (texShape[1] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n  }\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\n\nfunction getOutputPacked3DCoords(\n    shape: [number, number, number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getOutput3DCoords(\n    shape: [number, number, number], texShape: [number, number]): string {\n  const coordsFromIndexSnippet =\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n\nfunction getOutputPackedNDCoords(\n    shape: number[], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n  const texelsInBatch =\n      texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n  let texelsInBatchN = texelsInBatch;\n  let batches = ``;\n  let coords = 'b, r, c';\n\n  for (let b = 2; b < shape.length - 1; b++) {\n    texelsInBatchN *= shape[shape.length - b - 1];\n    batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n    coords = `b${b}, ` + coords;\n  }\n\n  return `\n    ivec${shape.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      ${batches}\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec${shape.length}(${coords});\n    }\n  `;\n}\n\nfunction getOutput4DCoords(\n    shape: [number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2'], shape);\n\n  return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\n\nfunction getOutput5DCoords(\n    shape: [number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3'], shape);\n\n  return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\n\nfunction getOutput6DCoords(\n    shape: [number, number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n\n  return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `;\n}\n\nfunction getOutputPacked2DCoords(\n    shape: [number, number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (util.arraysEqual(shape, texShape)) {\n    return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${\n        packedTexShape[1]}));\n      }\n    `;\n  }\n\n  // texels needed to accommodate a logical row\n  const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n  /**\n   * getOutputCoords\n   *\n   * resTexRC: The rows and columns of the texels. If you move over one\n   * texel to the right in the packed texture, you are moving over one column\n   * (not two).\n   *\n   * index: The texel index\n   */\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getOutput2DCoords(\n    shape: [number, number], texShape: [number, number]): string {\n  if (util.arraysEqual(shape, texShape)) {\n    return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n  }\n  if (shape[1] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n  }\n  if (shape[0] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n  }\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getFlatOffsetUniformName(texName: string): string {\n  return `offset${texName}`;\n}\n\nfunction getPackedSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const glsl = getGlslDifferences();\n  return `\n    vec4 ${funcName}() {\n      return ${glsl.texture2D}(${texName}, halfCR);\n    }\n  `;\n}\n\nfunction getSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  if (inputInfo.shapeInfo.isUniform) {\n    return `float ${funcName}() {return ${texName};}`;\n  }\n  const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;\n  if (texNumR === 1 && texNumC === 1) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n\n  const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler1D(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const glsl = getGlslDifferences();\n\n  return `\n    vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler1D(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int index) {\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const tNumR = texShape[0];\n  const tNumC = texShape[1];\n\n  if (tNumC === 1 && tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  if (tNumC === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler2D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const glsl = getGlslDifferences();\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n  }\n\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const valuesPerRow = Math.ceil(shape[1] / 2);\n\n  return `\n    vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${\n      packedTexShape[1]}, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler2D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const offset = getFlatOffsetUniformName(texName);\n  if (texNumC === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n  if (texNumR === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  return `\n  float ${funcName}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${shape[1]} + col + ${offset};\n    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\n\nfunction getPackedSampler3D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  if (shape[0] === 1) {\n    const squeezedShape = shape.slice(1);\n    const keptDims = [1, 2];\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['b', 'row', 'col'];\n    return `\n        ${getPackedSamplerFromInInfo(newInputInfo)}\n        vec4 ${funcName}(int b, int row, int col) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n  const glsl = getGlslDifferences();\n\n  return `\n    vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler3D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride0 = shape[1] * shape[2];\n  const stride1 = shape[2];\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col', 'depth'];\n    return `\n        ${getSamplerFromInInfo(newInputInfo)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${stride0}, ${stride1}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n        float ${funcName}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n  }\n\n  if (texNumC === stride1 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n      float ${funcName}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};\n        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\n\nfunction getPackedSamplerND(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const rank = shape.length;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n  let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n  let params = `int b, int row, int col`;\n  let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n  for (let b = 2; b < rank - 1; b++) {\n    params = `int b${b}, ` + params;\n    texelsInBatch *= shape[rank - b - 1];\n    index = `b${b} * ${texelsInBatch} + ` + index;\n  }\n  const glsl = getGlslDifferences();\n  return `\n    vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler4D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride2 = shape[3];\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${stride1}, ${stride2}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride2 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} +\n          depth * ${stride2} + depth2;\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler5D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride3 = shape[4];\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          depth3;\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${stride1}, ${stride2}, ${stride3}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  if (texNumC === stride3 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3]},\n               ${shape[2] * shape[3]}, ${shape[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler6D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  const stride4 = shape[5];\n  const stride3 = shape[4] * stride4;\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${stride4}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride4 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},\n               ${shape[2] * shape[3] * shape[4]},\n               ${shape[3] * shape[4]},\n               ${shape[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getUniformSampler(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n\n  if (inSize < 2) {\n    return `return ${texName};`;\n  }\n  return `\n    for (int i = 0; i < ${inSize}; i++) {\n      if (i == index) {\n        return ${texName}[i];\n      }\n    }\n  `;\n}\n\nfunction getPackedSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n\n  const type = getCoordsDataType(outRank);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  let output = `return outputValue;`;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n  const isInputScalar = inSize === 1;\n  const outSize = util.sizeFromShape(outShapeInfo.logicalShape);\n  const isOutputScalar = outSize === 1;\n\n  if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n    output = `\n      return vec4(outputValue.xy, outputValue.xy);\n    `;\n  } else if (isInputScalar && !isOutputScalar) {\n    if (outRank === 1) {\n      output = `\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;\n    } else {\n      output = `\n        return vec4(outputValue.x);\n      `;\n    }\n  } else if (broadcastDims.length) {\n    const rows = inRank - 2;\n    const cols = inRank - 1;\n\n    if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.x);`;\n    } else if (broadcastDims.indexOf(rows) > -1) {\n      output = `return vec4(outputValue.x, outputValue.y, ` +\n          `outputValue.x, outputValue.y);`;\n    } else if (broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.xx, outputValue.zz);`;\n    }\n  }\n\n  return `\n    vec4 ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});\n      ${output}\n    }\n  `;\n}\n\nfunction getSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const outTexShape = outShapeInfo.texShape;\n  const inTexShape = inputInfo.shapeInfo.texShape;\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n      inputInfo.shapeInfo.flatOffset == null &&\n      util.arraysEqual(inTexShape, outTexShape)) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n  }\n\n  const type = getCoordsDataType(outRank);\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(\n    inInfo: InputInfo, squeezedShape: number[]): InputInfo {\n  // Deep copy.\n  const newInputInfo: InputInfo = JSON.parse(JSON.stringify(inInfo));\n  newInputInfo.shapeInfo.logicalShape = squeezedShape;\n  return newInputInfo;\n}\n\nfunction getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map(d => params[d]).join(', ');\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, Tensor, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport * as shader_compiler from './shader_compiler';\nimport {InputInfo, ShapeInfo} from './shader_compiler';\nimport {PackingScheme, TextureData, TextureUsage} from './tex_util';\n\nexport interface GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  /** If true, this program expects packed input textures. Defaults to false. */\n  packedInputs?: boolean;\n  /** If true, this program produces a packed texture. Defaults to false. */\n  packedOutput?: boolean;\n  /**\n   * Affects what type of texture we allocate for the output. Defaults to\n   * `TextureUsage.RENDER`.\n   */\n  outTexUsage?: TextureUsage;\n  /**\n   * The type of scheme to use when packing texels for the output values.\n   * See `PackingScheme` for details. Defaults to `PackingScheme.SHARED_BATCH`.\n   */\n  outPackingScheme?: PackingScheme;\n}\n\nexport interface GPGPUBinary {\n  webGLProgram: WebGLProgram;\n  program: GPGPUProgram;\n  uniformLocations: {[name: string]: WebGLUniformLocation};\n  source: string;\n  inShapeInfos: ShapeInfo[];\n  outShapeInfo: ShapeInfo;\n  infLoc: WebGLUniformLocation;\n  nanLoc: WebGLUniformLocation;\n}\n\nexport interface TensorData {\n  shape: number[];\n  texData: TextureData;\n  isUniform: boolean;\n  // Available when we decide to upload as uniform instead of texture.\n  uniformValues?: TypedArray;\n}\n\nexport function compileProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, program: GPGPUProgram, inputs: TensorData[],\n    output: TensorData): GPGPUBinary {\n  const userCode = program.userCode;\n  const inputInfos: InputInfo[] = inputs.map((input, i) => {\n    const shapeInfo: ShapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n    if (input.texData != null && input.texData.slice != null &&\n        input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n    return {name: program.variableNames[i], shapeInfo};\n  });\n  const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n  const outShapeInfo: ShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  const source = shader_compiler.makeShader(\n      inputInfos, outShapeInfo, userCode, program.packedInputs);\n\n  const webGLProgram = gpgpu.createProgram(source);\n\n  // Add special uniforms (NAN, INFINITY)\n  let infLoc: WebGLUniformLocation = null;\n  const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  }\n\n  // Add user-defined uniforms\n  const uniformLocations: {[name: string]: WebGLUniformLocation} = {};\n  for (let i = 0; i < program.variableNames.length; i++) {\n    const varName = program.variableNames[i];\n    const shouldThrow = false;\n    uniformLocations[varName] =\n        gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[`offset${varName}`] =\n        gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n  }\n\n  return {\n    program,\n    source,\n    webGLProgram,\n    uniformLocations,\n    inShapeInfos,\n    outShapeInfo,\n    infLoc,\n    nanLoc,\n  };\n}\n\nfunction validateBinaryAndProgram(\n    shapeInfos: ShapeInfo[], inputs: TensorData[]) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(\n        `Binary was compiled with ${shapeInfos.length} inputs, but ` +\n        `was executed with ${inputs.length} inputs`);\n  }\n\n  shapeInfos.forEach((s, i) => {\n    const shapeA = s.logicalShape;\n    const input = inputs[i];\n    const shapeB = input.shape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(\n          `Binary was compiled with different shapes than ` +\n          `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n    }\n    // The input is uploaded as uniform.\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n\n    const texShapeA = s.texShape;\n    const texShapeB = input.isUniform ? null : input.texData.texShape;\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(\n          `Binary was compiled with different texture shapes than the` +\n          ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n    }\n  });\n}\n\nexport function runProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, binary: GPGPUBinary, inputs: TensorData[],\n    output: TensorData,\n    customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) =>\n        void): void {\n  validateBinaryAndProgram(binary.inShapeInfos, inputs);\n  validateBinaryAndProgram([binary.outShapeInfo], [output]);\n\n  const outTex = output.texData.texture;\n  const outTexShape = output.texData.texShape;\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  }\n  gpgpu.setProgram(binary.webGLProgram);\n\n  // Set special uniforms (NAN, INFINITY)\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  }\n\n  // Set user-defined inputs\n  inputs.forEach((input, i) => {\n    const varName = binary.program.variableNames[i];\n    const varLoc = binary.uniformLocations[varName];\n    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        let vals = input.uniformValues;\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n      return;\n    }\n\n    // If the input was sliced, upload the flat offset index.\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n\n    gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n  });\n\n  if (customSetup != null) {\n    customSetup(gpgpu, binary.webGLProgram);\n  }\n  gpgpu.executeProgram();\n}\n\nexport function makeShaderKey(\n    program: GPGPUProgram, inputs: TensorData[], output: TensorData): string {\n  let keyInputs = '';\n  inputs.concat(output).forEach(x => {\n    const hasOffset = x.texData != null && x.texData.slice != null &&\n        x.texData.slice.flatOffset > 0;\n    const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n    keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n  });\n  const keyUserCode = program.userCode;\n  let key = program.constructor.name;\n  // Fast string concat. See https://jsperf.com/string-concatenation/14.\n  key += '_' + keyInputs + '_' + keyUserCode;\n  return key;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nexport function createSimpleBinaryKernelImpl(op) {\n    return (aShape, bShape, aVals, bVals, dtype) => {\n        const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const resultRank = newShape.length;\n        const resultStrides = util.computeStrides(newShape);\n        const resultSize = util.sizeFromShape(newShape);\n        const result = util.getTypedArrayFromDType(dtype, resultSize);\n        const aRank = aShape.length;\n        const bRank = bShape.length;\n        const aStrides = util.computeStrides(aShape);\n        const bStrides = util.computeStrides(bShape);\n        const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < result.length; ++i) {\n                result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            for (let i = 0; i < result.length; ++i) {\n                const loc = util.indexToLoc(i, resultRank, resultStrides);\n                const aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n                const bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n                result[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return [result, newShape];\n    };\n}\n//# sourceMappingURL=binary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Add } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/binary_utils';\nexport const addImpl = createSimpleBinaryKernelImpl(((a, b) => a + b));\nexport const addComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return { real: aReal + bReal, imag: aImag + bImag };\n}));\nexport const add = binaryKernelFunc(Add, addImpl, addComplexImpl);\nexport const addConfig = {\n    kernelName: Add,\n    backendName: 'cpu',\n    kernelFunc: add\n};\n//# sourceMappingURL=Add.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for unary op.\n */\nexport function createSimpleUnaryImpl(op) {\n    return (values, dtype, attrs) => {\n        const newValues = util.getTypedArrayFromDType(dtype, values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return newValues;\n    };\n}\n//# sourceMappingURL=unary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Ceil } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));\nexport const ceil = unaryKernelFuncFromImpl(Ceil, ceilImpl);\nexport const ceilConfig = {\n    kernelName: Ceil,\n    backendName: 'cpu',\n    kernelFunc: ceil,\n};\n//# sourceMappingURL=Ceil.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Exp } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));\nexport const exp = unaryKernelFuncFromImpl(Exp, expImpl);\nexport const expConfig = {\n    kernelName: Exp,\n    backendName: 'cpu',\n    kernelFunc: exp,\n};\n//# sourceMappingURL=Exp.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Expm1 } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));\nexport const expm1 = unaryKernelFuncFromImpl(Expm1, expm1Impl);\nexport const expm1Config = {\n    kernelName: Expm1,\n    backendName: 'cpu',\n    kernelFunc: expm1,\n};\n//# sourceMappingURL=Expm1.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Floor } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));\nexport const floor = unaryKernelFuncFromImpl(Floor, floorImpl);\nexport const floorConfig = {\n    kernelName: Floor,\n    backendName: 'cpu',\n    kernelFunc: floor,\n};\n//# sourceMappingURL=Floor.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Greater } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const greaterImpl = createSimpleBinaryKernelImpl((a, b) => (a > b) ? 1 : 0);\nexport const greater = binaryKernelFunc(Greater, greaterImpl, null /* complexImpl */, 'bool');\nexport const greaterConfig = {\n    kernelName: Greater,\n    backendName: 'cpu',\n    kernelFunc: greater\n};\n//# sourceMappingURL=Greater.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Less } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const lessImpl = createSimpleBinaryKernelImpl((a, b) => (a < b) ? 1 : 0);\nexport const less = binaryKernelFunc(Less, lessImpl, null /* complexImpl */, 'bool');\nexport const lessConfig = {\n    kernelName: Less,\n    backendName: 'cpu',\n    kernelFunc: less\n};\n//# sourceMappingURL=Less.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Log } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));\nexport const log = unaryKernelFuncFromImpl(Log, logImpl);\nexport const logConfig = {\n    kernelName: Log,\n    backendName: 'cpu',\n    kernelFunc: log,\n};\n//# sourceMappingURL=Log.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Maximum } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const maximumImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => Math.max(aValue, bValue)));\nexport const maximum = binaryKernelFunc(Maximum, maximumImpl);\nexport const maximumConfig = {\n    kernelName: Maximum,\n    backendName: 'cpu',\n    kernelFunc: maximum\n};\n//# sourceMappingURL=Maximum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Minimum } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const minimumImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => Math.min(aValue, bValue)));\nexport const minimum = binaryKernelFunc(Minimum, minimumImpl);\nexport const minimumConfig = {\n    kernelName: Minimum,\n    backendName: 'cpu',\n    kernelFunc: minimum\n};\n//# sourceMappingURL=Minimum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Multiply } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/binary_utils';\nexport const multiplyImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue * bValue));\nexport const multiplyComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return {\n        real: aReal * bReal - aImag * bImag,\n        imag: aReal * bImag + aImag * bReal\n    };\n}));\nexport const multiply = binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);\nexport const multiplyConfig = {\n    kernelName: Multiply,\n    backendName: 'cpu',\n    kernelFunc: multiply\n};\n//# sourceMappingURL=Multiply.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Rsqrt } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));\nexport const rsqrt = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);\nexport const rsqrtConfig = {\n    kernelName: Rsqrt,\n    backendName: 'cpu',\n    kernelFunc: rsqrt,\n};\n//# sourceMappingURL=Rsqrt.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sub } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/binary_utils';\nexport const subImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue - bValue));\nexport const subComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return { real: aReal - bReal, imag: aImag - bImag };\n}));\nexport const sub = binaryKernelFunc(Sub, subImpl, subComplexImpl);\nexport const subConfig = {\n    kernelName: Sub,\n    backendName: 'cpu',\n    kernelFunc: sub\n};\n//# sourceMappingURL=Sub.js.map","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import shared functionality from tfjs-backend-cpu without triggering\n// side effects.\n// tslint:disable-next-line: no-imports-from-dist\nimport * as shared from '@tensorflow/tfjs-backend-cpu/dist/shared';\n// tslint:disable-next-line: no-imports-from-dist\nimport {SimpleBinaryKernelImpl} from '@tensorflow/tfjs-backend-cpu/dist/shared';\n// tslint:disable-next-line: no-imports-from-dist\nimport {SimpleUnaryImpl} from '@tensorflow/tfjs-backend-cpu/dist/utils/unary_types';\n\nexport type SimpleBinaryKernelImplCPU = SimpleBinaryKernelImpl;\nexport type SimpleUnaryKernelImplCPU = SimpleUnaryImpl;\nconst {\n  addImpl: addImplCPU,\n  bincountImpl: bincountImplCPU,\n  bincountReduceImpl: bincountReduceImplCPU,\n  ceilImpl: ceilImplCPU,\n  concatImpl: concatImplCPU,\n  expImpl: expImplCPU,\n  expm1Impl: expm1ImplCPU,\n  floorImpl: floorImplCPU,\n  gatherV2Impl: gatherV2ImplCPU,\n  greaterImpl: greaterImplCPU,\n  lessImpl: lessImplCPU,\n  linSpaceImpl: linSpaceImplCPU,\n  logImpl: logImplCPU,\n  maxImpl: maxImplCPU,\n  maximumImpl: maximumImplCPU,\n  minimumImpl: minimumImplCPU,\n  multiplyImpl: multiplyImplCPU,\n  negImpl: negImplCPU,\n  prodImpl: prodImplCPU,\n  rangeImpl: rangeImplCPU,\n  rsqrtImpl: rsqrtImplCPU,\n  simpleAbsImpl: simpleAbsImplCPU,\n  sliceImpl: sliceImplCPU,\n  sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU,\n  sparseReshapeImpl: sparseReshapeImplCPU,\n  stridedSliceImpl: stridedSliceImplCPU,\n  subImpl: subImplCPU,\n  tileImpl: tileImplCPU,\n  topKImpl: topKImplCPU,\n  transposeImpl: transposeImplCPU,\n  uniqueImpl: uniqueImplCPU,\n} = shared;\n\nexport {\n  addImplCPU,\n  bincountImplCPU,\n  bincountReduceImplCPU,\n  ceilImplCPU,\n  concatImplCPU,\n  expImplCPU,\n  expm1ImplCPU,\n  floorImplCPU,\n  gatherV2ImplCPU,\n  greaterImplCPU,\n  lessImplCPU,\n  linSpaceImplCPU,\n  logImplCPU,\n  maxImplCPU,\n  maximumImplCPU,\n  minimumImplCPU,\n  multiplyImplCPU,\n  negImplCPU,\n  prodImplCPU,\n  simpleAbsImplCPU,\n  sliceImplCPU,\n  sparseFillEmptyRowsImplCPU,\n  sparseReshapeImplCPU,\n  stridedSliceImplCPU,\n  subImplCPU,\n  rangeImplCPU,\n  rsqrtImplCPU,\n  tileImplCPU,\n  topKImplCPU,\n  transposeImplCPU,\n  uniqueImplCPU,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, util } from '@tensorflow/tfjs-core';\nexport function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {\n    const weightsSize = util.sizeFromShape(weightsShape);\n    const outVals = util.makeZerosTypedArray(size, weightsDtype);\n    for (let i = 0; i < xVals.length; i++) {\n        const value = xVals[i];\n        if (value < 0) {\n            throw new Error('Input x must be non-negative!');\n        }\n        if (value >= size) {\n            continue;\n        }\n        if (weightsSize > 0) {\n            outVals[value] += weightsVals[i];\n        }\n        else {\n            outVals[value] += 1;\n        }\n    }\n    return outVals;\n}\nexport function bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {\n    const numRows = xBuf.shape[0];\n    const numCols = xBuf.shape[1];\n    const outBuf = buffer([numRows, size], weightsBuf.dtype);\n    for (let i = 0; i < numRows; i++) {\n        for (let j = 0; j < numCols; j++) {\n            const value = xBuf.get(i, j);\n            if (value < 0) {\n                throw new Error('Input x must be non-negative!');\n            }\n            if (value >= size) {\n                continue;\n            }\n            if (binaryOutput) {\n                outBuf.set(1, i, value);\n            }\n            else {\n                if (weightsBuf.size > 0) {\n                    outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);\n                }\n                else {\n                    outBuf.set(outBuf.get(i, value) + 1, i, value);\n                }\n            }\n        }\n    }\n    return outBuf;\n}\n//# sourceMappingURL=Bincount_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function concatImpl(inputs, outShape, dtype, simplyConcat) {\n    const outVals = util.getArrayFromDType(dtype, util.sizeFromShape(outShape));\n    if (simplyConcat && dtype !== 'string') {\n        // Use built-in TypedArray.set() method for speed.\n        let offset = 0;\n        inputs.forEach(input => {\n            const size = util.sizeFromShape(input.shape);\n            outVals.set(input.vals, offset);\n            offset += size;\n        });\n    }\n    else {\n        let colOffset = 0;\n        inputs.forEach(input => {\n            const decodedData = dtype === 'string' ?\n                backend_util.fromUint8ToStringArray(input.vals) :\n                input.vals;\n            let tIdx = 0;\n            for (let row = 0; row < input.shape[0]; ++row) {\n                const resIdx = row * outShape[1] + colOffset;\n                for (let col = 0; col < input.shape[1]; ++col) {\n                    outVals[resIdx + col] = decodedData[tIdx++];\n                }\n            }\n            colOffset += input.shape[1];\n        });\n    }\n    return outVals;\n}\n//# sourceMappingURL=Concat_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {\n    const outBuf = buffer(flattenOutputShape, xBuf.dtype);\n    for (let i = 0; i < outBuf.size; ++i) {\n        const newLoc = outBuf.indexToLoc(i);\n        const originalLoc = newLoc.slice();\n        const batchIdx = originalLoc[0];\n        const indicesIdx = originalLoc[2];\n        const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);\n        originalLoc[2] = indicesBuf.values[indicesIndex];\n        const originalIndex = xBuf.locToIndex(originalLoc);\n        outBuf.values[i] = xBuf.values[originalIndex];\n    }\n    return outBuf;\n}\n//# sourceMappingURL=GatherV2_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function linSpaceImpl(start, stop, num) {\n    const step = (stop - start) / (num - 1);\n    const values = util.makeZerosTypedArray(num, 'float32');\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n//# sourceMappingURL=LinSpace_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function maxImpl(aVals, reduceSize, outShape, dtype) {\n    const vals = util.getTypedArrayFromDType(dtype, util.sizeFromShape(outShape));\n    for (let i = 0; i < vals.length; ++i) {\n        const offset = i * reduceSize;\n        let max = aVals[offset];\n        for (let j = 0; j < reduceSize; ++j) {\n            const value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n            }\n        }\n        vals[i] = max;\n    }\n    return vals;\n}\n//# sourceMappingURL=Max_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Neg, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { multiplyImpl } from './Multiply';\nexport function negImpl(xVals, xShape, xDtype) {\n    const minusOne = util.createScalarValue(-1, xDtype);\n    return multiplyImpl([], xShape, minusOne, xVals, xDtype);\n}\nexport function neg(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    assertNotComplex(x, 'neg');\n    const xVals = backend.data.get(x.dataId).values;\n    const [res, newShape] = negImpl(xVals, x.shape, x.dtype);\n    return backend.makeTensorInfo(newShape, x.dtype, res);\n}\nexport const negConfig = {\n    kernelName: Neg,\n    backendName: 'cpu',\n    kernelFunc: neg\n};\n//# sourceMappingURL=Neg.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function prodImpl(xShape, xDtype, xVals, reductionAxes) {\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n    const outDtype = upcastType(xDtype, 'int32');\n    const outVals = util.makeZerosTypedArray(util.sizeFromShape(outShape), outDtype);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    for (let i = 0; i < outVals.length; ++i) {\n        const offset = i * reduceSize;\n        let prod = 1;\n        for (let j = 0; j < reduceSize; ++j) {\n            prod *= xVals[offset + j];\n        }\n        outVals[i] = prod;\n    }\n    return { outVals, outShape, outDtype };\n}\nexport function prod(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    assertNotComplex(x, 'prod');\n    const xRank = x.shape.length;\n    const axes = util.parseAxisParam(axis, x.shape);\n    const permutation = backend_util.getAxesPermutation(axes, xRank);\n    let reductionAxes = axes;\n    let permutedX = x;\n    const intermediateTensorInfos = [];\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutation } });\n        intermediateTensorInfos.push(permutedX);\n        reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n    }\n    const xVals = backend.data.get(permutedX.dataId).values;\n    const { outVals, outShape, outDtype } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n    let resultShape = outShape;\n    if (keepDims) {\n        resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n    }\n    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nexport const prodConfig = {\n    kernelName: Prod,\n    backendName: 'cpu',\n    kernelFunc: prod\n};\n//# sourceMappingURL=Prod.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function rangeImpl(start, stop, step, dtype) {\n    const sameStartStop = start === stop;\n    const increasingRangeNegativeStep = start < stop && step < 0;\n    const decreasingRangePositiveStep = stop < start && step > 1;\n    if (sameStartStop || increasingRangeNegativeStep ||\n        decreasingRangePositiveStep) {\n        return util.makeZerosTypedArray(0, dtype);\n    }\n    const numElements = Math.abs(Math.ceil((stop - start) / step));\n    const values = util.makeZerosTypedArray(numElements, dtype);\n    if (stop < start && step === 1) {\n        // Auto adjust the step's sign if it hasn't been set\n        // (or was set to 1)\n        step = -1;\n    }\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n//# sourceMappingURL=Range_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Abs, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function simpleAbsImpl(vals) {\n    const resultValues = new Float32Array(vals.length);\n    for (let i = 0; i < vals.length; ++i) {\n        resultValues[i] = Math.abs(vals[i]);\n    }\n    return resultValues;\n}\nexport const abs = (args) => {\n    const { x } = args.inputs;\n    const cpuBackend = args.backend;\n    assertNotComplex(x, 'abs');\n    let resultValues = new Float32Array(util.sizeFromShape(x.shape));\n    const values = cpuBackend.data.get(x.dataId).values;\n    resultValues = simpleAbsImpl(values);\n    return cpuBackend.makeOutput(resultValues, x.shape, 'float32');\n};\nexport const absConfig = {\n    kernelName: Abs,\n    backendName: 'cpu',\n    kernelFunc: abs,\n};\n//# sourceMappingURL=Abs.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function sliceImpl(vals, begin, size, shape, dtype) {\n    const isContinous = slice_util.isSliceContinous(shape, begin, size);\n    const length = util.sizeFromShape(size);\n    const xStrides = util.computeStrides(shape);\n    if (isContinous) {\n        const flatOffset = slice_util.computeFlatOffset(begin, xStrides);\n        if (dtype === 'string') {\n            return vals.slice(flatOffset, flatOffset + length);\n        }\n        return vals.subarray(flatOffset, flatOffset + length);\n    }\n    const decodedData = dtype === 'string' ?\n        backend_util.fromUint8ToStringArray(vals) :\n        vals;\n    const inBuf = buffer(shape, dtype, decodedData);\n    const outBuf = buffer(size, dtype);\n    for (let i = 0; i < outBuf.size; ++i) {\n        const outLoc = outBuf.indexToLoc(i);\n        const inLoc = outLoc.map((idx, j) => idx + begin[j]);\n        outBuf.set(inBuf.get(...inLoc), ...outLoc);\n    }\n    if (dtype === 'string') {\n        return backend_util.fromStringArrayToUint8(outBuf.values);\n    }\n    return outBuf.values;\n}\nexport function slice(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { begin, size } = attrs;\n    assertNotComplex(x, 'slice');\n    const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n    slice_util.assertParamsValid(x, $begin, $size);\n    const vals = backend.data.get(x.dataId).values;\n    const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outVals);\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'cpu',\n    kernelFunc: slice\n};\n//# sourceMappingURL=Slice.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseFillEmptyRowsImpl(indices, indicesShape, indicesDType, values, valuesDType, denseShape, defaultValue) {\n    const indicesCount = indicesShape[0];\n    const denseRows = denseShape[0];\n    const emptyRowIndicator = new Array(denseRows);\n    const reverseIndexMap = new Array(indicesCount);\n    const rank = indicesShape[1];\n    if (denseRows === 0) {\n        if (indicesCount !== 0) {\n            throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${indicesCount}`);\n        }\n        const outputIndices = util.getArrayFromDType(indicesDType, 0);\n        const outputValues = util.getArrayFromDType(valuesDType, 0);\n        return [\n            outputIndices, [0, rank], outputValues, emptyRowIndicator, reverseIndexMap\n        ];\n    }\n    let rowsAreOrdered = true;\n    let lastIndicesRow = 0;\n    const csrOffset = new Array(denseRows).fill(0);\n    for (let i = 0; i < indicesCount; ++i) {\n        // indices is a 2d tensor with shape of [N, rank]\n        const row = indices[i * rank];\n        if (row < 0) {\n            throw new Error(`indices(${i}, 0) is invalid: ${row} < 0`);\n        }\n        if (row >= denseRows) {\n            throw new Error(`indices(${i}, 0) is invalid: ${row} >= ${denseRows}`);\n        }\n        ++csrOffset[row];\n        rowsAreOrdered = rowsAreOrdered && (row >= lastIndicesRow);\n        lastIndicesRow = row;\n    }\n    let allRowsFull = true;\n    for (let row = 0; row < denseRows; ++row) {\n        // csrOffset here describes the number of elements in this dense row\n        const rowEmpty = (csrOffset[row] === 0);\n        emptyRowIndicator[row] = rowEmpty;\n        allRowsFull = allRowsFull && !rowEmpty;\n        // In filled version, each row has at least one element.\n        csrOffset[row] = Math.max(csrOffset[row], 1);\n        // Update csrOffset to represent the number of elements up to and\n        // including denseRows + 1:\n        //  csrOffset[0] == #{elements of row 0}\n        //  csrOffset[1] == #{elements of row 1} + #{elements of row 0}\n        //  ..\n        //  csrOffset[i] == starting index for elements in row i + 1.\n        if (row > 0) {\n            csrOffset[row] += csrOffset[row - 1];\n        }\n    }\n    if (allRowsFull && rowsAreOrdered) {\n        const outputIndices = indices;\n        const outputValues = values;\n        for (let i = 0; i < indicesCount; ++i) {\n            reverseIndexMap[i] = i;\n        }\n        return [\n            outputIndices, [indicesCount, rank], outputValues, emptyRowIndicator,\n            reverseIndexMap\n        ];\n    }\n    else {\n        const fullIndicesCount = csrOffset[denseRows - 1];\n        const outputIndices = util.getArrayFromDType(indicesDType, fullIndicesCount * rank);\n        const outputValues = util.getArrayFromDType(valuesDType, fullIndicesCount);\n        const filledCount = new Array(denseRows).fill(0);\n        // Fill in values for rows that are not missing\n        for (let i = 0; i < indicesCount; ++i) {\n            // indices is a 2d tensor with shape of [N, rank]\n            const row = indices[i * rank];\n            const offset = filledCount[row];\n            const outputI = ((row === 0) ? 0 : csrOffset[row - 1]) + offset;\n            filledCount[row]++; // Increment the filled count for this row.\n            for (let j = 0; j < rank; ++j) {\n                // indices and outputIndices are 2d tensors with shape of [N, rank]\n                outputIndices[outputI * rank + j] = indices[i * rank + j];\n            }\n            outputValues[outputI] = values[i];\n            // We'll need this reverse index map to backprop correctly.\n            reverseIndexMap[i] = outputI;\n        }\n        // Fill in values for rows that are missing\n        for (let row = 0; row < denseRows; ++row) {\n            const rowCount = filledCount[row];\n            if (rowCount === 0) { // We haven't filled this row\n                const startingIndex = (row === 0) ? 0 : csrOffset[row - 1];\n                // Remaining index values were set to zero already.\n                // Just need to set the row index in the right location.\n                // outputIndices is a 2d tensor with shape of [N, rank]\n                outputIndices[startingIndex * rank + 0] = row;\n                for (let col = 1; col < rank; ++col) {\n                    outputIndices[startingIndex * rank + col] = 0;\n                }\n                outputValues[startingIndex] = defaultValue;\n            }\n        }\n        return [\n            outputIndices, [indicesCount, rank], outputValues, emptyRowIndicator,\n            reverseIndexMap\n        ];\n    }\n}\n//# sourceMappingURL=SparseFillEmptyRows_impl.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {\n    const denseSize = util.sizeFromShape(inputShape);\n    const nnz = inputIndicesShape[0];\n    const outputRank = targetShape.length;\n    // Compute the output shape. Determine product of specified dimensions, and\n    // find the index of the unspecified one.\n    const outputShape = [];\n    let product = 1;\n    let unknownIndex = -1;\n    for (let d = 0; d < outputRank; ++d) {\n        const size = targetShape[d];\n        if (size === -1) {\n            if (unknownIndex !== -1) {\n                throw new Error(`only one output dimension may be -1, not both ${unknownIndex} and ${d}`);\n            }\n            unknownIndex = d;\n            outputShape.push(1);\n        }\n        else {\n            if (size < 0) {\n                throw new Error(`size ${d} must be non-negative, not ${size}`);\n            }\n            product *= size;\n            outputShape.push(size);\n        }\n    }\n    if (unknownIndex !== -1) {\n        if (product <= 0) {\n            throw new Error('reshape cannot infer the missing ' +\n                'input size for an empty tensor unless all ' +\n                'specified input sizes are non-zero');\n        }\n        const missing = Math.trunc(denseSize / product);\n        if (product * missing !== denseSize) {\n            throw new Error(`Input to reshape is a SparseTensor with ${denseSize}\n          dense values, but the requested shape requires a multiple of ${product}. inputShape=${inputShape} outputShape= ${outputShape}`);\n        }\n        outputShape[unknownIndex] = missing;\n    }\n    const outputSize = util.sizeFromShape(outputShape);\n    if (outputSize !== denseSize) {\n        throw new Error(`Input to reshape is a tensor with ${denseSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`);\n    }\n    const inputRank = inputShape.length;\n    const inputStrides = [];\n    if (inputRank > 0) {\n        inputStrides[inputRank - 1] = 1;\n        for (let d = inputRank - 2; d >= 0; --d) {\n            inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n        }\n    }\n    const outputStrides = [];\n    if (outputRank > 0) {\n        outputStrides[outputRank - 1] = 1;\n        for (let d = outputRank - 2; d >= 0; --d) {\n            outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n        }\n    }\n    const newIndices = util.getArrayFromDType(inputDType, nnz * outputRank);\n    for (let i = 0; i < nnz; ++i) {\n        let id = 0;\n        for (let j = 0; j < inputRank; ++j) {\n            // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n            id += inputIndices[i * inputRank + j] * inputStrides[j];\n        }\n        for (let j = 0; j < outputRank; ++j) {\n            // newIndices is a 2d tensor with shape of [nnz, outputRank]\n            newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n            id %= outputStrides[j];\n        }\n    }\n    return [newIndices, [nnz, outputRank], outputShape];\n}\n//# sourceMappingURL=SparseReshape_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function stridedSliceImpl(outShape, xBuf, strides, begin) {\n    const outBuf = buffer(outShape, xBuf.dtype);\n    for (let i = 0; i < outBuf.size; i++) {\n        const loc = outBuf.indexToLoc(i);\n        const newLoc = new Array(loc.length);\n        for (let j = 0; j < newLoc.length; j++) {\n            newLoc[j] = loc[j] * strides[j] + begin[j];\n        }\n        outBuf.set(xBuf.get(...newLoc), ...loc);\n    }\n    return outBuf;\n}\n//# sourceMappingURL=StridedSlice_impl.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\n/**\n * An implementation of the tile kernel shared between webgl and cpu for string\n * tensors only.\n */\nexport function tileImpl(xBuf, reps) {\n    const newShape = new Array(xBuf.rank);\n    for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = xBuf.shape[i] * reps[i];\n    }\n    const result = buffer(newShape, xBuf.dtype);\n    for (let i = 0; i < result.values.length; ++i) {\n        const newLoc = result.indexToLoc(i);\n        const originalLoc = new Array(xBuf.rank);\n        for (let j = 0; j < originalLoc.length; j++) {\n            originalLoc[j] = newLoc[j] % xBuf.shape[j];\n        }\n        const originalIndex = xBuf.locToIndex(originalLoc);\n        result.values[i] = xBuf.values[originalIndex];\n    }\n    return result;\n}\n//# sourceMappingURL=Tile_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/** An implementation of the TopK kernel shared between webgl and cpu. */\nimport { buffer, util } from '@tensorflow/tfjs-core';\nexport function topKImpl(x, xShape, xDtype, k, sorted) {\n    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n    const lastDim = xShape[xShape.length - 1];\n    const [batch, size] = [x.length / lastDim, lastDim];\n    const allTopKVals = util.getTypedArrayFromDType(xDtype, batch * k);\n    const allTopKIndices = util.getTypedArrayFromDType('int32', batch * k);\n    for (let b = 0; b < batch; b++) {\n        const offset = b * size;\n        const vals = x.subarray(offset, offset + size);\n        const valAndInd = [];\n        for (let i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort((a, b) => b.value - a.value);\n        const outOffset = b * k;\n        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);\n        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);\n        for (let i = 0; i < k; i++) {\n            topKVals[i] = valAndInd[i].value;\n            topKIndices[i] = valAndInd[i].index;\n        }\n    }\n    // Reshape back to the original input shape, except that the last\n    // dimension is k.\n    const outputShape = xShape.slice();\n    outputShape[outputShape.length - 1] = k;\n    return [\n        buffer(outputShape, xDtype, allTopKVals),\n        buffer(outputShape, 'int32', allTopKIndices)\n    ];\n}\n//# sourceMappingURL=TopK_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function transposeImpl(xVals, xShape, dtype, perm, newShape) {\n    const xRank = xShape.length;\n    const xSize = util.sizeFromShape(xShape);\n    const xStrides = util.computeStrides(xShape);\n    const newStrides = util.computeStrides(newShape);\n    const result = util.getTypedArrayFromDType(dtype, util.sizeFromShape(newShape));\n    for (let i = 0; i < xSize; ++i) {\n        const loc = util.indexToLoc(i, xRank, xStrides);\n        // Permute location.\n        const newLoc = new Array(loc.length);\n        for (let i = 0; i < newLoc.length; i++) {\n            newLoc[i] = loc[perm[i]];\n        }\n        const newIndex = util.locToIndex(newLoc, xRank, newStrides);\n        result[newIndex] = xVals[i];\n    }\n    return result;\n}\n//# sourceMappingURL=Transpose_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TensorBuffer, util } from '@tensorflow/tfjs-core';\nexport function uniqueImpl(values, axis, shape, dtype) {\n    // Normalize and validate axis.\n    const $axis = util.parseAxisParam(axis, shape)[0];\n    // Calculate the new shape that is suitable for extracting data along the\n    // given axis.\n    //\n    // The rank is 3.\n    // The size of the 1st dimension is the size of all the axes < the given axis.\n    // The size of the 2nd dimension is the same as the size of the given axis.\n    // The size of the 3rd dimension is the size of all the axes > the given axis.\n    //\n    // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the\n    // newShape would be: [2*3, 5, 4].\n    //\n    // Note that this is not the final output shape. This will be the shape for an\n    // intermediate TensorBuffer (see inputBuffer below) to allow us to extract\n    // values along the given axis. To demonstrate how it works, consider the\n    // following example:\n    //\n    // Input: a 3D tensor, with shape [1, 2, 3]\n    // [\n    //   [\n    //      [1,2,3],\n    //      [4,5,6]\n    //   ]\n    // ]\n    // Axis: 2 (the last axis).\n    // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].\n    //\n    // For this example, newShape would be: [2, 3, 1], where 2 is calculated from\n    // 1*2. The re-shaped data would look like:\n    //\n    // [\n    //   [\n    //     [1], [2], [3]\n    //   ],\n    //   [\n    //     [4], [5], [6]\n    //   ]\n    // ]\n    //\n    // Then, we can construct a 3-level nested loop by the following dimension\n    // order to extract the values along the axis (dimension1):\n    // i: dimension1       // 0,1,2 (newShape[1])\n    //   m: dimension0     // 0,1   (newShape[0])\n    //     n: dimension2   // 0     (newShape[2])\n    //\n    //                       m, i, n\n    //                      ---------\n    // Iteration 0: data at [0, 0, 0] => \"1\"\n    // Iteration 1: data at [1, 0, 0] => \"4\"\n    // We got [1,4].\n    // Iteration 2: data at [0, 1, 0] => \"2\"\n    // Iteration 3: data at [1, 1, 0] => \"5\"\n    // We got [2,5].\n    // Iteration 4: data at [0, 2, 0] => \"3\"\n    // Iteration 5: data at [1, 2, 0] => \"6\"\n    // We got [3,6].\n    const newShape = [1, shape[0], 1];\n    for (let i = 0; i < $axis; i++) {\n        newShape[0] *= shape[i];\n    }\n    newShape[1] = shape[$axis];\n    for (let i = $axis + 1; i < shape.length; i++) {\n        newShape[2] *= shape[i];\n    }\n    // A map from unique elements (their string representations) to their values\n    // in \"indices\" (below).\n    const uniqueElements = {};\n    // The indices of each unique element in the original tensor along the given\n    // axis. It is 1D and has the same size as the given axis.\n    const indices = new Int32Array(shape[$axis]);\n    // Create a buffer so we can easily extract value at a given location.\n    const inputBuffer = new TensorBuffer(newShape, dtype, values);\n    // The indices along the given axis that have unique elements. This is a\n    // de-duped version of \"indices\" above.\n    const uniqueIndices = [];\n    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;\n    for (let i = 0; i < shape[$axis]; i++) {\n        // Extract values along the axis.\n        let element;\n        if (is1DTensor) {\n            // Fast path for 1D tensor input.\n            element = values[i].toString();\n        }\n        else {\n            const axisValues = [];\n            for (let m = 0; m < newShape[0]; m++) {\n                for (let n = 0; n < newShape[2]; n++) {\n                    axisValues.push(inputBuffer.get(m, i, n));\n                }\n            }\n            element = axisValues.join(',');\n        }\n        // Dedup and update various indices.\n        if (uniqueElements[element] !== undefined) {\n            indices[i] = uniqueElements[element];\n        }\n        else {\n            const uniqueIndex = Object.keys(uniqueElements).length;\n            uniqueElements[element] = uniqueIndex;\n            indices[i] = uniqueIndex;\n            uniqueIndices.push(i);\n        }\n    }\n    // Now we know where each of the unique elements are located along the axis\n    // (uniqueIndices). Extract them from input buffer and store them in the\n    // output buffer.\n    const outputTmpShape = newShape.slice();\n    outputTmpShape[1] = Object.keys(uniqueElements).length;\n    const outputBuffer = new TensorBuffer(outputTmpShape, dtype);\n    uniqueIndices.forEach((uniqueElementIndex, i) => {\n        for (let m = 0; m < newShape[0]; m++) {\n            for (let n = 0; n < newShape[2]; n++) {\n                outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);\n            }\n        }\n    });\n    // The output shape can be calculated from the input shape with the size of\n    // the given axis replaced by the number of unique elements along that axis.\n    const outputShape = shape.slice();\n    outputShape[$axis] = outputTmpShape[1];\n    return {\n        outputValues: outputBuffer.values,\n        outputShape,\n        indices,\n    };\n}\n//# sourceMappingURL=Unique_impl.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(\n      outputShape:\n          number[]) {  // TODO(https://github.com/tensorflow/tfjs/issues/893):\n                       // Only input / output 3D tensors.\n    this.outputShape = outputShape;\n    const rank = outputShape.length;\n\n    if (rank === 0) {\n      this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n    } else {\n      const channels = getChannels('rc', rank);\n      const dtype = getCoordsDataType(rank);\n      const outOfBoundsCondition =\n          getOutOfBoundsCondition(rank, outputShape, channels);\n      const setup = getSetup(\n          rank, outputShape[outputShape.length - 1],\n          outputShape[outputShape.length - 2], channels);\n      const output = getOutput(outputShape, channels);\n\n      this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n    }\n  }\n}\n\nfunction getSourceCoordsArr(rank: number, dims: string[]): string[] {\n  const coords = [];\n\n  for (let row = 0; row <= 1; row++) {\n    for (let col = 0; col <= 1; col++) {\n      let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n\n      for (let d = 2; d < rank; d++) {\n        coord = `${dims[dims.length - 1 - d]},` + coord;\n      }\n\n      coords.push(coord);\n    }\n  }\n  return coords;\n}\n\nfunction getOutOfBoundsCondition(\n    rank: number, shape: number[], dims: string[]): string {\n  if (rank === 1) {\n    return `rc > ${shape[0]}`;\n  }\n\n  let cond = '';\n  for (let i = rank - 2; i < rank; i++) {\n    cond += `${dims[i]} >= ${shape[i]}`;\n    if (i < rank - 1) {\n      cond += '||';\n    }\n  }\n\n  return cond;\n}\n\nfunction getSetup(\n    rank: number, cols: number, rows: number, dims: string[]): string {\n  if (rank === 1) {\n    return '';\n  }\n\n  const innerDims = dims.slice(-2);\n\n  return `\n    int r = ${innerDims[0]};\n    int c = ${innerDims[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${cols};\n    bool rEdge = rp1 >= ${rows};\n  `;\n}\n\nfunction getOutput(shape: number[], dims: string[]): string {\n  const rank = shape.length;\n  const sourceCoords = getSourceCoordsArr(rank, dims);\n  if (rank === 1) {\n    return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  }\n\n  return `getA(${sourceCoords[0]}),\n          cEdge ? 0. : getA(${sourceCoords[1]}),\n          rEdge ? 0. : getA(${sourceCoords[2]}),\n          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nexport class ReshapePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(outputShape: [number, number, number], inputShape: [\n    number, number, number\n  ]) {\n    this.outputShape = outputShape;\n\n    let mainLoop = ``;\n    for (let i = 0; i < 4; i++) {\n      let thisRC = `thisRC = rc;`;\n      if (i % 2 === 1) {\n        thisRC += `thisRC.z += 1;`;\n      }\n      if (i > 1) {\n        thisRC += `thisRC.y += 1;`;\n      }\n\n      mainLoop += `\n        ${thisRC}\n        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i > 0 ? '}' : ''}\n      `;\n    }\n\n    this.userCode = `\n      ${getReshapedInputCoords(inputShape)}\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${outputShape[1]};\n        int cols = ${outputShape[2]};\n\n        ${mainLoop}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nfunction getReshapedInputCoords(shape: [number, number, number]): string {\n  const coordsFromIndexSnippet =\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture} from './gpgpu_util';\nimport {getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureConfig, TextureUsage} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private _numBytesAllocated = 0;\n  private _numBytesFree = 0;  // How many bytes that have been allocated\n                              // are available for reuse.\n  private freeTextures: {[shape: string]: WebGLTexture[]} = {};\n  private logEnabled = false;\n  private usedTextures: {[shape: string]: WebGLTexture[]} = {};\n\n  constructor(private gpgpu: GPGPUContext) {}\n\n  acquireTexture(\n      shapeRC: [number, number], usage: TextureUsage,\n      isPacked: boolean): WebGLTexture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture: WebGLTexture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (\n        physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: WebGLTexture, shape: [number, number],\n      logicalTexType: TextureUsage, isPacked: boolean): void {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType =\n        getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n    if (deleteTexThreshold !== -1 &&\n        this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n    if (texIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${\n        Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated(): number {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree(): number {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n}\n\nfunction numBytesForInternalFormat(\n    gl: WebGLRenderingContext, internalFormat: number): number {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  }\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(\n    shape: [number, number], physicalTexType: PhysicalTextureType,\n    gl: WebGLRenderingContext, textureConfig: TextureConfig,\n    isPacked: boolean): number {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat =\n      internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n\n  let numElements: number;\n  if (isPacked) {\n    const [packedWidth, packedHeight] =\n        getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n\n  } else {\n    const [width, height] =\n        getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(\n    physicalTexType: PhysicalTextureType,\n    textureConfig: TextureConfig): number {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked: boolean):\n    PhysicalTextureType {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(\n    logicalTexType: TextureUsage, isPacked: boolean): PhysicalTextureType {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (\n      logicalTexType === TextureUsage.DOWNLOAD ||\n      logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number], physicalTexType: PhysicalTextureType,\n    isPacked: boolean): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class UnaryOpProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n\nexport const CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;\n\nexport const LINEAR = `return x;`;\n\nexport const ABS = `return abs(x);`;\n\nexport function STEP(alpha = 0.0) {\n  return CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${alpha});\n  `;\n}\n\nexport const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\nexport const RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\n\nexport const RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\n\nexport const CLONE = 'return x;';\n\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport const LINEAR = `return x;`;\n\nexport const ELU = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\n\nexport const RELU = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const RELU6 = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n\nexport class UnaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels, getSourceCoords} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class UnpackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = false;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(outputShape: number[]) {\n    this.outputShape = outputShape;\n    const rank = outputShape.length;\n\n    const channels = getChannels('rc', rank);\n    const dtype = getCoordsDataType(rank);\n    const sourceCoords = getSourceCoords(rank, channels);\n    const innerDims = channels.slice(-2);\n    const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n\n    this.userCode = `\n      void main() {\n        ${dtype} rc = getOutputCoords();\n        vec4 packedInput = getA(${sourceCoords});\n\n        setOutput(getChannel(packedInput, ${coords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import webgl flags.\nimport './flags_webgl';\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {backend_util, BackendValues, buffer, DataId, DataStorage, DataType, DataValues, engine, env, kernel_impls, KernelBackend, MemoryInfo, NumericDataType, Rank, RecursiveArray, scalar, ShapeMap, Tensor, Tensor2D, TensorBuffer, TensorInfo, tidy, TimingInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {DecodeMatrixProgram} from './decode_matrix_gpu';\nimport {DecodeMatrixPackedProgram} from './decode_matrix_packed_gpu';\nimport {EncodeFloatProgram} from './encode_float_gpu';\nimport {EncodeFloatPackedProgram} from './encode_float_packed_gpu';\nimport {EncodeMatrixProgram} from './encode_matrix_gpu';\nimport {EncodeMatrixPackedProgram} from './encode_matrix_packed_gpu';\nimport {GPGPUContext} from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport {GPGPUBinary, GPGPUProgram, TensorData} from './gpgpu_math';\nimport {simpleAbsImplCPU} from './kernel_utils/shared';\nimport {PackProgram} from './pack_gpu';\nimport {ReshapePackedProgram} from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport {TextureData, TextureUsage} from './tex_util';\nimport {TextureManager} from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport {UnaryOpProgram} from './unaryop_gpu';\nimport {UnaryOpPackedProgram} from './unaryop_packed_gpu';\nimport {UnpackProgram} from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\n\nconst whereImpl = kernel_impls.whereImpl;\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\ntype KernelInfo = {\n  name: string; query: Promise<number>;\n};\n\nexport type TimerNode = RecursiveArray<KernelInfo>|KernelInfo;\nexport interface CPUTimerQuery {\n  startMs: number;\n  endMs?: number;\n}\n\nexport interface WebGLMemoryInfo extends MemoryInfo {\n  numBytesInGPU: number;\n  // Tracks the total number of bytes allocated on the GPU, accounting for the\n  // physical texture type.\n  numBytesInGPUAllocated: number;\n  // Tracks byte size of textures that were created and then made available for\n  // reuse (disposed).\n  numBytesInGPUFree: number;\n  unreliable: boolean;\n}\n\nexport interface WebGLTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\nconst binaryCaches: {[webGLVersion: string]: {[key: string]: GPGPUBinary}} = {};\n\nexport function getBinaryCache(webGLVersion: number) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD = 128;\n\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning(): number {\n  if (env().global.screen == null) {\n    return 1024;  // 1 GB.\n  }\n  return (env().global.screen.height * env().global.screen.width *\n          window.devicePixelRatio) *\n      BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n\nexport class MathBackendWebGL extends KernelBackend {\n  texData: DataStorage<TextureData>;\n  gpgpu: GPGPUContext;\n\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return MathBackendWebGL.nextDataId++;\n  }\n  // Maps data ids that have a pending read operation, to list of subscribers.\n  private pendingRead = new WeakMap<DataId, Array<(arr: TypedArray) => void>>();\n  // List of data ids that are scheduled for disposal, but are waiting on a\n  // pending read operation.\n  private pendingDisposal = new WeakSet<DataId>();\n\n  // Used to count the number of 'shallow' sliced tensors that point to the\n  // same data id.\n  dataRefCount = new WeakMap<DataId, number>();\n  private numBytesInGPU = 0;\n\n  private canvas: HTMLCanvasElement|OffscreenCanvas;\n\n  private programTimersStack: TimerNode[];\n  private activeTimers: TimerNode[];\n  // Accumulated time spent (including blocking) in uploading data to webgl.\n  private uploadWaitMs = 0;\n  // Accumulated time spent (including blocking in downloading data from webgl.\n  private downloadWaitMs = 0;\n\n  // record the last manual GL Flush time.\n  private lastGlFlushTime = 0;\n\n  // Number of bits of precision of this backend.\n  private floatPrecisionValue: 32|16;\n\n  private textureManager: TextureManager;\n  private binaryCache: {[key: string]: GPGPUBinary};\n  private gpgpuCreatedLocally: boolean;\n  private numMBBeforeWarning: number;\n  private warnedAboutMemory = false;\n\n  constructor(gpgpu?: GPGPUContext) {\n    super();\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    if (gpgpu == null) {\n      const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      this.gpgpu = new GPGPUContext(gl);\n      this.canvas = gl.canvas;\n      this.gpgpuCreatedLocally = true;\n    } else {\n      this.gpgpu = gpgpu;\n      this.binaryCache = {};\n      this.gpgpuCreatedLocally = false;\n      this.canvas = gpgpu.gl.canvas;\n    }\n    this.textureManager = new TextureManager(this.gpgpu);\n    this.numMBBeforeWarning = numMBBeforeWarning();\n\n    this.texData = new DataStorage(this, engine());\n  }\n\n  numDataIds() {\n    return this.texData.numDataIds() - this.pendingDeletes;\n  }\n\n  write(values: BackendValues, shape: number[], dtype: DataType): DataId {\n    if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n        env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {id: this.nextDataId()};\n    this.texData.set(\n        dataId,\n        {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1});\n    return dataId;\n  }\n\n  /** Return refCount of a `TensorData`. */\n  refCount(dataId: DataId): number {\n    if (this.texData.has(dataId)) {\n      const tensorData = this.texData.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TextureData`. */\n  incRef(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    texData.refCount++;\n  }\n\n  /** Decrease refCount of a `TextureData`. */\n  decRef(dataId: DataId): void {\n    if (this.texData.has(dataId)) {\n      const texData = this.texData.get(dataId);\n      texData.refCount--;\n    }\n  }\n\n  move(\n      dataId: DataId, values: BackendValues, shape: number[], dtype: DataType,\n      refCount: number): void {\n    if (env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    this.texData.set(\n        dataId, {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount});\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  readSync(dataId: DataId): BackendValues {\n    const texData = this.texData.get(dataId);\n    const {values, dtype, complexTensorInfos, slice, shape, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.readSync(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n    if (dtype === 'string') {\n      return values;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let result: Float32Array;\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    } else {\n      result = this.getValuesFromTexture(dataId);\n    }\n\n    if (shouldTimeProgram) {\n      this.downloadWaitMs += util.now() - start;\n    }\n    return this.convertAndCacheOnCPU(dataId, result);\n  }\n\n  async read(dataId: DataId): Promise<BackendValues> {\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<TypedArray>(resolve => subscribers.push(resolve));\n    }\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, complexTensorInfos, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.read(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n\n    if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n        env().getNumber('WEBGL_VERSION') === 2) {\n      throw new Error(\n          `tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n          `WEBGL_VERSION=2 not yet supported.`);\n    }\n\n    let buffer = null;\n    let tmpDownloadTarget: TensorInfo;\n\n    if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n      // Possibly copy the texture into a buffer before inserting a fence.\n      tmpDownloadTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n\n      buffer = this.gpgpu.createBufferFromTexture(\n          tmpData.texture, ...tex_util.getDenseTexShape(shape));\n    }\n\n    this.pendingRead.set(dataId, []);\n\n    if (dtype !== 'complex64') {\n      // Create a fence and wait for it to resolve.\n      await this.gpgpu.createAndWaitForFence();\n    }\n\n    // Download the values from the GPU.\n    let vals: Float32Array;\n    if (dtype === 'complex64') {\n      const ps = await Promise.all([\n        this.read(complexTensorInfos.real.dataId),\n        this.read(complexTensorInfos.imag.dataId)\n      ]);\n\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else if (buffer == null) {\n      vals = this.getValuesFromTexture(dataId);\n    } else {\n      const size = util.sizeFromShape(shape);\n      vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n    }\n    if (tmpDownloadTarget != null) {\n      this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n    }\n    const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n\n    const subscribers = this.pendingRead.get(dataId);\n    this.pendingRead.delete(dataId);\n\n    // Notify all pending reads.\n    subscribers.forEach(resolve => resolve(dTypeVals));\n    if (this.pendingDisposal.has(dataId)) {\n      this.pendingDisposal.delete(dataId);\n      if (this.disposeData(dataId)) {\n        engine().removeDataId(dataId, this);\n      }\n      this.pendingDeletes--;\n    }\n    return dTypeVals;\n  }\n\n  bufferSync<R extends Rank>(t: TensorInfo): TensorBuffer<R> {\n    const data = this.readSync(t.dataId);\n    let decodedData = data as DataValues;\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        decodedData = (data as Uint8Array[]).map(d => util.decodeString(d));\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, decodedData) as\n        TensorBuffer<R>;\n  }\n\n  private checkNumericalProblems(values: BackendValues): void {\n    if (values == null) {\n      return;\n    }\n    for (let i = 0; i < values.length; i++) {\n      const num = values[i] as number;\n      if (!webgl_util.canBeRepresented(num)) {\n        if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n          throw Error(\n              `The value ${num} cannot be represented with your ` +\n              `current settings. Consider enabling float32 rendering: ` +\n              `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n        }\n        throw Error(`The value ${num} cannot be represented on this device.`);\n      }\n    }\n  }\n\n  private getValuesFromTexture(dataId: DataId): Float32Array {\n    const {shape, dtype, isPacked} = this.texData.get(dataId);\n    const size = util.sizeFromShape(shape);\n    if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n      const tmpTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpTarget.dataId);\n      const vals = this.gpgpu\n                       .downloadMatrixFromPackedTexture(\n                           tmpData.texture, ...tex_util.getDenseTexShape(shape))\n                       .subarray(0, size);\n\n      this.disposeIntermediateTensorInfo(tmpTarget);\n\n      return vals;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK') && isPacked === true;\n    const outputShape =\n        shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n    const program = shouldUsePackedProgram ?\n        new EncodeFloatPackedProgram(outputShape as [number, number, number]) :\n        new EncodeFloatProgram(outputShape);\n    const output = this.runWebGLProgram(\n        program, [{shape: outputShape, dtype, dataId}], 'float32');\n    const tmpData = this.texData.get(output.dataId);\n    const vals =\n        this.gpgpu\n            .downloadByteEncodedFloatMatrixFromOutputTexture(\n                tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])\n            .subarray(0, size);\n    this.disposeIntermediateTensorInfo(output);\n\n    return vals;\n  }\n\n  timerAvailable(): boolean {\n    return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n  }\n\n  async time(f: () => void): Promise<WebGLTimingInfo> {\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    // needing to split these up because util.flatten only accepts certain types\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n\n    const res: WebGLTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null  // will be filled by the engine\n    };\n\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n\n      res['kernelMs'] = util.sum(kernelMs);\n      res['getExtraProfileInfo'] = () =>\n          kernelMs.map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n              .map(d => `${d.name}: ${d.ms}`)\n              .join(', ');\n    } else {\n      res['kernelMs'] = {\n        error: 'WebGL query timers are not supported in this environment.'\n      };\n    }\n\n    this.uploadWaitMs = 0;\n    this.downloadWaitMs = 0;\n    return res;\n  }\n  memory(): WebGLMemoryInfo {\n    return {\n      unreliable: false,\n      numBytesInGPU: this.numBytesInGPU,\n      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n      numBytesInGPUFree: this.textureManager.numBytesFree\n    } as WebGLMemoryInfo;\n  }\n\n  private startTimer(): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.beginQuery();\n    }\n    return {startMs: util.now(), endMs: null};\n  }\n\n  private endTimer(query: WebGLQuery|CPUTimerQuery): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      this.gpgpu.endQuery();\n      return query;\n    }\n    (query as CPUTimerQuery).endMs = util.now();\n    return query;\n  }\n\n  private async getQueryTime(query: WebGLQuery|CPUTimerQuery): Promise<number> {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.waitForQueryAndGetTime(query as WebGLQuery);\n    }\n    const timerQuery = query as CPUTimerQuery;\n    return timerQuery.endMs - timerQuery.startMs;\n  }\n\n  private pendingDeletes = 0;\n\n  /**\n   * Decrease the RefCount on the dataId and dispose the memory if the dataId\n   * has 0 refCount. If there are pending read on the data, the disposal would\n   * added to the pending delete queue. Return true if the dataId is removed\n   * from backend or the backend does not contain the dataId, false if the\n   * dataId is not removed. Memory may or may not be released even when dataId\n   * is removed, which also depends on dataRefCount, see `releaseGPU`.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  disposeData(dataId: DataId, force = false): boolean {\n    if (this.pendingDisposal.has(dataId)) {\n      return false;\n    }\n\n    // No-op if already disposed.\n    if (!this.texData.has(dataId)) {\n      return true;\n    }\n\n    // if force flag is set, change refCount to 0, this would ensure disposal\n    // when added to the pendingDisposal queue. Memory may or may not be\n    // released, which also depends on dataRefCount, see `releaseGPU`.\n    if (force) {\n      this.texData.get(dataId).refCount = 0;\n    } else {\n      this.texData.get(dataId).refCount--;\n    }\n\n    if (!force && this.texData.get(dataId).refCount > 0) {\n      return false;\n    }\n\n    if (this.pendingRead.has(dataId)) {\n      this.pendingDisposal.add(dataId);\n      this.pendingDeletes++;\n      return false;\n    }\n\n    this.releaseGPUData(dataId);\n    const {complexTensorInfos} = this.texData.get(dataId);\n    if (complexTensorInfos != null) {\n      this.disposeData(complexTensorInfos.real.dataId, force);\n      this.disposeData(complexTensorInfos.imag.dataId, force);\n    }\n\n    this.texData.delete(dataId);\n\n    return true;\n  }\n\n  private releaseGPUData(dataId: DataId): void {\n    const {texture, dtype, texShape, usage, isPacked, slice} =\n        this.texData.get(dataId);\n    const key = slice && slice.origDataId || dataId;\n    const refCount = this.dataRefCount.get(key);\n\n    if (refCount > 1) {\n      this.dataRefCount.set(key, refCount - 1);\n    } else {\n      this.dataRefCount.delete(key);\n      if (texture != null) {\n        this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n        this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n      }\n    }\n\n    const texData = this.texData.get(dataId);\n    texData.texture = null;\n    texData.texShape = null;\n    texData.isPacked = false;\n    texData.slice = null;\n  }\n\n  getTexture(dataId: DataId): WebGLTexture {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId).texture;\n  }\n\n  /**\n   * Returns internal information for the specific data bucket. Used in unit\n   * tests.\n   */\n  getDataInfo(dataId: DataId): TextureData {\n    return this.texData.get(dataId);\n  }\n\n  /*\n  Tests whether all the inputs to an op are small and on the CPU. This heuristic\n  determines when it would be faster to execute a kernel on the CPU. WebGL\n  kernels opt into running this check and forwarding when appropriate.\n  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n  sustainable strategy for optimizing backend execution of ops.\n   */\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    return env().getBool('WEBGL_CPU_FORWARD') &&\n        inputs.every(\n            input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  getGPGPUContext(): GPGPUContext {\n    return this.gpgpu;\n  }\n\n  where(condition: Tensor): Tensor2D {\n    backend_util.warn(\n        'tf.where() in webgl locks the UI thread. ' +\n        'Call tf.whereAsync() instead');\n    const condVals = condition.dataSync();\n    return whereImpl(condition.shape, condVals);\n  }\n\n  private packedUnaryOp(x: TensorInfo, op: string, dtype: DataType) {\n    const program = new UnaryOpPackedProgram(x.shape, op);\n    const outInfo = this.compileAndRun(program, [x], dtype);\n    return engine().makeTensorFromDataId(\n        outInfo.dataId, outInfo.shape, outInfo.dtype);\n  }\n\n  // TODO(msoulanille) remove this once the backend has been modularized\n  // a copy is needed here to break a circular dependency.\n  // Also remove the op from unary_op.\n  abs<T extends Tensor>(x: T): T {\n    // TODO: handle cases when x is complex.\n    if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n      const outValues =\n          simpleAbsImplCPU(this.texData.get(x.dataId).values as TypedArray);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.ABS, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n    const outInfo = this.compileAndRun(program, [x]);\n    return engine().makeTensorFromDataId(\n               outInfo.dataId, outInfo.shape, outInfo.dtype) as T;\n  }\n\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: BackendValues|string[]): TensorInfo {\n    let dataId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as {} as string[]).map(d => util.encodeString(d));\n\n      dataId = this.write(encodedValues, shape, dtype);\n    } else {\n      dataId = this.write(values as TypedArray, shape, dtype);\n    }\n\n    this.texData.get(dataId).usage = null;\n    return {dataId, shape, dtype};\n  }\n\n  private makeOutput<T extends Tensor>(\n      shape: number[], dtype: DataType, values?: BackendValues): T {\n    const {dataId} = this.makeTensorInfo(shape, dtype, values);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, this) as T;\n  }\n\n  private unpackTensor(input: TensorInfo): TensorInfo {\n    const program = new UnpackProgram(input.shape);\n    return this.runWebGLProgram(program, [input], input.dtype);\n  }\n\n  private packTensor(input: TensorInfo): TensorInfo {\n    const program = new PackProgram(input.shape);\n    const preventEagerUnpackingOutput = true;\n    return this.runWebGLProgram(\n        program, [input], input.dtype, null /* customSetup */,\n        preventEagerUnpackingOutput);\n  }\n\n  private packedReshape(input: TensorInfo, afterShape: number[]): TensorInfo {\n    const input3DShape = [\n      webgl_util.getBatchDim(input.shape),\n      ...webgl_util.getRowsCols(input.shape)\n    ] as [number, number, number];\n    const input3D: TensorInfo = {\n      dtype: input.dtype,\n      shape: input3DShape,\n      dataId: input.dataId\n    };\n    const afterShapeAs3D = [\n      webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n    ] as [number, number, number];\n\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const output = this.runWebGLProgram(\n        program, [input3D], input.dtype, null /* customSetup */,\n        preventEagerUnpackingOfOutput);\n    return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n  }\n\n  private decode(dataId: DataId): TensorInfo {\n    const texData = this.texData.get(dataId);\n    const {isPacked, shape, dtype} = texData;\n    const shapeAs3D =\n        webgl_util.getShapeAs3D(shape) as [number, number, number];\n    let program;\n    if (isPacked) {\n      program = new DecodeMatrixPackedProgram(shapeAs3D);\n    } else {\n      program = new DecodeMatrixProgram(shapeAs3D);\n    }\n    const preventEagerUnpackingOfOutput = true;\n    const out = this.runWebGLProgram(\n        program, [{shape: shapeAs3D, dtype, dataId}], dtype,\n        null /* customSetup */, preventEagerUnpackingOfOutput);\n    return {dtype, shape, dataId: out.dataId};\n  }\n\n  runWebGLProgram(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype: DataType,\n      customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => void,\n      preventEagerUnpackingOfOutput = false): TensorInfo {\n    const output = this.makeTensorInfo(program.outputShape, outputDtype);\n    const outData = this.texData.get(output.dataId);\n    if (program.packedOutput) {\n      outData.isPacked = true;\n    }\n    if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n      const texelShape = tex_util.getDenseTexShape(program.outputShape);\n      // For a densely packed output, we explicitly set texShape\n      // so it doesn't get assigned later according to our typical packing\n      // scheme wherein a single texel can only contain values from adjacent\n      // rows/cols.\n      outData.texShape = texelShape.map(d => d * 2) as [number, number];\n    }\n    if (program.outTexUsage != null) {\n      outData.usage = program.outTexUsage;\n    }\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      outData.values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n\n    const dataToDispose: TensorInfo[] = [];\n    const inputsData: TensorData[] = inputs.map(input => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n\n      let texData = this.texData.get(input.dataId);\n\n      if (texData.texture == null) {\n        if (!program.packedInputs &&\n            util.sizeFromShape(input.shape) <=\n                env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n          // Upload small tensors that live on the CPU as uniforms, not as\n          // textures. Do this only when the environment supports 32bit floats\n          // due to problems when comparing 16bit floats with 32bit floats.\n          // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n          // possible for packed shaders to sample from uniforms.\n          return {\n            shape: input.shape,\n            texData: null,\n            isUniform: true,\n            uniformValues: texData.values as TypedArray\n          };\n        }\n\n        // This ensures that if a packed program's inputs have not yet been\n        // uploaded to the GPU, they get uploaded as packed right off the bat.\n        if (program.packedInputs) {\n          texData.isPacked = true;\n          texData.shape = input.shape;\n        }\n      } else if (!!texData.isPacked !== !!program.packedInputs) {\n        input = texData.isPacked ? this.unpackTensor(input) :\n                                   this.packTensor(input);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n      } else if (\n          texData.isPacked &&\n          !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n        // This is a special case where a texture exists for a tensor\n        // but the shapes are incompatible (due to packing constraints) because\n        // the tensor did not have a chance to go through the packed reshape\n        // shader. This only happens when we reshape the *same* tensor to form\n        // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n        // case will disappear once packed uploading is the default.\n\n        const savedInput = input;\n        const targetShape = input.shape;\n\n        input.shape = texData.shape;\n        input = this.packedReshape(input as Tensor, targetShape);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n\n        savedInput.shape = targetShape;\n      }\n\n      this.uploadToGPU(input.dataId);\n      return {shape: input.shape, texData, isUniform: false};\n    });\n\n    this.uploadToGPU(output.dataId);\n    const outputData:\n        TensorData = {shape: output.shape, texData: outData, isUniform: false};\n    const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n    const binary = this.getAndSaveBinary(key, () => {\n      return gpgpu_math.compileProgram(\n          this.gpgpu, program, inputsData, outputData);\n    });\n    const shouldTimeProgram = this.activeTimers != null;\n    let query: WebGLQuery|CPUTimerQuery;\n    if (shouldTimeProgram) {\n      query = this.startTimer();\n    }\n\n    gpgpu_math.runProgram(\n        this.gpgpu, binary, inputsData, outputData, customSetup);\n\n    dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));\n\n    if (shouldTimeProgram) {\n      query = this.endTimer(query);\n      this.activeTimers.push(\n          {name: program.constructor.name, query: this.getQueryTime(query)});\n    }\n\n    const glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');\n    // Manually GL flush requested\n    if (glFlushThreshold > 0) {\n      const time = util.now();\n      if ((time - this.lastGlFlushTime) > glFlushThreshold) {\n        this.gpgpu.gl.flush();\n        this.lastGlFlushTime = time;\n      }\n    }\n\n    if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n        preventEagerUnpackingOfOutput === false) {\n      const unpacked = this.unpackTensor(output);\n      this.disposeIntermediateTensorInfo(output);\n      return unpacked;\n    }\n    return output;\n  }\n\n  compileAndRun(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype?: DataType,\n      customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => void,\n      preventEagerUnpackingOfOutput = false): TensorInfo {\n    outputDtype = outputDtype || inputs[0].dtype;\n    const outInfo = this.runWebGLProgram(\n        program, inputs, outputDtype, customSetup,\n        preventEagerUnpackingOfOutput);\n    return outInfo;\n  }\n\n  private getAndSaveBinary(key: string, getBinary: () => GPGPUBinary):\n      GPGPUBinary {\n    if (!(key in this.binaryCache)) {\n      this.binaryCache[key] = getBinary();\n    }\n    return this.binaryCache[key];\n  }\n\n  getTextureManager(): TextureManager {\n    return this.textureManager;\n  }\n\n  private disposed = false;\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n    // Avoid disposing the compiled webgl programs during unit testing because\n    // it slows down test execution.\n    if (!env().getBool('IS_TEST')) {\n      const allKeys = Object.keys(this.binaryCache);\n      allKeys.forEach(key => {\n        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n        delete this.binaryCache[key];\n      });\n    }\n    this.textureManager.dispose();\n    if (this.canvas != null &&\n        (typeof (HTMLCanvasElement) !== 'undefined' &&\n         this.canvas instanceof HTMLCanvasElement)) {\n      this.canvas.remove();\n    } else {\n      this.canvas = null;\n    }\n    if (this.gpgpuCreatedLocally) {\n      this.gpgpu.program = null;\n      this.gpgpu.dispose();\n    }\n    this.disposed = true;\n  }\n\n  floatPrecision(): 16|32 {\n    if (this.floatPrecisionValue == null) {\n      this.floatPrecisionValue = tidy(() => {\n        if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n          // Momentarily switching DEBUG flag to false so we don't throw an\n          // error trying to upload a small value.\n          const debugFlag = env().getBool('DEBUG');\n          env().set('DEBUG', false);\n          const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n          env().set('DEBUG', debugFlag);\n\n          if (underflowCheckValue > 0) {\n            return 32;\n          }\n        }\n        return 16;\n      });\n    }\n    return this.floatPrecisionValue;\n  }\n\n  /** Returns the smallest representable number.  */\n  epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n\n  uploadToGPU(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    const {shape, dtype, values, texture, usage, isPacked} = texData;\n\n    if (texture != null) {\n      // Array is already on GPU. No-op.\n      return;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let texShape = texData.texShape;\n    if (texShape == null) {\n      texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n      texData.texShape = texShape;\n    }\n\n    if (values != null) {\n      const shapeAs3D = webgl_util.getShapeAs3D(shape);\n\n      let program;\n      let width = texShape[1], height = texShape[0];\n      const isByteArray = values instanceof Uint8Array;\n\n      if (isPacked) {\n        [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(\n            texShape[0], texShape[1]);\n        program = new EncodeMatrixPackedProgram(\n            shapeAs3D, [height, width], isByteArray);\n      } else {\n        program =\n            new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);\n      }\n\n      const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n      if (isByteArray) {\n        this.texData.get(tempDenseInputHandle.dataId).usage =\n            TextureUsage.PIXELS;\n      } else {\n        this.texData.get(tempDenseInputHandle.dataId).usage =\n            TextureUsage.UPLOAD;\n      }\n      this.gpgpu.uploadDenseMatrixToTexture(\n          this.getTexture(tempDenseInputHandle.dataId), width, height,\n          values as TypedArray);\n\n      // We want the output to remain packed regardless of the value of\n      // WEBGL_PACK.\n      const preventEagerUnpacking = true;\n      const encodedOutputTarget = this.runWebGLProgram(\n          program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);\n\n      // Have the original texture assume the identity of the encoded output.\n      const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n      texData.texture = outputTexData.texture;\n      texData.texShape = outputTexData.texShape;\n      texData.isPacked = outputTexData.isPacked;\n      texData.usage = outputTexData.usage;\n\n      this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n      this.texData.delete(encodedOutputTarget.dataId);\n\n      // Once uploaded, don't store the values on cpu.\n      texData.values = null;\n      if (shouldTimeProgram) {\n        this.uploadWaitMs += util.now() - start;\n      }\n    } else {\n      const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n      texData.texture = newTexture;\n    }\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, float32Values?: Float32Array):\n      TypedArray {\n    const texData = this.texData.get(dataId);\n    const {dtype} = texData;\n\n    this.releaseGPUData(dataId);\n\n    if (float32Values != null) {\n      texData.values = float32ToTypedArray(float32Values, dtype as 'float32');\n    }\n    return texData.values as TypedArray;\n  }\n\n  private acquireTexture(\n      texShape: [number, number], texType: TextureUsage, dtype: DataType,\n      isPacked: boolean): WebGLTexture {\n    this.numBytesInGPU += this.computeBytes(texShape, dtype);\n    if (!this.warnedAboutMemory &&\n        this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n      const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n      this.warnedAboutMemory = true;\n      console.warn(\n          `High memory usage in GPU: ${mb} MB, ` +\n          `most likely due to a memory leak`);\n    }\n    return this.textureManager.acquireTexture(texShape, texType, isPacked);\n  }\n\n  private computeBytes(shape: [number, number], dtype: DataType) {\n    return shape[0] * shape[1] * util.bytesPerElement(dtype);\n  }\n}\n\nfunction float32ToTypedArray<D extends NumericDataType>(\n    a: Float32Array, dtype: D): tf.DataTypeMap[D] {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a as tf.DataTypeMap[D];\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    const result = (dtype === 'int32') ? new Int32Array(a.length) :\n                                         new Uint8Array(a.length);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result as tf.DataTypeMap[D];\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport * as gpgpu_util from './gpgpu_util';\nimport * as webgl_util from './webgl_util';\n\nexport {MathBackendWebGL, WebGLMemoryInfo, WebGLTimingInfo} from './backend_webgl';\nexport {setWebGLContext} from './canvas_util';\nexport {GPGPUContext} from './gpgpu_context';\nexport {GPGPUProgram} from './gpgpu_math';\n// WebGL specific utils.\nexport {gpgpu_util, webgl_util};\n\n/**\n * Enforce use of half precision textures if available on the platform.\n *\n * @doc {heading: 'Environment', namespace: 'webgl'}\n */\nexport function forceHalfFloat(): void {\n  env().set('WEBGL_FORCE_F16_TEXTURES', true);\n}\n","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// base.ts is the webgl backend without auto kernel registration.\n\nimport {device_util, registerBackend} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from './backend_webgl';\nexport {version as version_webgl} from './version';\n\nif (device_util.isBrowser()) {\n  registerBackend('webgl', () => new MathBackendWebGL(), 2 /* priority */);\n}\n\n// Export webgl utilities\nexport * from './webgl';\n\n// Export forceHalfFlost under webgl namespace for the union bundle.\nimport {forceHalfFloat} from './webgl';\nexport const webgl = {forceHalfFloat};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport const CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\n\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport class BinaryOpProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport const CHECK_NAN_SNIPPET = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\n\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\n\nexport class BinaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n  supportsBroadcasting = true;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      op: string, aShape: number[], bShape: number[],\n      checkOutOfBounds = false) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const rank = this.outputShape.length;\n    let checkOutOfBoundsString = '';\n    if (checkOutOfBounds) {\n      if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n        checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n      } else {\n        const dtype = getCoordsDataType(rank);\n        checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n        if (rank === 1) {\n          checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n        } else {\n          const channels = getChannels('coords', rank);\n          checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n        }\n      }\n    }\n\n    this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Identity, IdentityInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function identity(\n    args: {inputs: IdentityInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  backend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};\n}\n\nexport const identityConfig: KernelConfig = {\n  kernelName: Identity,\n  backendName: 'webgl',\n  kernelFunc: identity as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Complex, ComplexInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\n/**\n * In WebGL data is stored in GPU textures which can't be efficiently copied, so\n * complex tensors share data with their real and imaginary components. Complex\n * tensors' reference to the components is tracked by refCount on the individual\n * component. The refCounts are increased by the identity call.\n *\n * When a complex tensor is disposed, it will reduce the refCount on the\n * components by calling disposeData on each.\n */\nexport function complex(\n    args: {inputs: ComplexInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {real, imag} = inputs;\n\n  const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n  const complex = backend.texData.get(complexInfo.dataId);\n\n  const realTensorInfo = identity({inputs: {x: real}, backend});\n\n  const imagTensorInfo = identity({inputs: {x: imag}, backend});\n\n  complex.complexTensorInfos = {real: realTensorInfo, imag: imagTensorInfo};\n\n  return complexInfo;\n}\n\nexport const complexConfig: KernelConfig = {\n  kernelName: Complex,\n  backendName: 'webgl',\n  kernelFunc: complex as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, LeakyRelu, LeakyReluAttrs, LeakyReluInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nexport const LEAKYRELU = `return (a < 0.) ? b * a : a;`;\nexport const LEAKYRELU_PACKED = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\n\nexport function leakyRelu(args: {\n  inputs: LeakyReluInputs,\n  backend: MathBackendWebGL,\n  attrs: LeakyReluAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {alpha} = attrs;\n\n  const $alpha = backend.makeTensorInfo(\n      [], 'float32',\n      util.createScalarValue(alpha as {} as 'float32', 'float32'));\n\n  const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n      new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) :\n      new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);\n  const result = backend.runWebGLProgram(program, [x, $alpha], x.dtype);\n\n  backend.disposeIntermediateTensorInfo($alpha);\n\n  return result;\n}\n\nexport const leakyReluConfig: KernelConfig = {\n  kernelName: LeakyRelu,\n  backendName: 'webgl',\n  kernelFunc: leakyRelu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Prelu, PreluInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\nexport const PRELU_PACKED = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\n\nexport function prelu(args: {inputs: PreluInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x, alpha} = inputs;\n\n  const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n      new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) :\n      new BinaryOpProgram(PRELU, x.shape, alpha.shape);\n  return backend.runWebGLProgram(program, [x, alpha], x.dtype);\n}\n\nexport const preluConfig: KernelConfig = {\n  kernelName: Prelu,\n  backendName: 'webgl',\n  kernelFunc: prelu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, DataType, env, KernelFunc, TypedArray, UnaryInputs, upcastType} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {complex} from '../kernels/Complex';\nimport {LEAKYRELU, LEAKYRELU_PACKED} from '../kernels/LeakyRelu';\nimport {PRELU, PRELU_PACKED} from '../kernels/Prelu';\nimport * as unary_op from '../unaryop_gpu';\nimport {UnaryOpProgram} from '../unaryop_gpu';\nimport * as unary_packed_op from '../unaryop_packed_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nimport {SimpleBinaryKernelImplCPU, SimpleUnaryKernelImplCPU} from './shared';\n\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\n\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\n\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n\ntype UnaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  cpuKernelImpl?: SimpleUnaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function unaryKernelFunc(\n    {opSnippet, packedOpSnippet, cpuKernelImpl, dtype}: UnaryKernelFuncConfig):\n    KernelFunc {\n  return ({inputs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const $dtype = dtype || x.dtype;\n    if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n      const xData = webglBackend.texData.get(x.dataId);\n      const outValues = cpuKernelImpl(xData.values as TypedArray, $dtype);\n      return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n    } else {\n      program = new UnaryOpProgram(x.shape, opSnippet);\n    }\n\n    return webglBackend.runWebGLProgram(program, [x], $dtype);\n  };\n}\n\ntype BinaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  checkOutOfBounds?: boolean,\n  supportsComplex?: boolean,\n  cpuKernelImpl?: SimpleBinaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc({\n  opSnippet,\n  packedOpSnippet,\n  checkOutOfBounds = false,\n  supportsComplex = false,\n  cpuKernelImpl,\n  dtype\n}: BinaryKernelFuncConfig): KernelFunc {\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n\n      const [real, imag] = [\n        [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n        [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n      ].map(complexParts => {\n        const [aPart, bPart] = complexParts;\n\n        const aHandle = {\n          dataId: aPart.dataId,\n          dtype: aPart.dtype,\n          shape: a.shape\n        };\n        const bHandle = {\n          dataId: bPart.dataId,\n          dtype: bPart.dtype,\n          shape: b.shape\n        };\n\n        const program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        return webglBackend.runWebGLProgram(\n            program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n      });\n\n      const complexOutput =\n          complex({inputs: {real, imag}, backend: webglBackend});\n\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag);\n\n      // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    const $dtype = dtype || upcastType(a.dtype, b.dtype);\n    if (webglBackend.shouldExecuteOnCPU([a, b]) && cpuKernelImpl != null) {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n      const [outValues, outShape] = cpuKernelImpl(\n          a.shape, b.shape, aData.values as TypedArray,\n          bData.values as TypedArray, $dtype);\n\n      const out = webglBackend.makeTensorInfo(outShape, $dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&\n        packedOpSnippet != null;\n    let program: BinaryOpProgram|BinaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(\n          packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}\n\nexport function mapActivationToShaderProgram(\n    activation: backend_util.Activation, packed = false): string {\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return PRELU_PACKED;\n    }\n    return PRELU;\n  } else if (activation === 'leakyrelu') {\n    if (packed) {\n      return LEAKYRELU_PACKED;\n    }\n    return LEAKYRELU;\n  } else if (activation === 'sigmoid') {\n    if (packed) {\n      return unary_packed_op.SIGMOID;\n    }\n    return unary_op.SIGMOID;\n  }\n  throw new Error(`Activation ${\n      activation} has not been implemented for the WebGL backend.`);\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MatMulPackedProgram implements GPGPUProgram {\n  variableNames = ['matrixA', 'matrixB'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      aShape: [number, number, number], bShape: [number, number, number],\n      outputShape: [number, number, number], transposeA = false,\n      transposeB = false, addBias = false, activation: string = null,\n      hasPreluActivation = false, hasLeakyreluActivation = false) {\n    this.outputShape = outputShape;\n\n    const sharedDim = transposeA ? aShape[1] : aShape[2];\n    const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n\n    const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n    const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n    const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n    const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (hasLeakyreluActivation) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    let batchASnippet = 'rc.x';\n    let batchBSnippet = 'rc.x';\n    if (aShape[0] < bShape[0]) {\n      batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n    } else if (bShape[0] < aShape[0]) {\n      batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nexport const COMPLEX_MULTIPLY = {\n  REAL: 'return areal * breal - aimag * bimag;',\n  IMAG: 'return areal * bimag + aimag * breal;'\n};\n\nexport class BinaryOpComplexProgram implements GPGPUProgram {\n  variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n\n    this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${op}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, env, KernelConfig, Multiply, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport * as binaryop_complex_gpu from '../binaryop_complex_gpu';\nimport {BinaryOpComplexProgram} from '../binaryop_complex_gpu';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {multiplyImplCPU as cpuMultiply} from '../kernel_utils/shared';\n\nimport {complex} from './Complex';\n\nconst MUL = 'return a * b;';\n\nexport function multiply(\n    args: {inputs: BinaryInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {a, b} = inputs;\n  const dtype = backend_util.upcastType(a.dtype, b.dtype);\n\n  if (a.dtype === 'complex64') {\n    const aData = backend.texData.get(a.dataId);\n    const bData = backend.texData.get(b.dataId);\n\n    const realProgram = new BinaryOpComplexProgram(\n        binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n    const imagProgram = new BinaryOpComplexProgram(\n        binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n\n    const inputs = [\n      {\n        dataId: aData.complexTensorInfos.real.dataId,\n        dtype: aData.complexTensorInfos.real.dtype,\n        shape: a.shape\n      },\n      {\n        dataId: aData.complexTensorInfos.imag.dataId,\n        dtype: aData.complexTensorInfos.imag.dtype,\n        shape: a.shape\n      },\n      {\n        dataId: bData.complexTensorInfos.real.dataId,\n        dtype: bData.complexTensorInfos.real.dtype,\n        shape: b.shape\n      },\n      {\n        dataId: bData.complexTensorInfos.imag.dataId,\n        dtype: bData.complexTensorInfos.imag.dtype,\n        shape: b.shape\n      }\n    ];\n\n    const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n    const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n\n    const complexOutput =\n        complex({inputs: {real: realPart, imag: imagPart}, backend});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(imagPart);\n\n    // TODO(annxingyuan): CPU forwarding for complex inputs.\n    return complexOutput;\n  }\n\n  if (backend.shouldExecuteOnCPU([a, b])) {\n    const aData = backend.texData.get(a.dataId);\n    const bData = backend.texData.get(b.dataId);\n    const [outValues, outShape] = cpuMultiply(\n        a.shape, b.shape, aData.values as TypedArray,\n        bData.values as TypedArray, dtype);\n\n    const out = backend.makeTensorInfo(outShape, dtype);\n    const outData = backend.texData.get(out.dataId);\n    outData.values = outValues;\n    return out;\n  }\n\n  let program: BinaryOpProgram|BinaryOpPackedProgram;\n  if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n    program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);\n  } else {\n    program = new BinaryOpProgram(MUL, a.shape, b.shape);\n  }\n\n  return backend.runWebGLProgram(program, [a, b], dtype);\n}\n\nexport const multiplyConfig: KernelConfig = {\n  kernelName: Multiply,\n  backendName: 'webgl',\n  kernelFunc: multiply\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Reshape, ReshapeAttrs, ReshapeInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {packedReshape} from '../kernel_utils/reshape';\nimport {isReshapeFree} from '../webgl_util';\n\nexport function reshape(args: {\n  inputs: ReshapeInputs,\n  backend: MathBackendWebGL,\n  attrs: ReshapeAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {shape} = attrs;\n  const webglBackend = backend;\n\n  const xSize = util.sizeFromShape(x.shape);\n  const $shape = util.inferFromImplicitShape(shape, xSize);\n  const $xSize = util.sizeFromShape($shape);\n\n  util.assert(\n      xSize === $xSize,\n      () => `The new shape (${$shape}) has ${$xSize} elements and the old ` +\n          `shape (${x.shape}) has ${xSize} elements. The new shape and old ` +\n          `shape must have the same number of elements.`);\n\n  const xTexData = webglBackend.texData.get(x.dataId);\n  if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) &&\n      !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {\n    return packedReshape(x, $shape, webglBackend);\n  }\n\n  webglBackend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: $shape, dtype: x.dtype};\n}\n\nexport const reshapeConfig: KernelConfig = {\n  kernelName: Reshape,\n  backendName: 'webgl',\n  kernelFunc: reshape as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ReshapePackedProgram} from '../reshape_packed_gpu';\nimport {getBatchDim, getRowsCols} from '../webgl_util';\n\nexport function packedReshape(\n    input: TensorInfo, afterShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const input3DShape =\n      [getBatchDim(input.shape),\n       ...getRowsCols(input.shape)] as [number, number, number];\n  const input3D: TensorInfo = {\n    dtype: input.dtype,\n    shape: input3DShape,\n    dataId: input.dataId\n  };\n  const afterShapeAs3D =\n      [getBatchDim(afterShape),\n       ...getRowsCols(afterShape)] as [number, number, number];\n\n  const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n  const preventEagerUnpackingOfOutput = true;\n  const output = backend.runWebGLProgram(\n      program, [input3D], input.dtype, null /* customSetup */,\n      preventEagerUnpackingOfOutput);\n  return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MeanProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(reduceInfo: backend_util.ReduceInfo, divisor?: number) {\n    const {windowSize, batchSize, inSize, outSize} = reduceInfo;\n    this.outputShape = [batchSize, outSize];\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `sumValue += dot(values, ones);`;\n    if (divisor != null) {\n      const denominator = 1 / divisor;\n      updateSnippet = `sumValue += dot(values * ${\n          util.isInt(denominator) ? denominator.toPrecision(2) :\n                                    denominator}, ones);`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return 0.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${updateSnippet}\n        }\n        setOutput(sumValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ReduceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo,\n      reduceType: 'all'|'any'|'max'|'min'|'sum'|'prod') {\n    const {windowSize, batchSize, inSize, outSize} = reduceInfo;\n    this.outputShape = [batchSize, outSize];\n\n    let initializationValue = '0.0';\n    let compareOp = ``;\n\n    if (reduceType === 'prod') {\n      initializationValue = '1.0';\n    } else if (reduceType === 'min') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '1.0 / 1e-20';\n      compareOp = `min`;\n    } else if (reduceType === 'max') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n      compareOp = `max`;\n    }\n\n    let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (reduceType === 'sum') {\n      returnValue = `sumValue`;\n    } else if (reduceType === 'prod') {\n      returnValue = `prodValue`;\n    } else if (reduceType === 'all') {\n      returnValue = `allValue`;\n    } else if (reduceType === 'any') {\n      returnValue = `anyValue`;\n    }\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    let vecType = `vec4`;\n\n    if (reduceType === 'all') {\n      initializationValue = '1.0';\n      updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    } else if (reduceType === 'any') {\n      initializationValue = '0.0';\n      updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MeanProgram} from '../mean_gpu';\nimport {ReduceProgram} from '../reduce_gpu';\n\ntype ReduceTypes = 'all'|'any'|'max'|'min'|'sum'|'prod'|'mean';\n\n// Returns an array of configuration objects that describe each stage of the\n// reduction.\nfunction getReductionStages(inShape: number[]):\n    Array<{inSize: number, windowSize: number, outSize: number}> {\n  const stages = [];\n\n  while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {\n    const outSize: number =\n        stages.length ? stages[stages.length - 1].outSize : inShape[1];\n    const windowSize = backend_util.computeOptimalWindowSize(outSize);\n    stages.push({\n      inSize: outSize,\n      windowSize,\n      outSize: Math.ceil(outSize / windowSize)\n    });\n  }\n\n  return stages;\n}\n\nexport function reduce(\n    x: TensorInfo, dtype: DataType, reductionType: ReduceTypes,\n    backend: MathBackendWebGL): TensorInfo {\n  const reductionStages = getReductionStages(x.shape);\n\n  let result = x;\n  for (let i = 0; i < reductionStages.length; i++) {\n    const {inSize, windowSize, outSize} = reductionStages[i];\n\n    let program: ReduceProgram|MeanProgram;\n    let previousResult: TensorInfo;\n    if (reductionType === 'mean') {\n      program = i === 0 ?\n          new MeanProgram(\n              {windowSize, inSize, batchSize: x.shape[0], outSize}, inSize) :\n          new MeanProgram({windowSize, inSize, batchSize: x.shape[0], outSize});\n    } else {\n      program = new ReduceProgram(\n          {windowSize, inSize, batchSize: x.shape[0], outSize}, reductionType);\n    }\n\n    previousResult = result;\n    result = backend.runWebGLProgram(program, [result], dtype);\n\n    if (previousResult.dataId !== x.dataId) {\n      backend.disposeIntermediateTensorInfo(previousResult);\n    }\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposeProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const switched = getSwitchedCoords(newDim);\n\n    this.userCode = `\n    void main() {\n      ${dtype} resRC = getOutputCoords();\n      setOutput(getA(${switched}));\n    }\n    `;\n  }\n}\n\nfunction getSwitchedCoords(newDim: number[]): string {\n  const rank = newDim.length;\n  if (rank > 6) {\n    throw Error(`Transpose for rank ${rank} is not yet supported`);\n  }\n  const originalOrder =\n      ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n  const switchedCoords = new Array(rank);\n  for (let i = 0; i < newDim.length; i++) {\n    switchedCoords[newDim[i]] = originalOrder[i];\n  }\n  return switchedCoords.join();\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getVecChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    if (this.rank > 6) {\n      throw Error(\n          `Packed transpose for rank ${this.rank} is not yet supported.`);\n    }\n    const dtype = getCoordsDataType(this.rank);\n\n    const outputOrder = getVecChannels('rc', this.rank);\n    const switchedOrder = new Array(this.rank);\n    for (let i = 0; i < newDim.length; i++) {\n      switchedOrder[newDim[i]] = outputOrder[i];\n    }\n    const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;\n    const nextColumn =\n        `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;\n    const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;\n\n    this.userCode = `\n    void main() {\n      ${dtype} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${getc};\n      if(${nextColumn}) {\n        result[1] = ${getc};\n      }\n      --${outputOrder[this.rank - 1]};\n      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {\n        result[2] = ${getc};\n        if(${nextColumn}) {\n          result[3] = ${getc};\n        }\n      }\n      setOutput(result);\n    }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {transposeImplCPU} from '../kernel_utils/shared';\nimport {TransposeProgram} from '../transpose_gpu';\nimport {TransposePackedProgram} from '../transpose_packed_gpu';\n\nexport function transposeImpl(\n    x: TensorInfo, perm: number[], backend: MathBackendWebGL): TensorInfo {\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new TransposePackedProgram(x.shape, perm) :\n      new TransposeProgram(x.shape, perm);\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport {transposeImplCPU};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Sum, SumAttrs, SumInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {sumImpl} from './Sum_impl';\n\nexport function sum(\n    args: {inputs: SumInputs, attrs: SumAttrs, backend: MathBackendWebGL}) {\n  const {inputs, backend, attrs} = args;\n\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  return sumImpl(x, axis, keepDims, backend);\n}\n\nexport const sumConfig: KernelConfig = {\n  kernelName: Sum,\n  backendName: 'webgl',\n  kernelFunc: sum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, sumOutType, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from './Reshape';\n\nimport {transposeImpl} from './Transpose_impl';\n\nexport function sumImpl(\n    x: TensorInfo, axis: number|number[], keepDims: boolean,\n    backend: MathBackendWebGL): TensorInfo {\n  const reductionIndices = axis;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  const sumInputIsTransposed = permutedAxes != null;\n\n  let sumInput = x;\n  if (sumInputIsTransposed) {\n    sumInput = transposeImpl(x, permutedAxes, backend);\n\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n  const [sumOutShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(sumInput.shape, axes);\n\n  let outShape = sumOutShape;\n  if (keepDims) {\n    // rather than reshape at the end, set the target shape here.\n    outShape = backend_util.expandShapeToKeepDim(sumOutShape, origAxes);\n  }\n\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput = reshape(\n      {inputs: {x: sumInput}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const outType = sumOutType(x.dtype);\n\n  const reduced = reduce(reshapedInput, outType, 'sum', backend);\n  const out =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n  if (sumInputIsTransposed) {\n    backend.disposeIntermediateTensorInfo(sumInput);\n  }\n\n  return out;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Transpose, TransposeAttrs, TransposeInputs, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {transposeImpl} from './Transpose_impl';\nimport {transposeImplCPU as cpuTranspose} from './Transpose_impl';\n\nexport function transpose(args: {\n  inputs: TransposeInputs,\n  attrs: TransposeAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {perm} = attrs;\n  const webglBackend = backend;\n\n  const xRank = x.shape.length;\n\n  const newShape: number[] = new Array(xRank);\n  for (let i = 0; i < newShape.length; i++) {\n    newShape[i] = x.shape[perm[i]];\n  }\n\n  let out: TensorInfo;\n  if (webglBackend.shouldExecuteOnCPU([x])) {\n    const xTexData = webglBackend.texData.get(x.dataId);\n    const values = xTexData.values as TypedArray;\n    const outValues = cpuTranspose(values, x.shape, x.dtype, perm, newShape);\n\n    out = webglBackend.makeTensorInfo(newShape, x.dtype);\n    const outData = webglBackend.texData.get(out.dataId);\n    outData.values = outValues;\n  } else {\n    out = transposeImpl(x, perm, webglBackend);\n  }\n  return out;\n}\n\nexport const transposeConfig: KernelConfig = {\n  kernelName: Transpose,\n  backendName: 'webgl',\n  kernelFunc: transpose as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\nimport {MatMulPackedProgram} from '../mulmat_packed_gpu';\n\nimport {multiply} from './Multiply';\nimport {reshape} from './Reshape';\nimport {sum} from './Sum';\nimport {transpose} from './Transpose';\n\n// Empirically determined minimal shared dimension in matmul before we forward\n// to a.mul(b).sum() in order to take advantage of GPU parallelism. See\n// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.\nexport const MATMUL_SHARED_DIM_THRESHOLD = 1000;\n\ntype BatchMatMulConfig = {\n  a: TensorInfo,\n  b: TensorInfo,\n  transposeA: boolean,\n  transposeB: boolean,\n  backend: MathBackendWebGL,\n  bias?: TensorInfo,\n  preluActivationWeights?: TensorInfo,\n  leakyreluAlpha?: number,\n  activation?: backend_util.Activation\n};\n\nexport function batchMatMulImpl({\n  a,\n  b,\n  transposeA,\n  transposeB,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: BatchMatMulConfig): TensorInfo {\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  const batchDimsCompatible =\n      batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;\n\n  util.assert(\n      aRank >= 2 && bRank >= 2 && batchDimsCompatible,\n      () => `Error in matMul: the input batch dimensions must either be the ` +\n          `same or at least one input batch dimension must be 1. Got input ` +\n          `batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);\n\n  const outShapeOuterDims =\n      batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n          `${b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const a3dShape: [number, number, number] = transposeA ?\n      [batchDimA, innerShapeA, outerShapeA] :\n      [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape: [number, number, number] = transposeB ?\n      [batchDimB, outerShapeB, innerShapeB] :\n      [batchDimB, innerShapeB, outerShapeB];\n\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  const a3d = reshape({inputs: {x: a}, backend, attrs: {shape: a3dShape}});\n  const b3d = reshape({inputs: {x: b}, backend, attrs: {shape: b3dShape}});\n\n  const intermediates: TensorInfo[] = [a3d, b3d];\n\n  const batchDim = Math.max(batchDimA, batchDimB);\n  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n  const hasLeakyreluAlpha = activation === 'leakyrelu';\n  const fusedActivation = activation != null ?\n      mapActivationToShaderProgram(activation, true) :\n      null;\n  const containsFusedOps = hasBias || hasPreluActivationWeights ||\n      hasLeakyreluAlpha || fusedActivation != null;\n  let out: TensorInfo;\n\n  // Since the matrices are vectors, it is faster to call mul().sum()\n  // because sum() is O(sqrt(N)) due to divide-and-conquer.\n  if ((outerShapeA === 1 || outerShapeB === 1) &&\n      sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {\n    let aVec = a3d;\n    let bVec = b3d;\n    if (transposeA) {\n      aVec = transpose({inputs: {x: a3d}, backend, attrs: {perm: [0, 2, 1]}});\n      intermediates.push(aVec);\n    }\n    if (transposeB) {\n      bVec = transpose({inputs: {x: b3d}, backend, attrs: {perm: [0, 2, 1]}});\n      intermediates.push(bVec);\n    }\n\n    const shouldReshapeA = outerShapeB !== 1;\n    const shouldReshapeB = outerShapeB === 1;\n\n    let aVec3d = aVec;\n    if (shouldReshapeA) {\n      aVec3d = reshape({\n        inputs: {x: aVec},\n        backend,\n        attrs: {shape: [batchDim, sharedDim, 1]}\n      });\n\n      intermediates.push(aVec3d);\n    }\n\n    const axis = outerShapeB === 1 ? 2 : 1;\n\n    let bVec3d = bVec;\n    if (shouldReshapeB) {\n      bVec3d = reshape({\n        inputs: {x: bVec},\n        backend,\n        attrs: {shape: [batchDim, 1, sharedDim]}\n      });\n\n      intermediates.push(bVec3d);\n    }\n\n    const product = multiply({inputs: {a: aVec3d, b: bVec3d}, backend});\n    out = sum({inputs: {x: product}, backend, attrs: {axis, keepDims: true}});\n    intermediates.push(product);\n  } else {\n    const dtype = upcastType(a.dtype, b.dtype);\n\n    const program = new MatMulPackedProgram(\n        a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA,\n        transposeB, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n\n    const inputs: TensorInfo[] = [a3d, b3d];\n    if (bias != null) {\n      inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    if (hasLeakyreluAlpha) {\n      const $leakyreluAlpha = backend.makeTensorInfo(\n          [], 'float32',\n          util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n      inputs.push($leakyreluAlpha);\n      intermediates.push($leakyreluAlpha);\n    }\n\n    out = backend.runWebGLProgram(program, inputs, dtype);\n  }\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: outShape}});\n  intermediates.push(out);\n  for (const i of intermediates) {\n    backend.disposeIntermediateTensorInfo(i);\n  }\n  return outReshaped;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {_FusedMatMul, _FusedMatMulAttrs, _FusedMatMulInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {batchMatMulImpl} from './BatchMatMul_impl';\n\nexport function _fusedMatMul(args: {\n  inputs: _FusedMatMulInputs,\n  attrs: _FusedMatMulAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b, bias, preluActivationWeights} = inputs;\n  const {transposeA, transposeB, activation, leakyreluAlpha} = attrs;\n\n  return batchMatMulImpl({\n    a,\n    b,\n    transposeA,\n    transposeB,\n    backend,\n    bias,\n    preluActivationWeights,\n    leakyreluAlpha,\n    activation\n  });\n}\n\nexport const _fusedMatMulConfig: KernelConfig = {\n  kernelName: _FusedMatMul,\n  backendName: 'webgl',\n  kernelFunc: _fusedMatMul as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Abs, AbsInputs, env, KernelConfig, KernelFunc, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {simpleAbsImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpProgram} from '../unaryop_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nconst ABS = `return abs(x);`;\n\nexport function abs(args: {inputs: AbsInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  // TODO: handle cases when x is complex. Once the cpu implementation\n  // can handle complex values, refactor to use unaryKernelFunc.\n  if (backend.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n    const xData = backend.texData.get(x.dataId);\n    const outValues = simpleAbsImplCPU(xData.values as TypedArray);\n    return backend.makeTensorInfo(x.shape, x.dtype, outValues);\n  }\n\n  let program: UnaryOpProgram|UnaryOpPackedProgram;\n  if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n    program = new UnaryOpPackedProgram(x.shape, ABS);\n  } else {\n    program = new UnaryOpProgram(x.shape, ABS);\n  }\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const absConfig: KernelConfig = {\n  kernelName: Abs,\n  backendName: 'webgl',\n  kernelFunc: abs as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Acos, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ACOS = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;\n\nexport const acos = unaryKernelFunc({opSnippet: ACOS});\n\nexport const acosConfig: KernelConfig = {\n  kernelName: Acos,\n  backendName: 'webgl',\n  kernelFunc: acos,\n};\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Acosh, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ACOSH = CHECK_NAN_SNIPPET + `\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));`;\n\nexport const acosh = unaryKernelFunc({opSnippet: ACOSH});\n\nexport const acoshConfig: KernelConfig = {\n  kernelName: Acosh,\n  backendName: 'webgl',\n  kernelFunc: acosh,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Add, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {addImplCPU as cpuAdd} from '../kernel_utils/shared';\n\nconst ADD = 'return a + b;';\n\nexport const addKernelFunc = binaryKernelFunc({\n  opSnippet: ADD,\n  packedOpSnippet: ADD,\n  supportsComplex: true,\n  cpuKernelImpl: cpuAdd\n});\n\nexport const addConfig: KernelConfig = {\n  kernelName: Add,\n  backendName: 'webgl',\n  kernelFunc: addKernelFunc\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`float v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        float result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        vec4 result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {AddN, AddNInputs, env, KernelConfig, KernelFunc, TensorInfo, upcastType} from '@tensorflow/tfjs-core';\n\nimport {AddNProgram} from '../addn_gpu';\nimport {AddNPackedProgram} from '../addn_packed_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function addN(args: {inputs: AddNInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n\n  const tensors = inputs;\n  if (tensors.length === 1) {\n    return identity({inputs: {x: tensors[0]}, backend});\n  }\n\n  // Limit the number of uploaded textures for optimization.\n  if (tensors.length > env().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n    const midIndex = Math.floor(tensors.length / 2);\n    const leftSide = addN({inputs: tensors.slice(0, midIndex), backend});\n    const rightSide = addN({inputs: tensors.slice(midIndex), backend});\n    return addN({inputs: [leftSide, rightSide], backend});\n  }\n\n  const dtype =\n      tensors.map(t => t.dtype).reduce((d1, d2) => upcastType(d1, d2));\n  const shapes = tensors.map(t => t.shape);\n  // We can make sure shapes are identical in op level.\n  const usePackedOp = env().getBool('WEBGL_PACK');\n  const program = usePackedOp ?\n      new AddNPackedProgram(tensors[0].shape, shapes) :\n      new AddNProgram(tensors[0].shape, shapes);\n  return backend.runWebGLProgram(program, tensors, dtype);\n}\n\nexport const addNConfig: KernelConfig = {\n  kernelName: AddN,\n  backendName: 'webgl',\n  kernelFunc: addN as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {All, AllAttrs, AllInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\n\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function all(\n    args: {inputs: AllInputs, backend: MathBackendWebGL, attrs: AllAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('all', axes, xRank);\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n  const inSize = util.sizeFromShape(reduceShape);\n\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  const reduced = reduce(a2D, a2D.dtype, 'all', backend);\n\n  let res;\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: newShape}});\n  } else {\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n  }\n\n  backend.disposeIntermediateTensorInfo(a2D);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  if (permutedAxes != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n\n  return res;\n}\n\nexport const allConfig: KernelConfig = {\n  kernelName: All,\n  backendName: 'webgl',\n  kernelFunc: all as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Any, AnyAttrs, AnyInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function any(\n    args: {inputs: AnyInputs, backend: MathBackendWebGL, attrs: AnyAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('any', axes, xRank);\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n  const inSize = util.sizeFromShape(reduceShape);\n\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  const reduced = reduce(a2D, a2D.dtype, 'any', backend);\n\n  let res;\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: newShape}});\n  } else {\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n  }\n\n  backend.disposeIntermediateTensorInfo(a2D);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  if (permutedAxes != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n\n  return res;\n}\n\nexport const anyConfig: KernelConfig = {\n  kernelName: Any,\n  backendName: 'webgl',\n  kernelFunc: any as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ArgMinMaxProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo, op: 'max'|'min',\n      firstPass: boolean) {\n    const {windowSize, batchSize, outSize} = reduceInfo;\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    this.outputShape = [batchSize, outSize];\n    const compOp = (op === 'max') ? '>' : '<';\n    const indexSnippet = firstPass ?\n        'inOffset + i;' :\n        'round(getBestIndicesA(batch, inOffset + i));';\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          int inIdx = ${indexSnippet};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${compOp} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ArgMinMaxPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      shape: number[], windowSize: number, op: 'max'|'min',\n      firstPass: boolean) {\n    util.assert(\n        shape.length > 2,\n        () => `Packed arg${\n            op.charAt(0).toUpperCase() +\n            op.slice(1)} supports only inputs with rank above 2.`);\n    const inSize = shape[shape.length - 1];\n    const outSize = Math.ceil(inSize / windowSize);\n    this.outputShape = shape.slice(0, -1);\n    if (outSize > 1) {\n      this.outputShape.push(outSize);\n    }\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    const outShape = this.outputShape;\n    const rank = outShape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n\n    let sourceLocSetup;\n    let sourceRank;\n    if (outSize === 1) {\n      sourceRank = rank + 1;\n      const sourceLocDType = getCoordsDataType(sourceRank);\n      sourceLocSetup = `\n        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 1]};\n        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 2]};\n        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 1]};\n        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 2]};`;\n    } else {\n      sourceRank = rank;\n      sourceLocSetup = `\n        ${dtype} sourceLocR = coords;\n        ++${coords[rank - 1]};\n        ${dtype} sourceLocG = coords;\n        ++${coords[rank - 2]};\n        ${dtype} sourceLocA = coords;\n        --${coords[rank - 1]};\n        ${dtype} sourceLocB = coords;\n        --${coords[rank - 2]};`;\n    }\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n    const inChannel = '.' + channels[sourceRank - 1];  // e.g. \".b\" for rank 3.\n    const intChannels = channels.map(x => 'int ' + x);\n    const srcRCoords =\n        getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n    const srcGCoords =\n        getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n    const srcBCoords =\n        getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n    const srcACoords =\n        getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n\n    const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n    const fetchCandidateIdx = firstPass ? '' : `\n          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),\n                             getBestIndicesAChannel(${srcGCoords.join()}),\n                             getBestIndicesAChannel(${srcBCoords.join()}),\n                             getBestIndicesAChannel(${srcACoords.join()})));`;\n\n    const fetchValue = `vec4(\n            getAChannel(${srcRCoords.join()}),\n            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,\n            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;\n\n    const getBestIndicesAChannelSnippet = firstPass ? '' : `\n      float getBestIndicesAChannel(${intChannels.join()}) {\n        return getChannel(getBestIndicesA(${channels.join()}),\n                                          vec2(${channels.slice(-2).join()}));\n      }`;\n\n    this.userCode = `\n      float getAChannel(${intChannels.join()}) {\n        return getChannel(getA(${channels.join()}),\n                               vec2(${channels.slice(-2).join()}));\n      }\n      ${getBestIndicesAChannelSnippet}\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};\n        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};\n        ${sourceLocSetup}\n        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},\n          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${fetchValue};\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          inIdx = srcIdx;\n          ${fetchCandidateIdx}\n          vec4 candidate = ${fetchValue};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {ArgMinMaxProgram} from '../argminmax_gpu';\nimport {ArgMinMaxPackedProgram} from '../argminmax_packed_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reshape} from '../kernels/Reshape';\n\nfunction argReduce(\n    backend: MathBackendWebGL, x: TensorInfo, reduceType: 'max'|'min',\n    bestIndicesA: TensorInfo = null): TensorInfo {\n  let batchSize = x.shape[0];\n  let inSize = x.shape[1];\n  if (bestIndicesA != null) {\n    batchSize = bestIndicesA.shape[0];\n    inSize = bestIndicesA.shape[1];\n  }\n  const windowSize = backend_util.computeOptimalWindowSize(inSize);\n  const reduceInfo =\n      {windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize)};\n  const program =\n      new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n  const inputs = [x];\n  if (bestIndicesA != null) {\n    inputs.push(bestIndicesA);\n  }\n  const output = backend.runWebGLProgram(program, inputs, 'int32');\n  // No need to run another GPGPU program.\n  if (output.shape[1] === 1) {\n    return output;\n  }\n  const result = argReduce(backend, x, reduceType, output);\n  backend.disposeIntermediateTensorInfo(output);\n  return result;\n}\n\nfunction argReducePacked(\n    backend: MathBackendWebGL, x: TensorInfo, reduceType: 'max'|'min',\n    bestIndicesA: TensorInfo = null): TensorInfo {\n  const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;\n  const inSize = inShape[inShape.length - 1];\n  const windowSize = backend_util.computeOptimalWindowSize(inSize);\n  const program = new ArgMinMaxPackedProgram(\n      inShape, windowSize, reduceType, bestIndicesA == null);\n  const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];\n  const output = backend.runWebGLProgram(program, inputs, 'int32');\n  if (output.shape.length === x.shape.length) {\n    const result = argReducePacked(backend, x, reduceType, output);\n    backend.disposeIntermediateTensorInfo(output);\n    return result;\n  }\n  return output;\n}\n\nexport function argMinMaxReduce(\n    backend: MathBackendWebGL, x: TensorInfo, axis: number,\n    reduceType: 'min'|'max'): TensorInfo {\n  const axes = [axis];\n  backend_util.assertAxesAreInnerMostDims(\n      'arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes,\n      x.shape.length);\n  if (!env().getBool('WEBGL_PACK_REDUCE') || x.shape.length <= 2) {\n    const intermediateTensorInfos = [];\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = reshape({inputs: {x}, backend, attrs: {shape: [-1, inSize]}});\n    intermediateTensorInfos.push(a2D);\n\n    const reduced = argReduce(backend, a2D, reduceType);\n    intermediateTensorInfos.push(reduced);\n    const reshaped =\n        reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n\n    intermediateTensorInfos.forEach(\n        t => backend.disposeIntermediateTensorInfo(t));\n    return reshaped;\n  }\n  return argReducePacked(backend, x, reduceType);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ArgMax, ArgMaxAttrs, ArgMaxInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {argMinMaxReduce} from '../kernel_utils/arg_min_max';\n\nimport {transpose} from './Transpose';\n\nexport function argMax(\n    args:\n        {inputs: ArgMaxInputs, backend: MathBackendWebGL, attrs: ArgMaxAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis} = attrs;\n\n  let axes = util.parseAxisParam(axis, x.shape);\n  const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n  let $x = x;\n  const intermediateTensorInfos = [];\n  if (permutedAxes != null) {\n    $x = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    intermediateTensorInfos.push($x);\n    axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('argMax', [axes[0]], $x.shape.length);\n  const out = argMinMaxReduce(backend, $x, axes[0], 'max');\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n  return out;\n}\n\nexport const argMaxConfig: KernelConfig = {\n  kernelName: ArgMax,\n  backendName: 'webgl',\n  kernelFunc: argMax as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ArgMin, ArgMinAttrs, ArgMinInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {argMinMaxReduce} from '../kernel_utils/arg_min_max';\nimport {transpose} from './Transpose';\n\nexport function argMin(\n    args:\n        {inputs: ArgMinInputs, backend: MathBackendWebGL, attrs: ArgMinAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis} = attrs;\n\n  let axes = util.parseAxisParam(axis, x.shape);\n  const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n  let $x = x;\n  const intermediateTensorInfos = [];\n  if (permutedAxes != null) {\n    $x = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    intermediateTensorInfos.push($x);\n    axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('argMin', [axes[0]], $x.shape.length);\n\n  const out = argMinMaxReduce(backend, $x, axes[0], 'min');\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n  return out;\n}\n\nexport const argMinConfig: KernelConfig = {\n  kernelName: ArgMin,\n  backendName: 'webgl',\n  kernelFunc: argMin as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Asin, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ASIN = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;\n\nexport const asin = unaryKernelFunc({opSnippet: ASIN});\n\nexport const asinConfig: KernelConfig = {\n  kernelName: Asin,\n  backendName: 'webgl',\n  kernelFunc: asin,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Asinh, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;\n\nexport const asinh = unaryKernelFunc({opSnippet: ASINH});\n\nexport const asinhConfig: KernelConfig = {\n  kernelName: Asinh,\n  backendName: 'webgl',\n  kernelFunc: asinh,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Atan, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ATAN = CHECK_NAN_SNIPPET + `\n  return atan(x);\n`;\n\nexport const atan = unaryKernelFunc({opSnippet: ATAN});\n\nexport const atanConfig: KernelConfig = {\n  kernelName: Atan,\n  backendName: 'webgl',\n  kernelFunc: atan,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Atan2} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc, CHECK_NAN_SNIPPET_BINARY, CHECK_NAN_SNIPPET_BINARY_PACKED} from '../kernel_utils/kernel_funcs_utils';\n\nconst ATAN2 = CHECK_NAN_SNIPPET_BINARY + `\n  return atan(a, b);\n`;\n\nconst ATAN2_PACKED = `\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET_BINARY_PACKED + `\n  return result;\n`;\n\nexport const atan2 =\n    binaryKernelFunc({opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED});\n\nexport const atan2Config: KernelConfig = {\n  kernelName: Atan2,\n  backendName: 'webgl',\n  kernelFunc: atan2,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Atanh, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ATANH = CHECK_NAN_SNIPPET + `\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;`;\n\nexport const atanh = unaryKernelFunc({opSnippet: ATANH});\n\nexport const atanhConfig: KernelConfig = {\n  kernelName: Atanh,\n  backendName: 'webgl',\n  kernelFunc: atanh,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Pool2DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${\n        convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n    const flattenPositionStr =\n        `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${\n          flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                                                    flattenPositionStr) :\n                             `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n\nexport class Pool3DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv3DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${\n          flattenPositions ?\n              (includeBatchInIndex ?\n                   `(((batch * ${convInfo.inDepth} + xD) * ${\n                       convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${\n                       convInfo.inChannels} + ch` :\n                   `((xD * ${convInfo.inHeight} + xR) * ${\n                       convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n              `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool, AvgPoolAttrs, AvgPoolInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\nimport {identity} from './Identity';\n\nexport function avgPool(args: {\n  inputs: AvgPoolInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPoolAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  assertNotComplex(x, 'avgPool');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in avgPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n      util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return identity({inputs: {x}, backend});\n  }\n  const avgPoolProgram = new Pool2DProgram(convInfo, 'avg', false);\n  return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\n\nexport const avgPoolConfig: KernelConfig = {\n  kernelName: AvgPool,\n  backendName: 'webgl',\n  kernelFunc: avgPool as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool3D, AvgPool3DAttrs, AvgPool3DInputs, backend_util, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool3DProgram} from '../pool_gpu';\n\nexport function avgPool3D(args: {\n  inputs: AvgPool3DInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPool3DAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {filterSize, strides, pad, dimRoundingMode, dataFormat} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode, dataFormat);\n  const avgPoolProgram = new Pool3DProgram(convInfo, 'avg', false);\n  return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\n\nexport const avgPool3DConfig: KernelConfig = {\n  kernelName: AvgPool3D,\n  backendName: 'webgl',\n  kernelFunc: avgPool3D as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AvgPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth};\n            wC+= ${dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class AvgPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool3DGrad, AvgPool3DGradAttrs, AvgPool3DGradInputs, backend_util, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {AvgPool3DBackpropProgram} from '../avg_pool_backprop_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function avgPool3DGrad(args: {\n  inputs: AvgPool3DGradInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPool3DGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input} = inputs;\n  const x = input;\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);\n  return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\n\nexport const avgPoolGrad3DConfig: KernelConfig = {\n  kernelName: AvgPool3DGrad,\n  backendName: 'webgl',\n  kernelFunc: avgPool3DGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPoolGrad, AvgPoolGradAttrs, AvgPoolGradInputs, backend_util, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {AvgPool2DBackpropProgram} from '../avg_pool_backprop_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function avgPoolGrad(args: {\n  inputs: AvgPoolGradInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPoolGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input} = inputs;\n  const x = input;\n  assertNotComplex([dy, input], 'avgPoolGrad');\n  const {filterSize, strides, pad} = attrs;\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      1 /* dilations */, pad);\n  const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);\n  return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\n\nexport const avgPoolGradConfig: KernelConfig = {\n  kernelName: AvgPoolGrad,\n  backendName: 'webgl',\n  kernelFunc: avgPoolGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BatchMatMul, BatchMatMulAttrs, BatchMatMulInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {batchMatMulImpl} from './BatchMatMul_impl';\n\nexport function batchMatMul(args: {\n  inputs: BatchMatMulInputs,\n  attrs: BatchMatMulAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b} = inputs;\n  const {transposeA, transposeB} = attrs;\n\n  return batchMatMulImpl({a, b, transposeA, transposeB, backend});\n}\n\nexport const batchMatMulConfig: KernelConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'webgl',\n  kernelFunc: batchMatMul as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = '0.0';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = '1.0';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = 'vec4(0.0)';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = 'vec4(1.0)';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        vec4 offset = ${offsetSnippet};\n        vec4 scale = ${scaleSnippet};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;\n  }\n}\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, FusedBatchNorm, FusedBatchNormAttrs, FusedBatchNormInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BatchNormProgram} from '../batchnorm_gpu';\nimport {BatchNormPackedProgram} from '../batchnorm_packed_gpu';\n\nexport const batchNorm: (params: {\n  inputs: FusedBatchNormInputs,\n  backend: MathBackendWebGL,\n  attrs: FusedBatchNormAttrs\n}) => TensorInfo = ({inputs, backend, attrs}) => {\n  const {x, mean, variance, offset, scale} = inputs;\n\n  util.assert(\n      mean.shape.length === variance.shape.length,\n      () => 'Batch normalization gradient requires mean and variance to have ' +\n          'equal ranks.');\n  util.assert(\n      offset == null || mean.shape.length === offset.shape.length,\n      () => 'Batch normalization gradient requires mean and offset to have ' +\n          'equal ranks.');\n  util.assert(\n      scale == null || mean.shape.length === scale.shape.length,\n      () => 'Batch normalization gradient requires mean and scale to have ' +\n          'equal ranks.');\n\n  let {varianceEpsilon} = attrs;\n  if (varianceEpsilon == null) {\n    varianceEpsilon = 0.001;\n  }\n\n  const finalInputs = [x, mean, variance];\n\n  let offsetShape = null;\n  if (offset != null) {\n    offsetShape = offset.shape;\n    finalInputs.push(offset);\n  }\n\n  let scaleShape = null;\n  if (scale != null) {\n    scaleShape = scale.shape;\n    finalInputs.push(scale);\n  }\n\n  const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n      new BatchNormPackedProgram(\n          x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n          varianceEpsilon) :\n      new BatchNormProgram(\n          x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n          varianceEpsilon);\n  const output =\n      backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);\n\n  return output;\n};\n\nexport const batchNormConfig: KernelConfig = {\n  kernelName: FusedBatchNorm,\n  backendName: 'webgl',\n  kernelFunc: batchNorm as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SliceProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  // Caching uniform location for speed.\n  startLoc: WebGLUniformLocation;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n\n    const dtype = getCoordsDataType(this.rank);\n    const uniformPart = `uniform int start[${this.rank}];`;\n    const sourceCoords = getCoords(this.rank);\n\n    let body: string;\n    const coordSum = destSize.map((_, i) => {\n      return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n    });\n    body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n    this.userCode = `\n      ${uniformPart}\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(start: number[]) {\n    if (start.length !== this.rank) {\n      throw Error(\n          `The rank (${this.rank}) of the program must match the ` +\n          `length of start (${start.length})`);\n    }\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.startLoc == null) {\n        this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n        if (this.startLoc == null) {\n          // This means the compiler has optimized and realized it doesn't need\n          // the uniform.\n          return;\n        }\n      }\n      gpgpu.gl.uniform1iv(this.startLoc, start);\n    };\n  }\n}\n\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\n\nfunction getCoords(rank: number): string {\n  if (rank === 1) {\n    return 'sourceLoc';\n  } else if (rank <= 6) {\n    return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n  } else {\n    throw Error(`Slicing for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SlicePackedProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  // Caching uniform location for speed.\n  startLoc: WebGLUniformLocation;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n\n    const dtype = getCoordsDataType(this.rank);\n    const coords = getChannels('coords', this.rank);\n    const sourceLoc = getChannels('sourceLoc', this.rank);\n\n    const innerDims =\n        this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;\n    const getChannel =\n        `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;\n    const upperRow = `\n      result.x = ${getChannel};\n      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n        ++${sourceLoc[this.rank - 1]};\n        result.y = ${getChannel};\n        --${sourceLoc[this.rank - 1]};\n      }\n    `;\n    const lowerRow = this.rank === 1 ? '' : `\n      --${coords[this.rank - 1]};\n      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {\n        ++${sourceLoc[this.rank - 2]};\n        result.z = ${getChannel};\n        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n          ++${sourceLoc[this.rank - 1]};\n          result.w = ${getChannel};\n        }\n      }\n    `;\n\n    const sourceLocSetup = this.rank <= 4 ?\n        `sourceLoc = coords +\n            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :\n        destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)\n            .join('\\n');\n    this.userCode = `\n      uniform int start[${this.rank}];\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        ${dtype} sourceLoc;\n        ${sourceLocSetup}\n        vec4 result = vec4(0.);\n        ${upperRow}\n        ${lowerRow}\n        setOutput(result);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(start: number[]) {\n    if (start.length !== this.rank) {\n      throw Error(\n          `The rank (${this.rank}) of the program must match the ` +\n          `length of start (${start.length})`);\n    }\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.startLoc == null) {\n        this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n        if (this.startLoc == null) {\n          // This means the compiler has optimized and realized it doesn't need\n          // the uniform.\n          return;\n        }\n      }\n      gpgpu.gl.uniform1iv(this.startLoc, start);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Slice, slice_util, SliceAttrs, SliceInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sliceImplCPU} from '../kernel_utils/shared';\nimport {SliceProgram} from '../slice_gpu';\nimport {SlicePackedProgram} from '../slice_packed_gpu';\n\nfunction shallowSlice(\n    x: TensorInfo, begin: number[], size: number[], backend: MathBackendWebGL) {\n  const xTexData = backend.texData.get(x.dataId);\n  const t = backend.makeTensorInfo(size, x.dtype);\n  const newTexData = backend.texData.get(t.dataId);\n  // Copy texture data from the original tensor.\n  Object.assign(newTexData, xTexData);\n  newTexData.refCount = 1;\n  newTexData.shape = size;\n  newTexData.dtype = x.dtype;\n  let flatOffset =\n      slice_util.computeFlatOffset(begin, util.computeStrides(x.shape));\n  if (xTexData.slice) {\n    // We are slicing an already sliced tensor, so we have to accumulate\n    // the offset.\n    flatOffset += xTexData.slice.flatOffset;\n  }\n  newTexData.slice = {\n    flatOffset,\n    // Point to the original dataId, which is used to do ref counting.\n    origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n  };\n\n  // Increase the ref count for that data bucket.\n  const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n  backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n  return t;\n}\n\nexport function slice(\n    args: {inputs: SliceInputs, backend: MathBackendWebGL, attrs: SliceAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {begin, size} = attrs;\n\n  const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n  slice_util.assertParamsValid(x, $begin, $size);\n\n  if (util.sizeFromShape($size) === 0) {\n    return backend.makeTensorInfo($size, x.dtype, []);\n  }\n\n  // Run on cpu if dtype is string. For string, the backend represents it\n  // as Uint8Array[], where each Uint8Array is a character. Given that the\n  // computation is only on the outer array, uploading the whole data onto\n  // gpu is wasteful. Also, currently webgl doesn't have a design to\n  // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n  // just run the kernel on cpu if dtype is string.\n  if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n    const xTexData = backend.texData.get(x.dataId);\n    const outValues = sliceImplCPU(\n        xTexData.values as TypedArray, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outValues);\n  }\n\n  const {isPacked} = backend.texData.get(x.dataId);\n  const isContinous = slice_util.isSliceContinous(x.shape, $begin, $size);\n  if (isPacked || !isContinous) {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new SlicePackedProgram($size) :\n        new SliceProgram($size);\n    const customSetup = program.getCustomSetupFunc($begin);\n    return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n  }\n  backend.uploadToGPU(x.dataId);\n  return shallowSlice(x, $begin, $size, backend);\n}\n\nexport const sliceConfig: KernelConfig = {\n  kernelName: Slice,\n  backendName: 'webgl',\n  kernelFunc: slice as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BatchToSpaceND, BatchToSpaceNDAttrs, BatchToSpaceNDInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\nimport {transpose} from './Transpose';\n\nexport const batchToSpaceND = (args: {\n  inputs: BatchToSpaceNDInputs,\n  backend: MathBackendWebGL,\n  attrs: BatchToSpaceNDAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockShape, crops} = attrs;\n\n  util.assert(\n      x.shape.length <= 4,\n      () => 'batchToSpaceND for rank > 4 with a WebGL backend not ' +\n          'implemented yet');\n  const prod = blockShape.reduce((a, b) => a * b);\n\n  const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n  const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n  const reshapedPermuted =\n      backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n  const sliceBeginCoords =\n      backend_util.getSliceBeginCoords(crops, blockShape.length);\n  const sliceSize =\n      backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n\n  const toDispose = [];\n\n  const reshapedIntermediate =\n      reshape({inputs: {x}, backend, attrs: {shape: reshaped}});\n  const transposedIntermediate = transpose(\n      {inputs: {x: reshapedIntermediate}, backend, attrs: {perm: permuted}});\n  const reshapedIntermediate2 = reshape({\n    inputs: {x: transposedIntermediate},\n    backend,\n    attrs: {shape: reshapedPermuted}\n  });\n  const sliced = slice({\n    inputs: {x: reshapedIntermediate2},\n    backend,\n    attrs: {begin: sliceBeginCoords, size: sliceSize}\n  });\n\n  toDispose.push(reshapedIntermediate);\n  toDispose.push(transposedIntermediate);\n  toDispose.push(reshapedIntermediate2);\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return sliced;\n};\n\nexport const batchToSpaceNDConfig: KernelConfig = {\n  kernelName: BatchToSpaceND,\n  backendName: 'webgl',\n  kernelFunc: batchToSpaceND as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Bincount, BincountAttrs, BincountInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {bincountImplCPU} from '../kernel_utils/shared';\n\nexport function bincount(args: {\n  inputs: BincountInputs,\n  backend: MathBackendWebGL,\n  attrs: BincountAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, weights} = inputs;\n  const {size} = attrs;\n\n  const xVals = backend.readSync(x.dataId) as TypedArray;\n  const weightsVals = backend.readSync(weights.dataId) as TypedArray;\n\n  const outVals =\n      bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n\n  return backend.makeTensorInfo([size], weights.dtype, outVals);\n}\n\nexport const bincountConfig: KernelConfig = {\n  kernelName: Bincount,\n  backendName: 'webgl',\n  kernelFunc: bincount as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NotEqual} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst NOT_EQUAL = `return float(a != b);`;\n\nexport const notEqual = binaryKernelFunc({opSnippet: NOT_EQUAL, dtype: 'bool'});\n\nexport const notEqualConfig: KernelConfig = {\n  kernelName: NotEqual,\n  backendName: 'webgl',\n  kernelFunc: notEqual,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Real, RealInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function real(args: {inputs: RealInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.texData.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.real}, backend});\n}\n\nexport const realConfig: KernelConfig = {\n  kernelName: Real,\n  backendName: 'webgl',\n  kernelFunc: real as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport {BinaryInputs, Cast, CastAttrs, CastInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {complex} from './Complex';\nimport {identity} from './Identity';\nimport {notEqual} from './NotEqual';\nimport {real} from './Real';\n\nimport {int} from '../kernel_utils/int';\n\nexport function cast(\n    args: {inputs: CastInputs, backend: MathBackendWebGL, attrs: CastAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dtype} = attrs;\n\n  // Casting to complex64.\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({inputs: {x}, backend});\n    }\n\n    // TODO(annxingyuan): Import kernel function once zeros is modularized.\n    const zerosTensor = tf.zeros(x.shape);\n    const floatX = cast({inputs: {x}, backend, attrs: {dtype: 'float32'}});\n\n    const result =\n        complex({inputs: {real: floatX, imag: zerosTensor}, backend});\n\n    zerosTensor.dispose();\n    backend.disposeIntermediateTensorInfo(floatX);\n\n    return result;\n  }\n\n  // Casting from complex64\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const result = cast({inputs: {x: realPart}, backend, attrs: {dtype}});\n    backend.disposeIntermediateTensorInfo(realPart);\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({inputs: {x}, backend});\n    return {dataId: result.dataId, shape: result.shape, dtype};\n  }\n\n  if (dtype === 'int32') {\n    return int(x, backend);\n  }\n\n  if (dtype === 'bool') {\n    const zerosTensorInfo = backend.makeTensorInfo(\n        [], 'bool', util.getTypedArrayFromDType('bool', 1));\n\n    const binaryInputs: BinaryInputs = {a: x, b: zerosTensorInfo};\n\n    const result = notEqual({inputs: binaryInputs, backend}) as TensorInfo;\n    backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n    return result;\n  }\n\n  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\n\nexport const castConfig: KernelConfig = {\n  kernelName: Cast,\n  backendName: 'webgl',\n  kernelFunc: cast as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {UnaryOpProgram} from '../unaryop_gpu';\n\nconst TO_INT = `return float(int(x));`;\n\nexport function int(input: TensorInfo, backend: MathBackendWebGL): TensorInfo {\n  const program = new UnaryOpProgram(input.shape, TO_INT);\n  const output = backend.runWebGLProgram(program, [input], 'int32');\n  return {dataId: output.dataId, shape: output.shape, dtype: output.dtype};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Ceil, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {ceilImplCPU} from '../kernel_utils/shared';\n\nconst CEIL = `return ceil(x);`;\n\nexport const ceil = unaryKernelFunc(\n    {opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU});\n\nexport const ceilConfig: KernelConfig = {\n  kernelName: Ceil,\n  backendName: 'webgl',\n  kernelFunc: ceil as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ClipProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  // Caching uniform locations for speed.\n  minLoc: WebGLUniformLocation;\n  maxLoc: WebGLUniformLocation;\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(min: number, max: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.minLoc == null) {\n        this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n        this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n      }\n      gpgpu.gl.uniform1f(this.minLoc, min);\n      gpgpu.gl.uniform1f(this.maxLoc, max);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ClipPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  userCode: string;\n  outputShape: number[];\n\n  // Caching uniform locations for speed.\n  minLoc: WebGLUniformLocation;\n  maxLoc: WebGLUniformLocation;\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(min: number, max: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.minLoc == null) {\n        this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n        this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n      }\n      gpgpu.gl.uniform1f(this.minLoc, min);\n      gpgpu.gl.uniform1f(this.maxLoc, max);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ClipByValue, ClipByValueAttrs, ClipByValueInputs, env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ClipProgram} from '../clip_gpu';\nimport {ClipPackedProgram} from '../clip_packed_gpu';\n\nexport function clipByValue(args: {\n  inputs: ClipByValueInputs,\n  backend: MathBackendWebGL,\n  attrs: ClipByValueAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {clipValueMin, clipValueMax} = attrs;\n\n  let program;\n  if (env().getBool('WEBGL_PACK_CLIP')) {\n    program = new ClipPackedProgram(x.shape);\n  } else {\n    program = new ClipProgram(x.shape);\n  }\n  const customSetup = program.getCustomSetupFunc(clipValueMin, clipValueMax);\n  return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n}\n\nexport const clipByValueConfig: KernelConfig = {\n  kernelName: ClipByValue,\n  backendName: 'webgl',\n  kernelFunc: clipByValue as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ComplexAbsProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n    this.userCode = `\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ComplexAbs, ComplexAbsInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ComplexAbsProgram} from '../complex_abs_gpu';\n\n// Returns a TensorInfo with the complex shape and the dataId of the\n// underlying part. We need to do this because a reshaped complex tensor is\n// not reflected in its parts.\nfunction makeComplexComponentTensorInfo(\n    complexTensor: TensorInfo, complexPart: TensorInfo): TensorInfo {\n  return {\n    dataId: complexPart.dataId,\n    dtype: complexPart.dtype,\n    shape: complexTensor.shape\n  };\n}\n\nexport function complexAbs(\n    args: {inputs: ComplexAbsInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  const xData = backend.texData.get(x.dataId);\n\n  const program = new ComplexAbsProgram(x.shape);\n  const programInputs = [\n    makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),\n    makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag),\n  ];\n\n  return backend.runWebGLProgram(\n      program, programInputs, programInputs[0].dtype);\n}\n\nexport const complexAbsConfig: KernelConfig = {\n  kernelName: ComplexAbs,\n  backendName: 'webgl',\n  kernelFunc: complexAbs as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ConcatProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n  constructor(shapes: Array<[number, number]>) {\n    this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][1];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][1];\n    }\n\n    const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      snippets.push(\n          `else if (yC < ${offsets[i]}) ` +\n          `setOutput(getT${i}(yR, yC-${shift}));`);\n    }\n    const lastIndex = offsets.length;\n    const lastShift = offsets[offsets.length - 1];\n    snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ConcatPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(shapes: number[][], axis: number) {\n    this.outputShape = backend_util.computeOutShape(shapes, axis);\n    const shape = this.outputShape;\n    const rank = shape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][axis];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][axis];\n    }\n\n    const channel = channels[axis];\n    const lastChannels = channels.slice(-2);\n    const allChannels = channels.join();\n\n    let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      // Note: the >= comparison below may seem unnecessary given the check\n      // above but is needed to workaround branch execution issues on some\n      // devices. It makes all the conditions exclusive without relying on\n      // execution order.\n      getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n    }\n    const lastIndex = offsets.length;\n    const shift = offsets[offsets.length - 1];\n    getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n\n    this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n  }\n}\n\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels: string[], channel: string, shift: number) {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Imag, ImagInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function imag(args: {inputs: ImagInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.texData.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.imag}, backend});\n}\n\nexport const imagConfig: KernelConfig = {\n  kernelName: Imag,\n  backendName: 'webgl',\n  kernelFunc: imag as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, ConcatInputs, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ConcatProgram} from '../concat_gpu';\nimport {ConcatPackedProgram} from '../concat_packed_gpu';\nimport {concatImplCPU} from '../kernel_utils/shared';\n\nimport {complex} from './Complex';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {reshape} from './Reshape';\n\nexport function concatImpl(\n    inputs: ConcatInputs, axis: number, backend: MathBackendWebGL): TensorInfo {\n  const dtype = inputs[0].dtype;\n  if (dtype === 'complex64') {\n    const reals = inputs.map((t) => real({inputs: {input: t}, backend}));\n    const imags = inputs.map((t) => imag({inputs: {input: t}, backend}));\n\n    const realConcated = concatImpl(reals, axis, backend);\n    const imagConcated = concatImpl(imags, axis, backend);\n\n    const result =\n        complex({inputs: {real: realConcated, imag: imagConcated}, backend});\n\n    reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n    backend.disposeIntermediateTensorInfo(realConcated);\n    backend.disposeIntermediateTensorInfo(imagConcated);\n\n    return result;\n  }\n\n  let runOnCpu = backend.shouldExecuteOnCPU(inputs);\n\n  // Run on cpu if dtype is string. For string, the backend represents it\n  // as Uint8Array[], where each Uint8Array is a character. Given that the\n  // computation is only on the outer array, uploading the whole data onto\n  // gpu is wasteful. Also, currently webgl doesn't have a design to\n  // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n  // just run the kernel on cpu if dtype is string.\n  if (dtype === 'string') {\n    runOnCpu = true;\n  }\n\n  if (runOnCpu) {\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    const tensors2D = inputs.map(t => {\n      const innerSize = util.sizeFromShape(t.shape.slice(axis));\n      const shape = [-1, innerSize];\n      return reshape({inputs: {x: t}, backend, attrs: {shape}});\n    });\n\n    const inputsValShapes = tensors2D.map(t => {\n      return {vals: backend.readSync(t.dataId), shape: t.shape};\n    });\n\n    // Concats 2d tensors along axis=1.\n    const outShape =\n        backend_util.computeOutShape(tensors2D.map(t => t.shape), 1 /* axis */);\n    const simplyConcat = tensors2D[0].shape[0] === 1;\n    const outVals =\n        concatImplCPU(inputsValShapes, outShape, dtype, simplyConcat);\n\n    const finalOutShape =\n        backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n\n    const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);\n\n    tensors2D.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n    return outInfo;\n  }\n\n  if (inputs.length > env().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n    const midIndex = Math.floor(inputs.length / 2);\n    const leftSide = concatImpl(inputs.slice(0, midIndex), axis, backend);\n    const rightSide = concatImpl(inputs.slice(midIndex), axis, backend);\n\n    const result = concatImpl([leftSide, rightSide], axis, backend);\n\n    backend.disposeIntermediateTensorInfo(leftSide);\n    backend.disposeIntermediateTensorInfo(rightSide);\n\n    return result;\n  }\n\n  if (env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') &&\n      inputs[0].shape.length > 1) {\n    const program = new ConcatPackedProgram(inputs.map(t => t.shape), axis);\n    return backend.runWebGLProgram(program, inputs, dtype);\n  }\n\n  const {tensors2D, outShape} = computeTensors2D(inputs, axis, backend);\n  const program =\n      new ConcatProgram(tensors2D.map(t => t.shape as [number, number]));\n  const result = backend.runWebGLProgram(program, tensors2D, dtype);\n\n  tensors2D.forEach(r => backend.disposeIntermediateTensorInfo(r));\n  const reshapedResult =\n      reshape({inputs: {x: result}, attrs: {shape: outShape}, backend});\n  backend.disposeIntermediateTensorInfo(result);\n\n  return reshapedResult;\n}\n\nfunction computeTensors2D(\n    inputs: ConcatInputs, axis: number, backend: MathBackendWebGL) {\n  // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the\n  // axis to be concatenated and the rest. Then reshape the tensors\n  // into a two-dimensional tensor by collapsing these two sets of axes and\n  // concatenate the resulting matrices across the axis 1, finally reshaping\n  // the result to have the proper shape.\n  const outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n  const tensors2D = inputs.map(\n      x => reshape({\n        inputs: {x},\n        attrs: {shape: [-1, util.sizeFromShape(x.shape.slice(axis))]},\n        backend\n      }));\n\n  return {tensors2D, outShape};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Concat, ConcatAttrs, ConcatInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {concatImpl} from './Concat_impl';\nimport {identity} from './Identity';\n\nexport function concat(\n    args:\n        {inputs: ConcatInputs, attrs: ConcatAttrs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n  const outShape =\n      backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  }\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return identity({inputs: {x: $inputs[0]}, backend});\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n\n  return concatImpl($inputs, $axis, backend);\n}\n\nexport const concatConfig: KernelConfig = {\n  kernelName: Concat,\n  backendName: 'webgl',\n  kernelFunc: concat as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivationWeights = false,\n      hasLeakyreluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyreluAlpha) {\n        activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (hasLeakyreluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nexport class Conv3DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.outShape;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n\n    this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${\n        strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Im2ColPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      outputShape: number[], inputShape: number[],\n      convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = outputShape;\n\n    const {\n      filterWidth,\n      inChannels,\n      strideWidth,\n      strideHeight,\n      padInfo,\n      outWidth,\n      dilationWidth,\n      dilationHeight,\n      dataFormat\n    } = convInfo;\n    const {left, top} = padInfo;\n    const itemsPerBlockRow = inChannels * filterWidth;\n    const glsl = getGlslDifferences();\n    const isChannelsLast = dataFormat === 'channelsLast';\n    const rowDim = isChannelsLast ? 0 : 1;\n    const colDim = isChannelsLast ? 1 : 2;\n\n    let unrolled = ``;\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        unrolled += `\n          blockIndex = rc.y + ${col};\n          pos = rc.x + ${row};\n\n          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {\n            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${\n            top};\n            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});\n\n            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${\n            strideWidth}. - ${left}.);\n              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${\n            itemsPerBlockRow}.) / ${inChannels}.));\n\n              if(d1 < ${inputShape[colDim]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${inChannels}.));\n\n                if (${isChannelsLast}) {\n                  innerDims = vec2(d1, ch);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;\n      }\n    }\n\n    this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${unrolled}\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Im2ColPackedProgram} from '../im2col_packed_gpu';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\nimport {MatMulPackedProgram} from '../mulmat_packed_gpu';\nimport * as webgl_util from '../webgl_util';\n\nimport {batchMatMulImpl, MATMUL_SHARED_DIM_THRESHOLD} from './BatchMatMul_impl';\nimport {identity} from './Identity';\nimport {reshape} from './Reshape';\n\ntype Conv2DConfig = {\n  x: TensorInfo,\n  filter: TensorInfo,\n  convInfo: backend_util.Conv2DInfo,\n  backend: MathBackendWebGL,\n  bias?: TensorInfo,\n  preluActivationWeights?: TensorInfo,\n  leakyreluAlpha?: number,\n  activation?: backend_util.Activation\n};\n\n// For 1x1 kernels that iterate through every point in the input, convolution\n// can be expressed as matrix multiplication (without need for memory\n// remapping).\nexport function conv2dByMatMul({\n  x,\n  filter,\n  convInfo,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: Conv2DConfig) {\n  // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the\n  // result from 2D to 4D.\n  const xShape = x.shape;\n  const xTexData = backend.texData.get(x.dataId);\n  const sharedMatMulDim = convInfo.inChannels;\n  const outerShapeX = xShape[0] * xShape[1] * xShape[2];\n  const outerShapeFilter = convInfo.outChannels;\n  const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n  const transposeA = false;\n  const transposeB = false;\n\n  let out: TensorInfo;\n  const intermediates: TensorInfo[] = [];\n\n  // TODO: Once reduction ops are packed, batchMatMul will always be packed\n  // and we can remove this condition.\n  const batchMatMulWillBeUnpacked =\n      (outerShapeX === 1 || outerShapeFilter === 1) &&\n      sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;\n  const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;\n\n  if (batchMatMulWillBeUnpacked || !env().getBool('WEBGL_LAZILY_UNPACK') ||\n      !env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ||\n      !reshapeWillBeExpensive) {\n    const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :\n                                         xShape[0] * xShape[2] * xShape[3];\n    const xReshaped = reshape({\n      inputs: {x},\n      backend,\n      attrs: {shape: [1, targetShape, convInfo.inChannels]}\n    });\n    const filterReshaped = reshape({\n      inputs: {x: filter},\n      backend,\n      attrs: {shape: [1, convInfo.inChannels, convInfo.outChannels]}\n    });\n    const result = batchMatMulImpl({\n      a: xReshaped,\n      b: filterReshaped,\n      transposeA,\n      transposeB,\n      backend,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n\n    out = reshape(\n        {inputs: {x: result}, backend, attrs: {shape: convInfo.outShape}});\n\n    intermediates.push(xReshaped);\n    intermediates.push(filterReshaped);\n    intermediates.push(result);\n  } else {\n    // Following optimization is specific to packed |x| with odd row count\n    // (For example, in channelLast mode, 'row count' refers to x.shape[2]):\n    // we avoid expensive packed 2x2 reshape by padding row count to next,\n    // even number. When x.shape[2] is odd, the result of packed batchMatMul is\n    // the same (has the same texture layout and and values in the texture) as\n    // it is for even x.shape[2] + 1. We make the odd-rows tensor to look like\n    // even-rows tensor before the operation and, after the batchMatMul,\n    // fix the even-rows result to have odd number of rows.\n    const targetShape = isChannelsLast ?\n        xShape[0] * xShape[1] * (xShape[2] + 1) :\n        xShape[0] * xShape[2] * (xShape[3] + 1);\n    const xReshaped: TensorInfo = {\n      dataId: x.dataId,\n      shape: [1, targetShape, convInfo.inChannels],\n      dtype: x.dtype\n    };\n    // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.\n    // Decrementing row count, after batchMatMul->...->compileProgram leads to\n    // invalid row count within the reference in GPGPUBinary.inShapeInfos.\n    // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos\n    // in compileProgram method, but that would affect compilation of all\n    // programs - instead, provide a copy here, with even row count, before\n    // calling batchMatMul->...->compileProgram and after that, the original\n    // xTexData.shape is restored.\n    const originalXTexDataShape = xTexData.shape;\n    xTexData.shape = xTexData.shape.slice();\n    xTexData.shape[xTexData.shape.length - 2]++;\n    util.assert(\n        webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape),\n        () => `packed reshape ${xTexData.shape} to ${\n            xReshaped.shape} isn't free`);\n    const filterReshaped = reshape({\n      inputs: {x: filter},\n      backend,\n      attrs: {shape: [1, convInfo.inChannels, convInfo.outChannels]}\n    });\n    intermediates.push(filterReshaped);\n    const pointwiseConv = batchMatMulImpl({\n      a: xReshaped,\n      b: filterReshaped,\n      backend,\n      transposeA,\n      transposeB,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n\n    const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);\n    util.assert(\n        pointwiseConvTexData.isPacked,\n        () => 'batchMatMul result is expected to be packed');\n    // Restore the input shape to original.\n    xTexData.shape = originalXTexDataShape;\n    // Set the output shape - there is no need for expensive reshape as data\n    // layout is already correct.\n    pointwiseConvTexData.shape = convInfo.outShape;\n\n    out = identity({inputs: {x: pointwiseConv}, backend});\n    out.shape = convInfo.outShape;\n\n    intermediates.push(pointwiseConv);\n  }\n\n  for (const i of intermediates) {\n    backend.disposeIntermediateTensorInfo(i);\n  }\n\n  return out;\n}\n\n// Implements the im2row algorithm as outlined in \"High Performance\n// Convolutional Neural Networks for Document Processing\" (Suvisoft, 2006)\nexport function conv2dWithIm2Row({\n  x,\n  filter,\n  convInfo,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: Conv2DConfig) {\n  // Rearranges conv2d input so each block to be convolved over forms the\n  // column of a new matrix with shape [filterWidth * filterHeight *\n  // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n  // output channel forms a row of a new matrix with shape [outChannels,\n  // filterWidth * filterHeight * inChannels]. The convolution is then\n  // computed by multiplying these matrices and reshaping the result.\n  const {\n    filterWidth,\n    filterHeight,\n    inChannels,\n    outWidth,\n    outHeight,\n    dataFormat\n  } = convInfo;\n\n  const isChannelsLast = dataFormat === 'channelsLast';\n\n  const sharedDim = filterWidth * filterHeight * inChannels;\n  const numCols = outHeight * outWidth;\n  const x2ColShape = [sharedDim, numCols];\n  const transposeA = true;\n  const transposeB = false;\n\n  const intermediates: TensorInfo[] = [];\n\n  const xSqueezed =\n      reshape({inputs: {x}, backend, attrs: {shape: x.shape.slice(1)}});\n  const w2Row = reshape({\n    inputs: {x: filter},\n    backend,\n    attrs: {shape: [1, sharedDim, util.sizeFromShape(filter.shape) / sharedDim]}\n  });\n\n  intermediates.push(xSqueezed);\n  intermediates.push(w2Row);\n\n  const im2ColProgram =\n      new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);\n  const im2Col = backend.runWebGLProgram(im2ColProgram, [xSqueezed], 'float32');\n  const im2ColReshaped = reshape({\n    inputs: {x: im2Col},\n    backend,\n    attrs: {shape: [1, x2ColShape[0], x2ColShape[1]]}\n  });\n\n  intermediates.push(im2Col);\n  intermediates.push(im2ColReshaped);\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n  const hasLeakyreluAlpha = activation === 'leakyrelu';\n  const fusedActivation =\n      activation ? mapActivationToShaderProgram(activation, true) : null;\n  const matmulProgram = new MatMulPackedProgram(\n      im2ColReshaped.shape as [number, number, number],\n      w2Row.shape as [number, number, number],\n      [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias,\n      fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n  const inputs: TensorInfo[] = [im2ColReshaped, w2Row];\n  if (bias) {\n    inputs.push(bias);\n  }\n  if (hasPreluActivationWeights) {\n    inputs.push(preluActivationWeights);\n  }\n  if (hasLeakyreluAlpha) {\n    const $leakyreluAlpha = backend.makeTensorInfo(\n        [], 'float32',\n        util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n    inputs.push($leakyreluAlpha);\n    intermediates.push($leakyreluAlpha);\n  }\n  const product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');\n\n  const outShape = isChannelsLast ?\n      [1, outHeight, outWidth, convInfo.outChannels] :\n      [1, convInfo.outChannels, outHeight, outWidth];\n  const out =\n      reshape({inputs: {x: product}, backend, attrs: {shape: outShape}});\n\n  intermediates.push(product);\n  for (const i of intermediates) {\n    backend.disposeIntermediateTensorInfo(i);\n  }\n\n  return out;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2D, Conv2DAttrs, Conv2DInputs, env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DProgram} from '../conv_gpu';\nimport {conv2dByMatMul, conv2dWithIm2Row} from './Conv2D_impl';\nimport {reshape} from './Reshape';\n\nexport function conv2d(\n    args:\n        {inputs: Conv2DInputs, attrs: Conv2DAttrs, backend: MathBackendWebGL}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dataFormat, dilations, dimRoundingMode} = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, dilations, pad,\n      dimRoundingMode, false /* depthwise */, $dataFormat);\n  let out: TensorInfo;\n\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n      convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n      convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n      (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n    out = conv2dByMatMul({x, filter, convInfo, backend});\n  } else if (env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n    out = conv2dWithIm2Row({x, filter, convInfo, backend});\n  } else {\n    const program = new Conv2DProgram(convInfo);\n    out = backend.runWebGLProgram(program, [x, filter], 'float32');\n  }\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: convInfo.outShape}});\n  backend.disposeIntermediateTensorInfo(out);\n\n  return outReshaped;\n}\n\nexport const conv2DConfig: KernelConfig = {\n  kernelName: Conv2D,\n  backendName: 'webgl',\n  kernelFunc: conv2d as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              if (${isChannelsLast}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n\n    this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padFront = filterDepth - 1 - convInfo.padInfo.front;\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2DBackpropFilter, Conv2DBackpropFilterAttrs, Conv2DBackpropFilterInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DDerFilterProgram} from '../conv_backprop_gpu';\n\nexport function conv2DBackpropFilter(args: {\n  inputs: Conv2DBackpropFilterInputs,\n  attrs: Conv2DBackpropFilterAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, dy} = inputs;\n  const {strides, pad, dataFormat, dimRoundingMode, filterShape} = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number], filterShape, strides,\n      1 /* dilations */, pad, dimRoundingMode, false /* depthwise */,\n      $dataFormat);\n\n  const program = new Conv2DDerFilterProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\n\nexport const conv2DBackpropFilterConfig: KernelConfig = {\n  kernelName: Conv2DBackpropFilter,\n  backendName: 'webgl',\n  kernelFunc: conv2DBackpropFilter as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2DBackpropInput, Conv2DBackpropInputAttrs, Conv2DBackpropInputInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DDerInputProgram} from '../conv_backprop_gpu';\n\nexport function conv2DBackpropInput(args: {\n  inputs: Conv2DBackpropInputInputs,\n  attrs: Conv2DBackpropInputAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {dy, filter} = inputs;\n  const {inputShape, strides, pad, dataFormat, dimRoundingMode} = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      inputShape, filter.shape as [number, number, number, number], strides,\n      1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n\n  const program = new Conv2DDerInputProgram(convInfo);\n  return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\n\nexport const conv2DBackpropInputConfig: KernelConfig = {\n  kernelName: Conv2DBackpropInput,\n  backendName: 'webgl',\n  kernelFunc: conv2DBackpropInput as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv3D, Conv3DAttrs, Conv3DInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv3DProgram} from '../conv_gpu';\n\nexport function conv3D(\n    args:\n        {inputs: Conv3DInputs, attrs: Conv3DAttrs, backend: MathBackendWebGL}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dilations} = attrs;\n\n  const convInfo = backend_util.computeConv3DInfo(\n      x.shape as [number, number, number, number, number],\n      filter.shape as [number, number, number, number, number], strides,\n      dilations, pad);\n\n  const program = new Conv3DProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, filter], 'float32');\n}\n\nexport const conv3DConfig: KernelConfig = {\n  kernelName: Conv3D,\n  backendName: 'webgl',\n  kernelFunc: conv3D as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv3DBackpropFilterV2, Conv3DBackpropFilterV2Attrs, Conv3DBackpropFilterV2Inputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv3DDerFilterProgram} from '../conv_backprop_gpu';\n\nexport function conv3DBackpropFilterV2(args: {\n  inputs: Conv3DBackpropFilterV2Inputs,\n  attrs: Conv3DBackpropFilterV2Attrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, dy} = inputs;\n  const {strides, pad, filterShape} = attrs;\n\n  const convInfo = backend_util.computeConv3DInfo(\n      x.shape as [number, number, number, number, number], filterShape, strides,\n      1 /* dilations */, pad);\n\n  const program = new Conv3DDerFilterProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\n\nexport const conv3DBackpropFilterV2Config: KernelConfig = {\n  kernelName: Conv3DBackpropFilterV2,\n  backendName: 'webgl',\n  kernelFunc: conv3DBackpropFilterV2 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv3DBackpropInputV2, Conv3DBackpropInputV2Attrs, Conv3DBackpropInputV2Inputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv3DDerInputProgram} from '../conv_backprop_gpu';\n\nexport function conv3DBackpropInput(args: {\n  inputs: Conv3DBackpropInputV2Inputs,\n  attrs: Conv3DBackpropInputV2Attrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {dy, filter} = inputs;\n  const {pad, strides, inputShape} = attrs;\n\n  const convInfo = backend_util.computeConv3DInfo(\n      inputShape, filter.shape as [number, number, number, number, number],\n      strides, 1 /* dilations */, pad);\n\n  const program = new Conv3DDerInputProgram(convInfo);\n  return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\n\nexport const conv3DBackpropInputConfig: KernelConfig = {\n  kernelName: Conv3DBackpropInputV2,\n  backendName: 'webgl',\n  kernelFunc: conv3DBackpropInput as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Cos, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst COS = CHECK_NAN_SNIPPET_UNARY + `\n  return cos(x);\n`;\n\nexport const cos = unaryKernelFunc({opSnippet: COS});\n\nexport const cosConfig: KernelConfig = {\n  kernelName: Cos,\n  backendName: 'webgl',\n  kernelFunc: cos,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Cosh, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst COSH = `\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\n\nexport const cosh = unaryKernelFunc({opSnippet: COSH});\n\nexport const coshConfig: KernelConfig = {\n  kernelName: Cosh,\n  backendName: 'webgl',\n  kernelFunc: cosh,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class CropAndResizeProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      imageShape: [number, number, number, number], boxShape: [number, number],\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number) {\n    const [batch, imageHeight, imageWidth, depth] = imageShape;\n    const [numBoxes, ] = boxShape;\n    const [cropHeight, cropWidth] = cropSize;\n    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n    const methodId = method === 'bilinear' ? 1 : 0;\n\n    const [inputHeightFloat, inputWidthFloat] =\n        [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n\n    const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n        [\n          `${(imageHeight - 1) / (cropHeight - 1)}`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n        [\n          `${(imageWidth - 1) / (cropWidth - 1)}`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {CropAndResize, CropAndResizeAttrs, CropAndResizeInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CropAndResizeProgram} from '../crop_and_resize_gpu';\n\nexport const cropAndResize = (args: {\n  inputs: CropAndResizeInputs,\n  backend: MathBackendWebGL,\n  attrs: CropAndResizeAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {image, boxes, boxInd} = inputs;\n  const {cropSize, method, extrapolationValue} = attrs;\n\n  const program = new CropAndResizeProgram(\n      image.shape as [number, number, number, number],\n      boxes.shape as [number, number], cropSize, method, extrapolationValue);\n  return backend.runWebGLProgram(program, [image, boxes, boxInd], 'float32');\n};\n\nexport const cropAndResizeConfig: KernelConfig = {\n  kernelName: CropAndResize,\n  backendName: 'webgl',\n  kernelFunc: cropAndResize as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class CumSumProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  index: WebGLUniformLocation;\n\n  constructor(shape: number[], exclusive: boolean, reverse: boolean) {\n    this.outputShape = shape;\n    const rank = shape.length;\n    const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n    const length = shape[shape.length - 1];\n    let condition = '';\n    let idxString = '';\n    // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = (reverse ? 'end + pow2' : 'end - pow2');\n    }\n\n    this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(index: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.index == null) {\n        this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n      }\n      gpgpu.gl.uniform1f(this.index, index);\n    };\n  }\n}\n\nfunction getCoords(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Cumsum, CumsumAttrs, CumsumInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CumSumProgram} from '../cumsum_gpu';\n\nimport {identity} from './Identity';\nimport {transpose} from './Transpose';\n\nexport function cumsum(\n    args:\n        {inputs: CumsumInputs, backend: MathBackendWebGL, attrs: CumsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, exclusive, reverse} = attrs;\n\n  const xRank = x.shape.length;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n  }\n  const permutedAxis = backend_util.getInnerMostAxes(1, xRank)[0];\n\n  if (permutedAxis !== xRank - 1) {\n    throw new Error(\n        `WebGL cumsum shader expects an inner-most axis=${\n            x.shape.length - 1} ` +\n        `but got axis=${axis}`);\n  }\n  const size = permutedX.shape[permutedAxis];\n  let result = identity({inputs: {x: permutedX}, backend});\n  // Use cumsum parallel algorithm, ref:\n  // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda\n\n  for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {\n    const program = new CumSumProgram(permutedX.shape, false, reverse);\n    const customSetup = program.getCustomSetupFunc(i);\n    const prevResult = result;\n    result =\n        backend.runWebGLProgram(program, [result], result.dtype, customSetup);\n    backend.disposeIntermediateTensorInfo(prevResult);\n  }\n  // For exclusive cumsum, shift the end result in the direction of sum\n  // and add 0 to the front index.\n  if (exclusive) {\n    const program = new CumSumProgram(permutedX.shape, exclusive, reverse);\n    const prevResult = result;\n    result = backend.runWebGLProgram(program, [result], result.dtype);\n    backend.disposeIntermediateTensorInfo(prevResult);\n  }\n\n  if (permutation != null) {\n    const reversePermutation = backend_util.getUndoAxesPermutation(permutation);\n    const reverseTransposedResult = transpose(\n        {inputs: {x: result}, backend, attrs: {perm: reversePermutation}});\n\n    backend.disposeIntermediateTensorInfo(result);\n    backend.disposeIntermediateTensorInfo(permutedX);\n\n    return reverseTransposedResult;\n  }\n\n  return result;\n}\n\nexport const cumsumConfig: KernelConfig = {\n  kernelName: Cumsum,\n  backendName: 'webgl',\n  kernelFunc: cumsum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DenseBincount, DenseBincountAttrs, DenseBincountInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {bincountImplCPU, bincountReduceImplCPU} from '../kernel_utils/shared';\n\nexport function denseBincount(args: {\n  inputs: DenseBincountInputs,\n  backend: MathBackendWebGL,\n  attrs: DenseBincountAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, weights} = inputs;\n  const {size, binaryOutput} = attrs;\n\n  if (x.shape.length === 1) {\n    const xVals = backend.readSync(x.dataId) as TypedArray;\n    const weightsVals = backend.readSync(weights.dataId) as TypedArray;\n\n    const outVals =\n        bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n\n    return backend.makeTensorInfo([size], weights.dtype, outVals);\n  } else if (x.shape.length === 2) {\n    const xBuf = backend.bufferSync(x);\n    const weightsBuf = backend.bufferSync(weights);\n\n    const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);\n\n    return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);\n  }\n\n  throw new Error(\n      `Error in denseBincount: input must be at most rank 2, but got rank` +\n      `${x.shape.length}.`);\n}\n\nexport const denseBincountConfig: KernelConfig = {\n  kernelName: DenseBincount,\n  backendName: 'webgl',\n  kernelFunc: denseBincount as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthToSpaceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  blockSize: number;\n  dataFormat: string;\n\n  constructor(\n      outputShape: number[], blockSize: number, dataFormat: 'NHWC'|'NCHW') {\n    this.outputShape = outputShape;\n    this.blockSize = blockSize;\n    this.dataFormat = dataFormat;\n    this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${blockSize};\n      int offset_h = imod(h, ${blockSize});\n      int in_w = w / ${blockSize};\n      int offset_w = imod(w, ${blockSize});\n      int offset_d = (offset_h * ${blockSize} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `;\n  }\n\n  private getHeightCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[1]`;\n    } else {\n      return `coords[2]`;\n    }\n  }\n\n  private getWidthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[2]`;\n    } else {\n      return `coords[3]`;\n    }\n  }\n\n  private getDepthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[3]`;\n    } else {\n      return `coords[1]`;\n    }\n  }\n\n  private getOutputDepthSize(): number {\n    if (this.dataFormat === 'NHWC') {\n      return this.outputShape[3];\n    } else {\n      return this.outputShape[1];\n    }\n  }\n\n  private getInputSamplingString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `getX(b, in_h, in_w, in_d)`;\n    } else {\n      return `getX(b, in_d, in_h, in_w)`;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DepthToSpace, DepthToSpaceAttrs, DepthToSpaceInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthToSpaceProgram} from '../depth_to_space_gpu';\n\nexport function depthToSpace(args: {\n  inputs: DepthToSpaceInputs,\n  backend: MathBackendWebGL,\n  attrs: DepthToSpaceAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockSize, dataFormat} = attrs;\n\n  util.assert(\n      blockSize > 1,\n      () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n\n  const batchSize = x.shape[0];\n  const inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];\n  const inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];\n  const inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];\n\n  const outputHeight = inputHeight * blockSize;\n  const outputWidth = inputWidth * blockSize;\n  const outputDepth = inputDepth / (blockSize * blockSize);\n\n  const outputShape = (dataFormat === 'NHWC') ?\n      [batchSize, outputHeight, outputWidth, outputDepth] :\n      [batchSize, outputDepth, outputHeight, outputWidth];\n\n  const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const depthToSpaceConfig: KernelConfig = {\n  kernelName: DepthToSpace,\n  backendName: 'webgl',\n  kernelFunc: depthToSpace as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false,\n      hasLeakyReluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyReluAlpha) {\n        activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    if (hasLeakyReluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${xNumRows}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${xNumCols}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConvPacked2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false,\n      hasLeakyReluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const texelsAcross = filterWidth;\n\n    let mainLoop = `\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;\n\n    for (let c = 0; c < filterWidth; c++) {\n      mainLoop += `\n          vec4 xTexelC${c * 2};\n          int xTexelC${c * 2}Ready;\n          vec4 xC${c};`;\n    }\n\n    /**\n     * This vectorized implementation works by gathering the values needed for\n     * each output channel's dot product into vec4's and then multiplying them\n     * all together (this happens in the final double for-loop below). Most of\n     * the main loop consists of constructing these vec4's with the minimum\n     * number of texture2D calls, which means making use of all four returned\n     * values from a texture2D call at once.\n     */\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `\n          xTexelC${c * 2} = vec4(0.0);\n          xTexelC${c * 2}Ready = 0;\n          xC${c} = vec4(0.0);`;\n      }\n      mainLoop += `\n        xR = xRCorner + ${r * dilationHeight};\n        if (xR >=0 && xR < ${xNumRows}) {\n      `;\n\n      for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n        const colIndex = texelC * 2;\n        const c = colIndex * dilationWidth;\n\n        mainLoop += `\n          xC = xCCorner + ${c};\n          `;\n\n        if (strideWidth === 1) {\n          if (colIndex < filterWidth) {\n            // If padding is odd, the outer texels have to be composed.\n            if (padLeft % 2 === 1) {\n              // TODO: Ensure vec4 previous does not result in redundant sample,\n              // and avoid setting xTexelRC's that exceed the boundary in the\n              // first place rather than resetting them to vec4(0)).\n\n              // To compute xCOffset:\n              // - If padding is odd, we must add 1 to ensure we ask for an\n              // even-numbered row.\n              // - We subtract 2 to access the previous texel.\n\n              mainLoop += `\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${\n                  c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n              `;\n              // This texel has been read in previous iteration if the dilation\n              // is 1.\n              if (dilationWidth === 1 && c > 0) {\n                mainLoop += `\n                xC${colIndex} = vec4(xTexelC${c - 2}.zw, xTexelC${c}.xy);\n                `;\n              } else {\n                mainLoop += `\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${xNumCols}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${colIndex} = vec4(previous.zw, xTexelC${c}.xy);\n                  } else {\n                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${c}.xy);\n                  }\n                  `;\n              }\n            } else {\n              // Padding is even, so xRC corresponds to a single texel.\n              mainLoop += `\n                if (xC >= 0 && xC < ${xNumCols} && xTexelC${c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n\n                xC${colIndex} = xTexelC${c};\n                `;\n            }\n\n            if (c + 1 < filterWidth) {\n              // If dilation is even, the second entry should match the first\n              // (either both are composed or both are single samples). But if\n              // dilation is odd, then the second entry should be the opposite\n              // of the first (if the first is composed, the second is a single\n              // sample, and vice versa.)\n\n              const nextTexelOffset = padLeft % 2 === 0 ?\n                  util.nearestLargerEven(dilationWidth) :\n                  dilationWidth;\n\n              if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                  (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${\n                    c + 2}Ready == 0) {\n                    xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${xNumCols}) {\n                      xTexelC${c + 2}.zw = vec2(0.0);\n                    }\n                    xTexelC${c + 2}Ready = 1;\n                  }\n                  `;\n\n                // If dilation > 1 then the xRC's will not be able to share any\n                // values, so each xRC will require two unique calls to getX.\n                if (dilationWidth > 1) {\n                  mainLoop += `\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${\n                      c}Ready == 0) {\n                      xTexelC${c} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${c}Ready = 1;\n                    }\n                    `;\n                }\n\n                mainLoop += `\n                  xC${colIndex + 1} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.xy);\n                  `;\n              } else {\n                // If dilation is 1 and padding is odd, we have already read the\n                // texel when constructing the previous x value. Here we can\n                // simply skip the texture read.\n                if (nextTexelOffset === 1) {\n                  mainLoop += `\n                    xC${colIndex + 1} = xTexelC${c};\n                    `;\n                } else {\n                  mainLoop += `\n                    xCOffset = xC + ${nextTexelOffset};\n\n                    if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${\n                      c + 2}Ready == 0) {\n                      xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${xNumCols}) {\n                        xTexelC${c + 2}.zw = vec2(0.0);\n                      }\n                      xTexelC${c + 2}Ready = 1;\n                    }\n\n                    xC${colIndex + 1} = xTexelC${c + 2};\n                    `;\n                }\n              }\n            }\n          }\n        } else {  // stride === 2\n          if (c < filterWidth) {\n            // Depending on whether padLeft is even or odd, we want either the\n            // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n            // even, xC${colIndex +1} is simply the zw channels of texels we've\n            // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n            // need to come from the xy channels of a new texel, hence the `\n            // vec4\n            // final` initialized below.\n            if (padLeft % 2 === 1) {\n              mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${\n                  c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols} && xTexelC${\n                  c + 2}Ready == 0) {\n                  xTexelC${c + 2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${xNumCols}) {\n                    xTexelC${c + 2}.zw = vec2(0.0);\n                  }\n                  xTexelC${c + 2}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.zw);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${colIndex + 1} = vec4(xTexelC${c + 2}.xy, final.xy);\n                `;\n              }\n            } else {\n              mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols} && xTexelC${c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${\n                  c + 2}Ready == 0) {\n                  xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${xNumCols}) {\n                    xTexelC${c + 2}.zw = vec2(0.);\n                  }\n                  xTexelC${c + 2}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(\n                  xTexelC${c}.xy, xTexelC${c + 2}.xy);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  xC${colIndex + 1} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.zw);\n                `;\n              }\n            }\n          }\n        }\n\n        // localize the dotProd accumulation within the loop, the theory is for\n        // GPU with limited cache, accumulate sum across large amount of\n        // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n        // 50 variables)\n        if (colIndex < filterWidth) {\n          mainLoop += `\n            wTexel = getW(${r}, ${c}, d1, q);\n            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);\n          `;\n\n          if (c + 1 < filterWidth) {\n            mainLoop += `\n              wTexel = getW(${r}, ${c + 1}, d1, q);\n              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);\n            `;\n          }\n        }\n      }\n      mainLoop += `\n        }\n      `;\n    }\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyReluAlpha) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    if (hasLeakyReluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${mainLoop}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DepthwiseConv2dNative, DepthwiseConv2dNativeAttrs, DepthwiseConv2dNativeInputs, env, KernelConfig, KernelFunc, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DProgram} from '../conv_gpu_depthwise';\nimport {DepthwiseConvPacked2DProgram} from '../conv_packed_gpu_depthwise';\n\nexport function depthwiseConv2dNative(args: {\n  inputs: DepthwiseConv2dNativeInputs,\n  attrs: DepthwiseConv2dNativeAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dilations, dimRoundingMode} = attrs;\n\n  let $dilations = dilations;\n  if ($dilations == null) {\n    $dilations = [1, 1];\n  }\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, $dilations),\n      () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n          `1. Got strides ${strides} and dilations '${$dilations}'`);\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, $dilations,\n      pad, dimRoundingMode, true /* depthwise */);\n\n  let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n  if (env().getBool('WEBGL_PACK_DEPTHWISECONV') && convInfo.strideWidth <= 2 &&\n      convInfo.outChannels / convInfo.inChannels === 1) {\n    program = new DepthwiseConvPacked2DProgram(convInfo);\n  } else {\n    program = new DepthwiseConv2DProgram(convInfo);\n  }\n\n  return backend.runWebGLProgram(program, [x, filter], 'float32');\n}\n\nexport const depthwiseConv2dNativeConfig: KernelConfig = {\n  kernelName: DepthwiseConv2dNative,\n  backendName: 'webgl',\n  kernelFunc: depthwiseConv2dNative as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class DepthwiseConv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DepthwiseConv2dNativeBackpropFilter, DepthwiseConv2dNativeBackpropFilterAttrs, DepthwiseConv2dNativeBackpropFilterInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DDerFilterProgram} from '../conv_backprop_gpu_depthwise';\n\nexport function depthwiseConv2dNativeBackpropFilter(args: {\n  inputs: DepthwiseConv2dNativeBackpropFilterInputs,\n  attrs: DepthwiseConv2dNativeBackpropFilterAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, dy} = inputs;\n  const {strides, dilations, pad, dimRoundingMode, filterShape} = attrs;\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number], filterShape, strides,\n      dilations, pad, dimRoundingMode, true /* depthwise */);\n\n  const program = new DepthwiseConv2DDerFilterProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\n\nexport const depthwiseConv2dNativeBackpropFilterConfig: KernelConfig = {\n  kernelName: DepthwiseConv2dNativeBackpropFilter,\n  backendName: 'webgl',\n  kernelFunc: depthwiseConv2dNativeBackpropFilter as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DepthwiseConv2dNativeBackpropInput, DepthwiseConv2dNativeBackpropInputAttrs, DepthwiseConv2dNativeBackpropInputInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DDerInputProgram} from '../conv_backprop_gpu_depthwise';\n\nexport function depthwiseConv2dNativeBackpropInput(args: {\n  inputs: DepthwiseConv2dNativeBackpropInputInputs,\n  attrs: DepthwiseConv2dNativeBackpropInputAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {dy, filter} = inputs;\n  const {strides, dilations, pad, dimRoundingMode, inputShape} = attrs;\n\n  const convInfo = backend_util.computeConv2DInfo(\n      inputShape, filter.shape as [number, number, number, number], strides,\n      dilations, pad, dimRoundingMode, true /* depthwise */);\n\n  const program = new DepthwiseConv2DDerInputProgram(convInfo);\n  return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\n\nexport const depthwiseConv2dNativeBackpropInputConfig: KernelConfig = {\n  kernelName: DepthwiseConv2dNativeBackpropInput,\n  backendName: 'webgl',\n  kernelFunc: depthwiseConv2dNativeBackpropInput as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DiagProgram implements GPGPUProgram {\n  variableNames = ['X'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(size: number) {\n    this.outputShape = [size, size];\n    this.userCode = `\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Diag, DiagInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DiagProgram} from '../diag_gpu';\nimport {reshape} from './Reshape';\n\nexport function diag(args: {inputs: DiagInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  const outShape = [...x.shape, ...x.shape];\n  const xSize = util.sizeFromShape(x.shape);\n\n  const flat = reshape({inputs: {x}, backend, attrs: {shape: [xSize]}});\n\n  const program = new DiagProgram(xSize);\n  const res = backend.runWebGLProgram(program, [flat], flat.dtype);\n\n  const out = reshape({inputs: {x: res}, backend, attrs: {shape: outShape}});\n\n  backend.disposeIntermediateTensorInfo(flat);\n  backend.disposeIntermediateTensorInfo(res);\n\n  return out;\n}\n\nexport const diagConfig: KernelConfig = {\n  kernelName: Diag,\n  backendName: 'webgl',\n  kernelFunc: diag as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Dilation2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.outShape;\n\n    const {\n      inHeight,\n      inWidth,\n      padInfo,\n      strideHeight,\n      strideWidth,\n      filterHeight,\n      filterWidth,\n      dilationHeight,\n      dilationWidth\n    } = convInfo;\n\n    const {top: padTop, left: padLeft} = padInfo;\n\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${filterHeight}; h++) {\n          int hIn = hBeg + h * ${dilationHeight};\n\n          if (hIn >= 0 && hIn < ${inHeight}) {\n            for (int w = 0; w < ${filterWidth}; w++) {\n              int wIn = wBeg + w * ${dilationWidth};\n\n              if (wIn >= 0 && wIn < ${inWidth}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Dilation2D, Dilation2DAttrs, Dilation2DInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Dilation2DProgram} from '../dilation_gpu';\nimport {reshape} from './Reshape';\n\nexport function dilation2D(args: {\n  inputs: Dilation2DInputs,\n  attrs: Dilation2DAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dilations} = attrs;\n\n  const convInfo = backend_util.computeDilation2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number], strides, pad,\n      'NHWC' /* dataFormat */, dilations);\n  let out: TensorInfo;\n\n  const program = new Dilation2DProgram(convInfo);\n  out = backend.runWebGLProgram(program, [x, filter], 'float32');\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: convInfo.outShape}});\n  backend.disposeIntermediateTensorInfo(out);\n\n  return outReshaped;\n}\n\nexport const dilation2DConfig: KernelConfig = {\n  kernelName: Dilation2D,\n  backendName: 'webgl',\n  kernelFunc: dilation2D as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Einsum, EinsumAttrs, EinsumInputs, KernelConfig, KernelFunc, Tensor, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {multiply} from './Multiply';\nimport {reshape} from './Reshape';\nimport {sum} from './Sum';\nimport {transpose} from './Transpose';\n\nexport function einsum(\n    args:\n        {inputs: EinsumInputs, backend: MathBackendWebGL, attrs: EinsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {equation} = attrs;\n  const tensors = inputs as Tensor[];\n\n  const {allDims, summedDims, idDims} =\n      backend_util.decodeEinsumEquation(equation, tensors.length);\n  backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);\n  const {path, steps} = backend_util.getEinsumComputePath(summedDims, idDims);\n\n  const nSteps = steps.length;\n  let out: TensorInfo|null = null;\n  let numDimsRemaining = allDims.length;\n  const tensorsToDispose: TensorInfo[] = [];\n  for (let i = 0; i < nSteps; ++i) {\n    for (const idTerm of steps[i]) {\n      const {permutationIndices: perm, expandDims: dimsToExpand} =\n          backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);\n      let x: TensorInfo;\n      if (backend_util.isIdentityPermutation(perm)) {\n        x = tensors[idTerm];\n      } else {\n        x = transpose({inputs: {x: tensors[idTerm]}, backend, attrs: {perm}});\n        tensorsToDispose.push(x);\n      }\n      const targetShape: number[] = x.shape.slice();\n      for (let k = 0; k < dimsToExpand.length; ++k) {\n        targetShape.splice(dimsToExpand[k], 0, 1);\n      }\n\n      if (!util.arraysEqual(x.shape, targetShape)) {\n        x = reshape({inputs: {x}, backend, attrs: {shape: targetShape}});\n        tensorsToDispose.push(x);\n      }\n      if (out === null) {\n        out = x;\n      } else {\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        out = multiply({inputs: {a: x, b: out}, backend}) as TensorInfo;\n        tensorsToDispose.push(out);\n      }\n    }\n    if (i < nSteps - 1) {\n      if (path[i] >= 0) {\n        out = sum({\n          inputs: {x: out},\n          backend,\n          attrs: {\n            axis: path[i] - (allDims.length - numDimsRemaining),\n            keepDims: false\n          }\n        });\n        tensorsToDispose.push(out);\n      }\n      numDimsRemaining--;\n    }\n  }\n\n  // Clean up intermediate tensors.\n  for (const tensorInfo of tensorsToDispose) {\n    if (tensorInfo === out) {\n      continue;\n    }\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n\n  return out;\n}\n\nexport const einsumConfig: KernelConfig = {\n  kernelName: Einsum,\n  backendName: 'webgl',\n  kernelFunc: einsum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Elu, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\n\nconst ELU_PACKED = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\n\nconst elu = unaryKernelFunc({opSnippet: ELU, packedOpSnippet: ELU_PACKED});\n\nexport const eluConfig: KernelConfig = {\n  kernelName: Elu,\n  backendName: 'webgl',\n  kernelFunc: elu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {EluGrad, EluGradInputs, env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nconst ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\nconst ELU_DER_PACKED = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\n\nexport const eluGrad =\n    (args: {inputs: EluGradInputs, backend: MathBackendWebGL}): TensorInfo => {\n      const {inputs, backend} = args;\n      const {dy, y} = inputs;\n\n      const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n          new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) :\n          new BinaryOpProgram(ELU_DER, dy.shape, y.shape);\n      return backend.runWebGLProgram(program, [dy, y], dy.dtype);\n    };\n\nexport const eluGradConfig: KernelConfig = {\n  kernelName: EluGrad,\n  backendName: 'webgl',\n  kernelFunc: eluGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Equal, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst PACKED_EQUAL = `\n  return vec4(equal(a, b));\n`;\n\nconst EQUAL = `return float(a == b);`;\n\nexport const equal = binaryKernelFunc(\n    {opSnippet: EQUAL, packedOpSnippet: PACKED_EQUAL, dtype: 'bool'});\n\nexport const equalConfig: KernelConfig = {\n  kernelName: Equal,\n  backendName: 'webgl',\n  kernelFunc: equal as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Erf, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${backend_util.ERF_P};\n  float a1 = ${backend_util.ERF_A1};\n  float a2 = ${backend_util.ERF_A2};\n  float a3 = ${backend_util.ERF_A3};\n  float a4 = ${backend_util.ERF_A4};\n  float a5 = ${backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;\n\nexport const erf = unaryKernelFunc({opSnippet: ERF});\n\nexport const erfConfig: KernelConfig = {\n  kernelName: Erf,\n  backendName: 'webgl',\n  kernelFunc: erf,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Exp, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {expImplCPU} from '../kernel_utils/shared';\n\nexport const EXP = `return exp(x);`;\nexport const exp = unaryKernelFunc(\n    {opSnippet: EXP, packedOpSnippet: EXP, cpuKernelImpl: expImplCPU});\n\nexport const expConfig: KernelConfig = {\n  kernelName: Exp,\n  backendName: 'webgl',\n  kernelFunc: exp as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ExpandDims, ExpandDimsAttrs, ExpandDimsInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reshape} from './Reshape';\n\nexport function expandDims(args: {\n  inputs: ExpandDimsInputs,\n  attrs: ExpandDimsAttrs,\n  backend: MathBackendWebGL\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {dim} = attrs;\n  const {input} = inputs;\n\n  const inputRank = input.shape.length;\n  const newShape = input.shape.slice();\n  let $dim = dim;\n  if (dim < 0) {\n    // Negative value is counted from the tail of rank.\n    util.assert(\n        -(inputRank + 1) <= dim,\n        () => `Axis must be in the interval [${- (inputRank + 1)}, ${\n            inputRank}]`);\n    $dim = inputRank + dim + 1;\n  }\n  newShape.splice($dim, 0, 1);\n\n  return reshape({inputs: {x: input}, backend, attrs: {shape: newShape}});\n}\n\nexport const expandDimsConfig: KernelConfig = {\n  kernelName: ExpandDims,\n  backendName: 'webgl',\n  kernelFunc: expandDims as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Expm1, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {expm1ImplCPU} from '../kernel_utils/shared';\n\nconst EXPM1 = `return exp(x) - 1.0;`;\n\nexport const expm1 = unaryKernelFunc(\n    {opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU});\n\nexport const expm1Config: KernelConfig = {\n  kernelName: Expm1,\n  backendName: 'webgl',\n  kernelFunc: expm1 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FFTProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      component: 'real'|'imag', inputShape: [number, number],\n      inverse: boolean) {\n    const innerDim = inputShape[1];\n    this.outputShape = inputShape;\n\n    const exponentMultiplierSnippet =\n        inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n    const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n\n    let opString: string;\n    if (component === 'real') {\n      opString = 'return real * expR - imag * expI;';\n    } else if (component === 'imag') {\n      opString = 'return real * expI + imag * expR;';\n    } else {\n      throw new Error(\n          `FFT component must be either \"real\" or \"imag\", got ${component}.`);\n    }\n\n    this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${opString}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FFTProgram} from '../fft_gpu';\n\nimport {complex} from './Complex';\nimport {reshape} from './Reshape';\n\nexport function fftImpl(\n    x: TensorInfo, inverse: boolean, backend: MathBackendWebGL): TensorInfo {\n  const xData = backend.texData.get(x.dataId);\n\n  const inputSize = util.sizeFromShape(x.shape);\n  // Collapse all outer dimensions to a single batch dimension.\n  const innerDimensionSize = x.shape[x.shape.length - 1];\n  const batch = inputSize / innerDimensionSize;\n\n  const input2D = reshape(\n      {inputs: {x}, backend, attrs: {shape: [batch, innerDimensionSize]}});\n\n  const xShape = input2D.shape as [number, number];\n  const realProgram = new FFTProgram('real', xShape, inverse);\n  const imagProgram = new FFTProgram('imag', xShape, inverse);\n\n  const inputs = [\n    {\n      dataId: xData.complexTensorInfos.real.dataId,\n      dtype: xData.complexTensorInfos.real.dtype,\n      shape: xShape\n    },\n    {\n      dataId: xData.complexTensorInfos.imag.dataId,\n      dtype: xData.complexTensorInfos.imag.dtype,\n      shape: xShape\n    }\n  ];\n\n  const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n  const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n\n  const complexOutput =\n      complex({inputs: {real: realPart, imag: imagPart}, backend});\n\n  backend.disposeIntermediateTensorInfo(realPart);\n  backend.disposeIntermediateTensorInfo(imagPart);\n\n  const complexOutputReshaped =\n      reshape({inputs: {x: complexOutput}, backend, attrs: {shape: x.shape}});\n\n  backend.disposeIntermediateTensorInfo(input2D);\n  backend.disposeIntermediateTensorInfo(complexOutput);\n  return complexOutputReshaped;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FFT, FFTInputs, KernelConfig, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {fftImpl} from './FFT_impl';\n\nexport function fft(args: {inputs: FFTInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  return fftImpl(input, false /* inverse */, backend);\n}\n\nexport const fftConfig: KernelConfig = {\n  kernelName: FFT,\n  backendName: 'webgl',\n  kernelFunc: fft\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FillProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  valueLoc: WebGLUniformLocation;\n\n  constructor(shape: number[], value: number) {\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n\n    this.userCode = `\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(value: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.valueLoc == null) {\n        this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n      }\n      gpgpu.gl.uniform1f(this.valueLoc, value);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Fill, FillAttrs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FillProgram} from '../fill_gpu';\n\nexport function fill(args: {backend: MathBackendWebGL, attrs: FillAttrs}):\n    TensorInfo {\n  const {backend, attrs} = args;\n  const {shape, value} = attrs;\n  let {dtype} = attrs;\n\n  dtype = dtype || util.inferDtype(value);\n\n  if (dtype === 'string') {\n    // String type should be handled in CPU memory.\n    const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n    values.fill(value as string);\n    return backend.makeTensorInfo(shape, dtype, values);\n  } else {\n    const program = new FillProgram(shape, value as number);\n    const customSetup = program.getCustomSetupFunc(value as number);\n    return backend.runWebGLProgram(program, [], dtype, customSetup);\n  }\n}\n\nexport const fillConfig: KernelConfig = {\n  kernelName: Fill,\n  backendName: 'webgl',\n  kernelFunc: fill as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {TextureUsage} from '../tex_util';\n\nimport {FromPixelsProgram} from './FromPixels_utils/from_pixels_gpu';\nimport {FromPixelsPackedProgram} from './FromPixels_utils/from_pixels_packed_gpu';\n\nexport const fromPixelsConfig: KernelConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgl',\n  kernelFunc: fromPixels as {} as KernelFunc,\n};\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\n\nfunction fromPixels(args: {\n  inputs: FromPixelsInputs,\n  backend: MathBackendWebGL,\n  attrs: FromPixelsAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  let {pixels} = inputs;\n  const {numChannels} = attrs;\n\n  const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement;\n  const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement;\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n\n  const texShape: [number, number] = [height, width];\n  const outShape = [height, width, numChannels];\n\n  if (isImage || isVideo) {\n    if (fromPixels2DContext == null) {\n      fromPixels2DContext = document.createElement('canvas').getContext('2d');\n    }\n\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(\n        pixels as HTMLVideoElement | HTMLImageElement | ImageBitmap,\n        0, 0, width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n\n  const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n  // This is a byte texture with pixels.\n  backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n  backend.gpgpu.uploadPixelDataToTexture(\n      backend.getTexture(tempPixelHandle.dataId), pixels as ImageData);\n  const program = env().getBool('WEBGL_PACK') ?\n      new FromPixelsPackedProgram(outShape) :\n      new FromPixelsProgram(outShape);\n  const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n  backend.disposeData(tempPixelHandle.dataId);\n  return res;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FlipLeftRightProgram implements GPGPUProgram {\n  variableNames = ['Image'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(imageShape: [number, number, number, number]) {\n    const imageWidth = imageShape[2];\n    this.outputShape = imageShape;\n\n    this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${imageWidth} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${imageWidth}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tensor4D} from '@tensorflow/tfjs-core';\nimport {FlipLeftRight, FlipLeftRightInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FlipLeftRightProgram} from '../flip_left_right_gpu';\n\nexport const flipLeftRightConfig: KernelConfig = {\n  kernelName: FlipLeftRight,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend}) => {\n    const {image} = inputs as FlipLeftRightInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const program = new FlipLeftRightProgram((image as Tensor4D).shape);\n    const output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n    return output;\n  }\n};\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Floor, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {floorImplCPU} from '../kernel_utils/shared';\n\nconst FLOOR = `return floor(x);`;\n\nexport const floor = unaryKernelFunc(\n    {opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU});\n\nexport const floorConfig: KernelConfig = {\n  kernelName: Floor,\n  backendName: 'webgl',\n  kernelFunc: floor,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FloorDiv, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\n// We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\nconst INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;\n\nconst INT_DIV_PACKED = `\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;\n\nexport const floorDiv = binaryKernelFunc(\n    {opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: 'int32'});\n\nexport const floorDivConfig: KernelConfig = {\n  kernelName: FloorDiv,\n  backendName: 'webgl',\n  kernelFunc: floorDiv as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);\n\n        vec4 values = ${glsl.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${width}.0, ${height}.0);\n            vec4 values = ${glsl.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, FusedConv2D, FusedConv2DAttrs, FusedConv2DInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DProgram} from '../conv_gpu';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\n\nimport {conv2dByMatMul, conv2dWithIm2Row} from './Conv2D_impl';\nimport {reshape} from './Reshape';\n\nexport function fusedConv2d(args: {\n  inputs: FusedConv2DInputs,\n  attrs: FusedConv2DAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter, bias, preluActivationWeights} = inputs;\n  const {\n    strides,\n    pad,\n    dataFormat,\n    dilations,\n    dimRoundingMode,\n    activation,\n    leakyreluAlpha\n  } = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, dilations, pad,\n      dimRoundingMode, false /* depthwise */, $dataFormat);\n  let out: TensorInfo;\n  const intermediates: TensorInfo[] = [];\n\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n      convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n      convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n      (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n    out = conv2dByMatMul({\n      x,\n      filter,\n      convInfo,\n      backend,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n  } else if (env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n    out = conv2dWithIm2Row({\n      x,\n      filter,\n      convInfo,\n      backend,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n  } else {\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const hasLeakyreluAlpha = activation === 'leakyrelu';\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, false) : null;\n    const program = new Conv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n    const inputs: TensorInfo[] = [x, filter];\n    if (bias) {\n      inputs.push(bias);\n    }\n    if (preluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    if (hasLeakyreluAlpha) {\n      const $leakyreluAlpha = backend.makeTensorInfo(\n          [], 'float32',\n          util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n      inputs.push($leakyreluAlpha);\n      intermediates.push($leakyreluAlpha);\n    }\n    out = backend.runWebGLProgram(program, inputs, 'float32');\n  }\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: convInfo.outShape}});\n\n  intermediates.push(out);\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return outReshaped;\n}\n\nexport const fusedConv2DConfig: KernelConfig = {\n  kernelName: FusedConv2D,\n  backendName: 'webgl',\n  kernelFunc: fusedConv2d as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, FusedDepthwiseConv2D, FusedDepthwiseConv2DAttrs, FusedDepthwiseConv2DInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DProgram} from '../conv_gpu_depthwise';\nimport {DepthwiseConvPacked2DProgram} from '../conv_packed_gpu_depthwise';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\n\nexport function fusedDepthwiseConv2D(args: {\n  inputs: FusedDepthwiseConv2DInputs,\n  attrs: FusedDepthwiseConv2DAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter, bias, preluActivationWeights} = inputs;\n  const {strides, pad, dilations, dimRoundingMode, activation, leakyreluAlpha} =\n      attrs;\n\n  const intermediates: TensorInfo[] = [];\n\n  let $dilations = dilations;\n  if ($dilations == null) {\n    $dilations = [1, 1];\n  }\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, $dilations),\n      () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n          `1. Got strides ${strides} and dilations '${$dilations}'`);\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, $dilations,\n      pad, dimRoundingMode, true /* depthwise */);\n\n  const shouldPackDepthwiseConv = env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n      convInfo.strideWidth <= 2 &&\n      convInfo.outChannels / convInfo.inChannels === 1;\n  const fusedActivation = activation ?\n      mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) :\n      null;\n  const programInputs: TensorInfo[] = [x, filter];\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n  const hasLeakyreluAlpha = activation === 'leakyrelu';\n\n  if (hasBias) {\n    programInputs.push(bias);\n  }\n  if (hasPreluActivationWeights) {\n    programInputs.push(preluActivationWeights);\n  }\n  if (hasLeakyreluAlpha) {\n    const $leakyreluAlpha = backend.makeTensorInfo(\n        [], 'float32',\n        util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n    programInputs.push($leakyreluAlpha);\n    intermediates.push($leakyreluAlpha);\n  }\n\n  let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n  if (shouldPackDepthwiseConv) {\n    program = new DepthwiseConvPacked2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n  } else {\n    program = new DepthwiseConv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n  }\n\n  const result = backend.runWebGLProgram(program, programInputs, 'float32');\n\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return result;\n}\n\nexport const fusedDepthwiseConv2DConfig: KernelConfig = {\n  kernelName: FusedDepthwiseConv2D,\n  backendName: 'webgl',\n  kernelFunc: fusedDepthwiseConv2D as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class GatherNDProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  constructor(\n      private sliceDim: number, private strides: number[], shape: number[]) {\n    this.outputShape = shape;\n    const stridesType = getCoordsDataType(strides.length);\n    const dtype = getCoordsDataType(shape.length);\n    const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';\n    this.userCode = `\n        ${stridesType} strides = ${stridesType}(${this.strides});\n         void main() {\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${strideString};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, GatherNd, GatherNdInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {GatherNDProgram} from '../gather_nd_gpu';\nimport {reshape} from './Reshape';\n\nexport function gatherNd(\n    args: {inputs: GatherNdInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {params, indices} = inputs;\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n\n  const [resultShape, numSlices, sliceSize, strides] =\n      backend_util.prepareAndValidate(params, indices);\n\n  const flattenIndices = reshape(\n      {inputs: {x: indices}, backend, attrs: {shape: [numSlices, sliceRank]}});\n  const flattenX = reshape({\n    inputs: {x: params},\n    backend,\n    attrs: {shape: [(util.sizeFromShape(params.shape) / sliceSize), sliceSize]}\n  });\n\n  const program =\n      new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);\n  const res = backend.runWebGLProgram(\n      program, [flattenX, flattenIndices], flattenX.dtype);\n\n  const reshaped =\n      reshape({inputs: {x: res}, backend, attrs: {shape: resultShape}});\n\n  backend.disposeIntermediateTensorInfo(flattenIndices);\n  backend.disposeIntermediateTensorInfo(flattenX);\n  backend.disposeIntermediateTensorInfo(res);\n\n  return reshaped;\n}\n\nexport const gatherNdConfig: KernelConfig = {\n  kernelName: GatherNd,\n  backendName: 'webgl',\n  kernelFunc: gatherNd as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class GatherProgram implements GPGPUProgram {\n  variableNames = ['A', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], outputShape: number[]) {\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape, 2);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\n// The input and output are always flattened into rank 4 tensors.\nfunction getSourceCoords(aShape: number[], axis: number): string {\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    if (i === 2) {\n      sourceCoords.push('int(getIndices(resRC.x, resRC.z))');\n    } else {\n      sourceCoords.push(`${currentCoords[i]}`);\n    }\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, GatherV2, GatherV2Attrs, GatherV2Inputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {GatherProgram} from '../gather_gpu';\nimport {gatherV2ImplCPU} from '../kernel_utils/shared';\n\nimport {reshape} from './Reshape';\n\nexport function gatherV2(args: {\n  inputs: GatherV2Inputs,\n  backend: MathBackendWebGL,\n  attrs: GatherV2Attrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, indices} = inputs;\n  const {axis, batchDims} = attrs;\n\n  const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(\n      x, indices, parsedAxis, batchDims);\n\n  const indicesSize = util.sizeFromShape(indices.shape);\n\n  const toDispose = [];\n\n  const flattenX = reshape({\n    inputs: {x},\n    backend,\n    attrs: {\n      shape: [\n        shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n        shapeInfo.sliceSize\n      ]\n    }\n  });\n\n  const flattenIndex = reshape({\n    inputs: {x: indices},\n    backend,\n    attrs: {shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]}\n  });\n\n  toDispose.push(flattenX);\n  toDispose.push(flattenIndex);\n\n  const flattenOutputShape = [\n    shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n    shapeInfo.sliceSize\n  ];\n\n  if (backend.shouldExecuteOnCPU([x, indices]) || x.dtype === 'string') {\n    const indicesBuf = backend.bufferSync(flattenIndex);\n    const xBuf = backend.bufferSync(flattenX);\n    const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);\n\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n    return backend.makeTensorInfo(\n        shapeInfo.outputShape, outBuf.dtype, outBuf.values as TypedArray);\n  }\n\n  const program = new GatherProgram(flattenX.shape, flattenOutputShape);\n  const res = backend.runWebGLProgram(\n      program, [flattenX, flattenIndex], flattenX.dtype);\n  toDispose.push(res);\n\n  const reshaped = reshape(\n      {inputs: {x: res}, backend, attrs: {shape: shapeInfo.outputShape}});\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return reshaped;\n}\n\nexport const gatherV2Config: KernelConfig = {\n  kernelName: GatherV2,\n  backendName: 'webgl',\n  kernelFunc: gatherV2 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Greater, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {greaterImplCPU} from '../kernel_utils/shared';\n\nconst GREATER = `return float(a > b);`;\nconst GREATER_PACKED = `\n  return vec4(greaterThan(a, b));\n`;\n\nexport const greater = binaryKernelFunc({\n  opSnippet: GREATER,\n  packedOpSnippet: GREATER_PACKED,\n  cpuKernelImpl: greaterImplCPU,\n  dtype: 'bool'\n});\n\nexport const greaterConfig: KernelConfig = {\n  kernelName: Greater,\n  backendName: 'webgl',\n  kernelFunc: greater as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GreaterEqual, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst GREATER_EQUAL = `return float(a >= b);`;\nconst GREATER_EQUAL_PACKED = `\n  return vec4(greaterThanEqual(a, b));\n`;\n\nexport const greaterEqual = binaryKernelFunc({\n  opSnippet: GREATER_EQUAL,\n  packedOpSnippet: GREATER_EQUAL_PACKED,\n  dtype: 'bool'\n});\n\nexport const greaterEqualConfig: KernelConfig = {\n  kernelName: GreaterEqual,\n  backendName: 'webgl',\n  kernelFunc: greaterEqual as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IFFT, IFFTInputs, KernelConfig, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {fftImpl} from './FFT_impl';\n\nexport function ifft(args: {inputs: IFFTInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  return fftImpl(input, true /* inverse */, backend);\n}\n\nexport const ifftConfig: KernelConfig = {\n  kernelName: IFFT,\n  backendName: 'webgl',\n  kernelFunc: ifft\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IsFinite, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst IS_FINITE = `return float(!isnan(x) && !isinf(x));`;\n\nexport const isFinite = unaryKernelFunc({opSnippet: IS_FINITE, dtype: 'bool'});\n\nexport const isFiniteConfig: KernelConfig = {\n  kernelName: IsFinite,\n  backendName: 'webgl',\n  kernelFunc: isFinite,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IsInf, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst IS_INF = `return float(isinf(x));`;\n\nexport const isInf = unaryKernelFunc({opSnippet: IS_INF, dtype: 'bool'});\n\nexport const isInfConfig: KernelConfig = {\n  kernelName: IsInf,\n  backendName: 'webgl',\n  kernelFunc: isInf,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IsNan, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst IS_NAN = `return float(isnan(x));`;\n\nexport const isNaN = unaryKernelFunc({opSnippet: IS_NAN, dtype: 'bool'});\n\nexport const isNaNConfig: KernelConfig = {\n  kernelName: IsNan,\n  backendName: 'webgl',\n  kernelFunc: isNaN,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Less} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {lessImplCPU} from '../kernel_utils/shared';\n\nconst LESS = `return float(a < b);`;\nconst LESS_PACKED = `\n  return vec4(lessThan(a, b));\n`;\n\nexport const less = binaryKernelFunc({\n  opSnippet: LESS,\n  packedOpSnippet: LESS_PACKED,\n  cpuKernelImpl: lessImplCPU,\n  dtype: 'bool'\n});\n\nexport const lessConfig: KernelConfig = {\n  kernelName: Less,\n  backendName: 'webgl',\n  kernelFunc: less as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LessEqual} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nexport const LESS_EQUAL = `return float(a <= b);`;\nexport const LESS_EQUAL_PACKED = `\n  return vec4(lessThanEqual(a, b));\n`;\n\nexport const lessEqual = binaryKernelFunc(\n    {opSnippet: LESS_EQUAL, packedOpSnippet: LESS_EQUAL_PACKED, dtype: 'bool'});\n\nexport const lessEqualConfig: KernelConfig = {\n  kernelName: LessEqual,\n  backendName: 'webgl',\n  kernelFunc: lessEqual as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LinSpace, LinSpaceAttrs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {linSpaceImplCPU} from '../kernel_utils/shared';\n\nexport function linSpace(\n    args: {backend: MathBackendWebGL, attrs: LinSpaceAttrs}): TensorInfo {\n  const {backend, attrs} = args;\n  const {start, stop, num} = attrs;\n\n  // TODO: Use CPU implementation due to the precision problem in Safari.\n  const outVals = linSpaceImplCPU(start, stop, num);\n  return backend.makeTensorInfo([outVals.length], 'float32', outVals);\n}\n\nexport const linSpaceConfig: KernelConfig = {\n  kernelName: LinSpace,\n  backendName: 'webgl',\n  kernelFunc: linSpace as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Log} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {logImplCPU} from '../kernel_utils/shared';\n\nconst LOG = `if (x < 0.0) return NAN;\n  return log(x);`;\n\nconst LOG_PACKED = `\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n`;\n\nexport const log = unaryKernelFunc(\n    {opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU});\n\nexport const logConfig: KernelConfig = {\n  kernelName: Log,\n  backendName: 'webgl',\n  kernelFunc: log as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Log1p} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOG1P = `return log(1.0 + x);`;\n\nexport const log1p = unaryKernelFunc({opSnippet: LOG1P});\n\nexport const log1pConfig: KernelConfig = {\n  kernelName: Log1p,\n  backendName: 'webgl',\n  kernelFunc: log1p,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LogicalAnd} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\nconst LOGICAL_AND_PACKED = `\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;\n\nexport const logicalAnd = binaryKernelFunc({\n  opSnippet: LOGICAL_AND,\n  packedOpSnippet: LOGICAL_AND_PACKED,\n  dtype: 'bool'\n});\n\nexport const logicalAndConfig: KernelConfig = {\n  kernelName: LogicalAnd,\n  backendName: 'webgl',\n  kernelFunc: logicalAnd as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, LogicalNot} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOGICAL_NOT = `return float(!(x >= 1.0));`;\n\nexport const logicalNot = unaryKernelFunc({opSnippet: LOGICAL_NOT});\n\nexport const logicalNotConfig: KernelConfig = {\n  kernelName: LogicalNot,\n  backendName: 'webgl',\n  kernelFunc: logicalNot,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LogicalOr} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\nconst LOGICAL_OR_PACKED = `\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;\n\nexport const logicalOr = binaryKernelFunc(\n    {opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: 'bool'});\n\nexport const logicalOrConfig: KernelConfig = {\n  kernelName: LogicalOr,\n  backendName: 'webgl',\n  kernelFunc: logicalOr as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${rad}; j <= ${rad}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${maxD}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${powOperator};\n        setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${rad};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${rad}; j <= ${rad}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${powOperator};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, LRN, LRNAttrs, LRNInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {LRNProgram} from '../lrn_gpu';\nimport {LRNPackedProgram} from '../lrn_packed_gpu';\n\nexport const lrn =\n    (args: {inputs: LRNInputs, backend: MathBackendWebGL, attrs: LRNAttrs}):\n        TensorInfo => {\n          const {inputs, backend, attrs} = args;\n          const {x} = inputs;\n          const {depthRadius, bias, alpha, beta} = attrs;\n\n          const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n              new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) :\n              new LRNProgram(x.shape, depthRadius, bias, alpha, beta);\n          return backend.runWebGLProgram(program, [x], x.dtype);\n        };\n\n// tslint:disable-next-line: variable-name\nexport const LRNConfig: KernelConfig = {\n  kernelName: LRN,\n  backendName: 'webgl',\n  kernelFunc: lrn as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNGradProgram implements GPGPUProgram {\n  variableNames = ['inputImage', 'outputImage', 'dy'];\n  outputShape: number[] = [];\n  userCode: string;\n  depthRadius: number;\n  bias: number;\n  alpha: number;\n  beta: number;\n  depth: number;\n\n  constructor(\n      inputShape: number[], depthRadius: number, bias: number, alpha: number,\n      beta: number) {\n    this.outputShape = inputShape;\n    this.depth = inputShape[3];\n    this.depthRadius = depthRadius;\n    this.bias = bias;\n    this.alpha = alpha;\n    this.beta = beta;\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${depthRadius})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${depthRadius} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${alpha}) * norm + float(${bias});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${alpha})\n                * float(${beta})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${beta});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LRNGrad, LRNGradAttrs, LRNGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {LRNGradProgram} from '../lrn_grad_gpu';\n\nexport const lrnGrad = (args: {\n  inputs: LRNGradInputs,\n  backend: MathBackendWebGL,\n  attrs: LRNGradAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x, y, dy} = inputs;\n  const {depthRadius, bias, alpha, beta} = attrs;\n\n  const program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);\n  return backend.runWebGLProgram(program, [x, y, dy], x.dtype);\n};\n\n// tslint:disable-next-line: variable-name\nexport const LRNGradConfig: KernelConfig = {\n  kernelName: LRNGrad,\n  backendName: 'webgl',\n  kernelFunc: lrnGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelFunc, Max, MaxAttrs, MaxInputs, TensorInfo} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {maxImplCPU} from '../kernel_utils/shared';\n\nimport {maxImpl} from './Max_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport function max(\n    args: {inputs: MaxInputs, backend: MathBackendWebGL, attrs: MaxAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {reductionIndices, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  const maxInputIsTransposed = permutedAxes != null;\n  const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x]);\n\n  let maxInput = x;\n  if (maxInputIsTransposed) {\n    if (shouldExecuteOnCPU) {\n      const xTexData = backend.texData.get(maxInput.dataId);\n      const values = xTexData.values as TypedArray;\n\n      const newShape: number[] = new Array(xRank);\n      for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = x.shape[permutedAxes[i]];\n      }\n      const maxInputValues =\n          transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n      maxInput = backend.makeTensorInfo(newShape, x.dtype);\n      const maxInputData = backend.texData.get(maxInput.dataId);\n      maxInputData.values = maxInputValues;\n    } else {\n      maxInput = transposeImpl(x, permutedAxes, backend);\n    }\n\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n  const [maxOutShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(maxInput.shape, axes);\n\n  let outShape = maxOutShape;\n  if (keepDims) {\n    // rather than reshape at the end, set the target shape here.\n    outShape = backend_util.expandShapeToKeepDim(maxOutShape, origAxes);\n  }\n\n  let out;\n  if (shouldExecuteOnCPU) {\n    const xTexData = backend.texData.get(maxInput.dataId);\n    const values = xTexData.values as TypedArray;\n\n    const outValues =\n        maxImplCPU(values, util.sizeFromShape(reduceShape), outShape, x.dtype);\n\n    out = backend.makeTensorInfo(outShape, x.dtype);\n    const outData = backend.texData.get(out.dataId);\n    outData.values = outValues;\n  } else {\n    out = maxImpl(maxInput, reduceShape, outShape, backend);\n  }\n\n  if (maxInputIsTransposed) {\n    backend.disposeIntermediateTensorInfo(maxInput);\n  }\n\n  return out;\n}\n\nexport const maxConfig: KernelConfig = {\n  kernelName: Max,\n  backendName: 'webgl',\n  kernelFunc: max as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from '../kernels/Reshape';\n\nexport function maxImpl(\n    x: TensorInfo, reduceShape: number[], outShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput =\n      reshape({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const reduced = reduce(reshapedInput, x.dtype, 'max', backend);\n  const reshapedOutput =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  return reshapedOutput;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Maximum} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET} from '../binaryop_gpu';\nimport {CHECK_NAN_SNIPPET as CHECK_NAN_SNIPPET_PACKED} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {maximumImplCPU} from '../kernel_utils/shared';\n\nconst MAXIMUM = CHECK_NAN_SNIPPET + `\n  return max(a, b);\n`;\n\nconst MAXIMUM_PACKED = `\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\n\nexport const maximum = binaryKernelFunc({\n  opSnippet: MAXIMUM,\n  packedOpSnippet: MAXIMUM_PACKED,\n  cpuKernelImpl: maximumImplCPU\n});\n\nexport const maximumConfig: KernelConfig = {\n  kernelName: Maximum,\n  backendName: 'webgl',\n  kernelFunc: maximum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool, MaxPoolAttrs, MaxPoolInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\nimport {identity} from './Identity';\n\nexport function maxPool(args: {\n  inputs: MaxPoolInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPoolAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  assertNotComplex(x, 'maxPool');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n      util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return identity({inputs: {x}, backend});\n  }\n  const maxPoolProgram = new Pool2DProgram(convInfo, 'max', false);\n  return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\n\nexport const maxPoolConfig: KernelConfig = {\n  kernelName: MaxPool,\n  backendName: 'webgl',\n  kernelFunc: maxPool as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool3D, MaxPool3DAttrs, MaxPool3DInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool3DProgram} from '../pool_gpu';\n\nexport function maxPool3d(args: {\n  inputs: MaxPool3DInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPool3DAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {filterSize, strides, pad, dataFormat, dimRoundingMode} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode, dataFormat);\n  const maxPoolProgram = new Pool3DProgram(convInfo, 'max', false);\n  return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\n\nexport const maxPool3DConfig: KernelConfig = {\n  kernelName: MaxPool3D,\n  backendName: 'webgl',\n  kernelFunc: maxPool3d as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MaxPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n          wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${effectiveFilterWidth} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class MaxPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex =\n        effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n           wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${lastIndex} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                  wR * ${effectiveFilterWidth} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool3DGrad, MaxPool3DGradAttrs, MaxPool3DGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MaxPool3DBackpropProgram} from '../max_pool_backprop_gpu';\nimport {Pool3DProgram} from '../pool_gpu';\n\nexport function maxPool3DGrad(args: {\n  inputs: MaxPool3DGradInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPool3DGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input} = inputs;\n  const x = input;\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n\n  const maxPool3dPositionsProgram =\n      new Pool3DProgram(convInfo, 'max', true /* get positions */);\n  const maxPool3dPositions =\n      backend.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);\n  const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);\n  const result = backend.runWebGLProgram(\n      maxPoolBackpropProgram, [dy, maxPool3dPositions], x.dtype);\n  backend.disposeIntermediateTensorInfo(maxPool3dPositions);\n  return result;\n}\n\nexport const maxPoolGrad3DConfig: KernelConfig = {\n  kernelName: MaxPool3DGrad,\n  backendName: 'webgl',\n  kernelFunc: maxPool3DGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPoolGrad, MaxPoolGradAttrs, MaxPoolGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MaxPool2DBackpropProgram} from '../max_pool_backprop_gpu';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function maxPoolGrad(args: {\n  inputs: MaxPoolGradInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPoolGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input, output} = inputs;\n  const x = input;\n  assertNotComplex([input, output], 'maxPoolGrad');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      1 /* dilations */, pad, dimRoundingMode);\n  const getPositions = true;\n  const maxPoolPositionsProgram =\n      new Pool2DProgram(convInfo, 'max', getPositions);\n  const maxPoolPositions: TensorInfo =\n      backend.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);\n\n  const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);\n  const result = backend.runWebGLProgram(\n      maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);\n  backend.disposeIntermediateTensorInfo(maxPoolPositions);\n  return result;\n}\n\nexport const maxPoolGradConfig: KernelConfig = {\n  kernelName: MaxPoolGrad,\n  backendName: 'webgl',\n  kernelFunc: maxPoolGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {MaxPoolWithArgmax, MaxPoolWithArgmaxAttrs, MaxPoolWithArgmaxInputs} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {maxPoolWithArgmaxImpl} from './MaxPoolWithArgmax_impl';\n\nexport const maxPoolWithArgmaxConfig: KernelConfig = {\n  kernelName: MaxPoolWithArgmax,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MaxPoolWithArgmaxInputs;\n    const {filterSize, strides, pad, includeBatchInIndex} =\n        attrs as {} as MaxPoolWithArgmaxAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    util.assert(\n        x.shape.length === 4,\n        () => `Error in maxPool: input must be rank 4 but got rank ${\n            x.shape.length}.`);\n    const dilations: [number, number] = [1, 1];\n    util.assert(\n        backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n        () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n            `Got strides ${strides} and dilations '${dilations}'`);\n\n    const convInfo = backend_util.computePool2DInfo(\n        x.shape as [number, number, number, number], filterSize, strides,\n        dilations, pad);\n\n    const [result, indexes] =\n        maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend);\n    return [result, indexes];\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\n\nexport function maxPoolWithArgmaxImpl(\n    x: TensorInfo, includeBatchInIndex: boolean,\n    convInfo: backend_util.Conv2DInfo,\n    backend: MathBackendWebGL): TensorInfo[] {\n  let program = new Pool2DProgram(convInfo, 'max', false);\n  const poolOutput = backend.runWebGLProgram(program, [x], 'float32');\n\n  program = new Pool2DProgram(convInfo, 'max', true, true, includeBatchInIndex);\n  const indexOutput = backend.runWebGLProgram(program, [x], 'float32');\n  return [poolOutput, indexOutput];\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Mean, MeanAttrs, MeanInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {meanImpl} from './Mean_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport const meanConfig: KernelConfig = {\n  kernelName: Mean,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MeanInputs;\n    const {keepDims, axis} = attrs as {} as MeanAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(axis, x.shape);\n\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const meanInputIsTransposed = permutedAxes != null;\n    const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n\n    const intermediates: TensorInfo[] = [];\n\n    let meanInput = x;\n    if (meanInputIsTransposed) {\n      if (shouldExecuteOnCPU) {\n        const xTexData = webglBackend.texData.get(meanInput.dataId);\n        const values = xTexData.values as TypedArray;\n\n        const newShape: number[] = new Array(xRank);\n        for (let i = 0; i < newShape.length; i++) {\n          newShape[i] = x.shape[permutedAxes[i]];\n        }\n        const meanInputValues =\n            transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n        meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n        const meanInputData = webglBackend.texData.get(meanInput.dataId);\n        meanInputData.values = meanInputValues;\n      } else {\n        meanInput = transposeImpl(x, permutedAxes, webglBackend);\n      }\n\n      intermediates.push(meanInput);\n      axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n\n    backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n    const [meanOutShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(meanInput.shape, axes);\n\n    let outShape = meanOutShape;\n    if (keepDims) {\n      // rather than reshape at the end, set the target shape here.\n      outShape = backend_util.expandShapeToKeepDim(meanOutShape, origAxes);\n    }\n\n    const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);\n    for (const i of intermediates) {\n      webglBackend.disposeIntermediateTensorInfo(i);\n    }\n\n    return out;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from '../kernels/Reshape';\n\nexport function meanImpl(\n    x: TensorInfo, reduceShape: number[], outShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput =\n      reshape({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const reduced = reduce(reshapedInput, 'float32', 'mean', backend);\n  const reshapedOutput =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  return reshapedOutput;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Min, MinAttrs, MinInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\n\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function min(\n    args: {inputs: MinInputs, backend: MathBackendWebGL, attrs: MinAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('min', axes, xRank);\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n  const inSize = util.sizeFromShape(reduceShape);\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  const reduced = reduce(a2D, a2D.dtype, 'min', backend);\n\n  let res;\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: newShape}});\n  } else {\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n  }\n\n  backend.disposeIntermediateTensorInfo(a2D);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  if (permutedAxes != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n\n  return res;\n}\n\nexport const minConfig: KernelConfig = {\n  kernelName: Min,\n  backendName: 'webgl',\n  kernelFunc: min as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Minimum} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET} from '../binaryop_gpu';\nimport {CHECK_NAN_SNIPPET as CHECK_NAN_SNIPPET_PACKED} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {minimumImplCPU} from '../kernel_utils/shared';\n\nconst MINIMUM = CHECK_NAN_SNIPPET + `\n  return min(a, b);\n`;\n\nconst MINIMUM_PACKED = `\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\n\nexport const minimum = binaryKernelFunc({\n  opSnippet: MINIMUM,\n  packedOpSnippet: MINIMUM_PACKED,\n  cpuKernelImpl: minimumImplCPU\n});\n\nexport const minimumConfig: KernelConfig = {\n  kernelName: Minimum,\n  backendName: 'webgl',\n  kernelFunc: minimum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class MirrorPadProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      mode: 'reflect'|'symmetric') {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const unpackedCoords =\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n    const offset = mode === 'reflect' ? 0 : 1;\n\n    if (rank === 1) {\n      this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${offset};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${offset};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;\n      return;\n    }\n    this.userCode = `\n      ${dtype} start = ${dtype}(${start});\n      ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outC = getOutputCoords();\n        for (int i = 0; i < ${rank}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${offset};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};\n          }\n        }\n        ${dtype} coords = outC - start;\n        setOutput(getX(${unpackedCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nexport class MirrorPadPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      mode: 'reflect'|'symmetric') {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const coords = getChannels('rc', rank);\n    const source = getChannels('source', rank);\n    const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n    const innerDims =\n        rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n    const offset = mode === 'reflect' ? 0 : 1;\n\n    let mainLoop = '';\n    if (rank === 1) {\n      const padSetup = `\n        ${dtype} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${offset};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${offset};\n        }\n        source -= start;\n      `;\n      mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n    } else {\n      const padSetup = `\n        ${dtype} source = rc;\n        ${dtype} lt = ${dtype}(lessThan(source, start));\n        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));\n        ${dtype} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${offset}) +\n                gte * ((end - 1) * 2 - source + ${offset});\n        source -= start;\n      `;\n\n      mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n        rc = outputLoc;\n        ${coords[rank - 2]} += 1;\n        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {\n          ${padSetup}\n          result[2] = getChannel(getX(${source.join()}), ${innerDims});\n          ${coords[rank - 1]} += 1;\n          if(${cLimit}) {\n            ${padSetup}\n            result[3] = getChannel(getX(${source.join()}), ${innerDims});\n          }\n        }\n      `;\n    }\n\n    this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, MirrorPad, MirrorPadAttrs, MirrorPadInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MirrorPadProgram} from '../mirror_pad_gpu';\nimport {MirrorPadPackedProgram} from '../mirror_pad_packed_gpu';\n\nexport const mirrorPadKernelFunc: (params: {\n  inputs: MirrorPadInputs,\n  backend: MathBackendWebGL,\n  attrs: MirrorPadAttrs\n}) => TensorInfo = ({inputs, backend, attrs}) => {\n  const {x} = inputs;\n  const {paddings, mode} = attrs;\n\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new MirrorPadPackedProgram(x.shape, paddings, mode) :\n      new MirrorPadProgram(x.shape, paddings, mode);\n\n  const output = backend.runWebGLProgram(program, [x], x.dtype);\n\n  return output;\n};\n\nexport const mirrorPadConfig: KernelConfig = {\n  kernelName: MirrorPad,\n  backendName: 'webgl',\n  kernelFunc: mirrorPadKernelFunc as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Mod} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst MOD = `if (b == 0.0) return NAN;\n  return mod(a, b);`;\n\nconst MOD_PACKED = `\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const mod = binaryKernelFunc({\n  opSnippet: MOD,\n  packedOpSnippet: MOD_PACKED,\n});\n\nexport const modConfig: KernelConfig = {\n  kernelName: Mod,\n  backendName: 'webgl',\n  kernelFunc: mod as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MultinomialProgram implements GPGPUProgram {\n  variableNames = ['probs'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  seedLoc: WebGLUniformLocation;\n\n  constructor(batchSize: number, numOutcomes: number, numSamples: number) {\n    this.outputShape = [batchSize, numSamples];\n\n    this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${numOutcomes - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${numOutcomes - 1}));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(seed: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.seedLoc == null) {\n        this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n      }\n      gpgpu.gl.uniform1f(this.seedLoc, seed);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {RealDiv} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\n// Without the equality check div produces 0.9999 for a = b, which when\n// floored can cause errors.\nconst DIV = `\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;\n\n// We do the same as in ./binaryop_gpu, with vec4 and ivec4.\n// On Linux, the vectorized implementation produces NaNs when a and b are 0.\nconst DIV_PACKED = `\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;\n\nexport const realDiv = binaryKernelFunc(\n    {opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true});\n\nexport const realDivConfig: KernelConfig = {\n  kernelName: RealDiv,\n  backendName: 'webgl',\n  kernelFunc: realDiv,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sub} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {subImplCPU as cpuSub} from '../kernel_utils/shared';\n\nconst SUB = 'return a - b;';\n\nexport const sub = binaryKernelFunc({\n  opSnippet: SUB,\n  packedOpSnippet: SUB,\n  supportsComplex: true,\n  cpuKernelImpl: cpuSub\n});\n\nexport const subConfig: KernelConfig = {\n  kernelName: Sub,\n  backendName: 'webgl',\n  kernelFunc: sub\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Softmax, SoftmaxAttrs, SoftmaxInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {exp} from './Exp';\nimport {max} from './Max';\nimport {realDiv} from './RealDiv';\nimport {reshape} from './Reshape';\nimport {sub} from './Sub';\nimport {sum} from './Sum';\n\nexport function softmax(args: {\n  inputs: SoftmaxInputs,\n  backend: MathBackendWebGL,\n  attrs: SoftmaxAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {logits} = inputs;\n  const {dim} = attrs;\n\n  const axes = util.parseAxisParam([dim], logits.shape);\n\n  const maxLogit = max({\n    inputs: {x: logits},\n    backend,\n    attrs: {reductionIndices: axes, keepDims: false}\n  });\n\n  const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n\n  const maxLogitsReshaped =\n      reshape({inputs: {x: maxLogit}, backend, attrs: {shape: expandedShape}});\n  const a =\n      sub({inputs: {a: logits, b: maxLogitsReshaped}, backend}) as TensorInfo;\n  const b = exp({inputs: {x: a}, backend}) as TensorInfo;\n  const sumExp =\n      sum({inputs: {x: b}, backend, attrs: {axis: axes, keepDims: false}});\n  const sumExpReshaped =\n      reshape({inputs: {x: sumExp}, backend, attrs: {shape: expandedShape}});\n\n  const res =\n      realDiv({inputs: {a: b, b: sumExpReshaped}, backend}) as TensorInfo;\n\n  backend.disposeIntermediateTensorInfo(maxLogit);\n  backend.disposeIntermediateTensorInfo(maxLogitsReshaped);\n  backend.disposeIntermediateTensorInfo(a);\n  backend.disposeIntermediateTensorInfo(b);\n  backend.disposeIntermediateTensorInfo(sumExp);\n  backend.disposeIntermediateTensorInfo(sumExpReshaped);\n\n  return res;\n}\n\nexport const softmaxConfig: KernelConfig = {\n  kernelName: Softmax,\n  backendName: 'webgl',\n  kernelFunc: softmax as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Multinomial, MultinomialAttrs, MultinomialInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MultinomialProgram} from '../multinomial_gpu';\n\nimport {softmax} from './Softmax';\n\nexport function multinomial(args: {\n  inputs: MultinomialInputs,\n  backend: MathBackendWebGL,\n  attrs: MultinomialAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {logits} = inputs;\n  const {numSamples, seed, normalized} = attrs;\n\n  const probs = normalized ?\n      logits :\n      softmax(\n          {inputs: {logits}, backend, attrs: {dim: logits.shape.length - 1}});\n  const batchSize = probs.shape[0];\n  const numOutcomes = probs.shape[1];\n  const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);\n  const customSetup = program.getCustomSetupFunc(seed);\n\n  const res = backend.runWebGLProgram(program, [probs], 'int32', customSetup);\n  if (!normalized) {\n    backend.disposeIntermediateTensorInfo(probs);\n  }\n  return res;\n}\n\nexport const multinomialConfig: KernelConfig = {\n  kernelName: Multinomial,\n  backendName: 'webgl',\n  kernelFunc: multinomial as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Neg, NegInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {negImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpProgram} from '../unaryop_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nconst NEG = `return -x;`;\n\n// This doesn't use unaryKernelFunc because negImplCPU is not of type\n// SimpleUnaryKernelImplCPU.\nexport function neg(args: {inputs: NegInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (backend.shouldExecuteOnCPU([x])) {\n    const xData = backend.texData.get(x.dataId);\n    const [outValues, newShape] =\n        negImplCPU(xData.values as TypedArray, x.shape, x.dtype);\n    return backend.makeTensorInfo(newShape, x.dtype, outValues);\n  }\n\n  let program: UnaryOpProgram|UnaryOpPackedProgram;\n  if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n    program = new UnaryOpPackedProgram(x.shape, NEG);\n  } else {\n    program = new UnaryOpProgram(x.shape, NEG);\n  }\n\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const negConfig: KernelConfig = {\n  kernelName: Neg,\n  backendName: 'webgl',\n  kernelFunc: neg as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV3, NonMaxSuppressionV3Attrs, NonMaxSuppressionV3Inputs, TypedArray} from '@tensorflow/tfjs-core';\n\nconst nonMaxSuppressionV3Impl = kernel_impls.nonMaxSuppressionV3Impl;\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function nonMaxSuppressionV3(args: {\n  inputs: NonMaxSuppressionV3Inputs,\n  backend: MathBackendWebGL,\n  attrs: NonMaxSuppressionV3Attrs\n}) {\n  backend_util.warn(\n      'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold} = attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const {selectedIndices} = nonMaxSuppressionV3Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n\n  return backend.makeTensorInfo(\n      [selectedIndices.length], 'int32', new Int32Array(selectedIndices));\n}\n\nexport const nonMaxSuppressionV3Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV3,\n  backendName: 'webgl',\n  kernelFunc: nonMaxSuppressionV3 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV4, NonMaxSuppressionV4Attrs, NonMaxSuppressionV4Inputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV4Impl = kernel_impls.nonMaxSuppressionV4Impl;\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function nonMaxSuppressionV4(args: {\n  inputs: NonMaxSuppressionV4Inputs,\n  backend: MathBackendWebGL,\n  attrs: NonMaxSuppressionV4Attrs\n}): [TensorInfo, TensorInfo] {\n  backend_util.warn(\n      'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize} =\n      attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const {selectedIndices, validOutputs} = nonMaxSuppressionV4Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold,\n      padToMaxOutputSize);\n\n  return [\n    backend.makeTensorInfo(\n        [selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n    backend.makeTensorInfo([], 'int32', new Int32Array([validOutputs]))\n  ];\n}\n\nexport const nonMaxSuppressionV4Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV4,\n  backendName: 'webgl',\n  kernelFunc: nonMaxSuppressionV4 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV5, NonMaxSuppressionV5Attrs, NonMaxSuppressionV5Inputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nconst nonMaxSuppressionV5Impl = kernel_impls.nonMaxSuppressionV5Impl;\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function nonMaxSuppressionV5(args: {\n  inputs: NonMaxSuppressionV5Inputs,\n  backend: MathBackendWebGL,\n  attrs: NonMaxSuppressionV5Attrs\n}): [TensorInfo, TensorInfo] {\n  backend_util.warn(\n      'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} = attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const maxOutputSizeVal = maxOutputSize;\n  const iouThresholdVal = iouThreshold;\n  const scoreThresholdVal = scoreThreshold;\n  const softNmsSigmaVal = softNmsSigma;\n\n  const {selectedIndices, selectedScores} = nonMaxSuppressionV5Impl(\n      boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal,\n      scoreThresholdVal, softNmsSigmaVal);\n\n  return [\n    backend.makeTensorInfo(\n        [selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n    backend.makeTensorInfo(\n        [selectedScores.length], 'float32', new Float32Array(selectedScores))\n  ];\n}\n\nexport const nonMaxSuppressionV5Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV5,\n  backendName: 'webgl',\n  kernelFunc: nonMaxSuppressionV5 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class OneHotProgram implements GPGPUProgram {\n  variableNames = ['indices'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  seedLoc: WebGLUniformLocation;\n\n  constructor(\n      numIndices: number, depth: number, onValue: number, offValue: number) {\n    this.outputShape = [numIndices, depth];\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${offValue}), float(${onValue}),\n                      float(index == coords.y)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, OneHot, OneHotAttrs, OneHotInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {OneHotProgram} from '../onehot_gpu';\nimport {reshape} from './Reshape';\n\nexport const oneHot = (args: {\n  inputs: OneHotInputs,\n  backend: MathBackendWebGL,\n  attrs: OneHotAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {indices} = inputs;\n  const {depth, onValue, offValue} = attrs;\n\n  const indicesSize = util.sizeFromShape(indices.shape);\n  const program = new OneHotProgram(indicesSize, depth, onValue, offValue);\n  const reshaped =\n      reshape({inputs: {x: indices}, backend, attrs: {shape: [indicesSize]}});\n  const result = backend.runWebGLProgram(program, [reshaped], indices.dtype);\n  backend.disposeIntermediateTensorInfo(reshaped);\n\n  const outShape = [...indices.shape, depth];\n  const out = reshape({inputs: {x: result}, backend, attrs: {shape: outShape}});\n  backend.disposeIntermediateTensorInfo(result);\n  return out;\n};\n\nexport const oneHotConfig: KernelConfig = {\n  kernelName: OneHot,\n  backendName: 'webgl',\n  kernelFunc: oneHot as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, ZerosLike, ZerosLikeInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {complex} from './Complex';\nimport {fill} from './Fill';\nimport {imag} from './Imag';\nimport {real} from './Real';\n\nexport function zerosLike(\n    args: {inputs: ZerosLikeInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const r = zerosLike({inputs: {x: realPart}, backend});\n    const imagPart = imag({inputs: {input: x}, backend});\n    const i = zerosLike({inputs: {x: imagPart}, backend});\n\n    const result = complex({inputs: {real: r, imag: i}, backend});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(r);\n    backend.disposeIntermediateTensorInfo(imagPart);\n    backend.disposeIntermediateTensorInfo(i);\n\n    return result;\n  } else {\n    return fill({\n      attrs: {\n        shape: x.shape,\n        dtype: x.dtype,\n        value: x.dtype === 'string' ? '' : 0\n      },\n      backend\n    });\n  }\n}\n\nexport const zerosLikeConfig: KernelConfig = {\n  kernelName: ZerosLike,\n  backendName: 'webgl',\n  kernelFunc: zerosLike as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, OnesLike, OnesLikeInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {complex} from './Complex';\nimport {fill} from './Fill';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {zerosLike} from './ZerosLike';\n\nexport function onesLike(\n    args: {inputs: OnesLikeInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (x.dtype === 'string') {\n    throw new Error('onesLike is not supported under string dtype');\n  } else if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const r = onesLike({inputs: {x: realPart}, backend});\n    const imagPart = imag({inputs: {input: x}, backend});\n    const i = zerosLike({inputs: {x: imagPart}, backend});\n\n    const result = complex({inputs: {real: r, imag: i}, backend});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(r);\n    backend.disposeIntermediateTensorInfo(imagPart);\n    backend.disposeIntermediateTensorInfo(i);\n\n    return result;\n  } else {\n    // TODO(cais, smilkov): Add WebGL shader for onesLike:\n    //   https://github.com/tensorflow/tfjs/issues/1293\n    return fill({attrs: {shape: x.shape, dtype: x.dtype, value: 1}, backend});\n  }\n}\n\nexport const onesLikeConfig: KernelConfig = {\n  kernelName: OnesLike,\n  backendName: 'webgl',\n  kernelFunc: onesLike as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Pack, PackAttrs, PackInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {concat} from './Concat';\nimport {expandDims} from './ExpandDims';\n\nexport function pack(\n    args: {inputs: PackInputs, backend: MathBackendWebGL, attrs: PackAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  if (inputs.length === 1) {\n    return expandDims(\n        {inputs: {input: inputs[0]}, backend, attrs: {dim: axis}});\n  }\n\n  const shape = inputs[0].shape;\n  const dtype = inputs[0].dtype;\n\n  inputs.forEach(t => {\n    util.assertShapesMatch(\n        shape, t.shape,\n        'All tensors passed to stack must have matching shapes');\n    util.assert(\n        dtype === t.dtype,\n        () => 'All tensors passed to stack must have matching dtypes');\n  });\n\n  const intermediateTensorInfos: TensorInfo[] = [];\n  const expandedTensors = inputs.map(t => {\n    const expandedT =\n        expandDims({inputs: {input: t}, backend, attrs: {dim: axis}});\n    intermediateTensorInfos.push(expandedT);\n    return expandedT;\n  });\n\n  const result = concat({inputs: expandedTensors, backend, attrs: {axis}});\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return result;\n}\n\nexport const packConfig: KernelConfig = {\n  kernelName: Pack,\n  backendName: 'webgl',\n  kernelFunc: pack as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PadProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  valueLoc: WebGLUniformLocation;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const type = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const unpackedCoords =\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n\n    if (rank === 1) {\n      this.userCode = `\n        int start = ${start};\n        int end = ${end};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n      return;\n    }\n    this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n      uniform float value;\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n  }\n\n  getCustomSetupFunc(value: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.valueLoc == null) {\n        this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n      }\n      gpgpu.gl.uniform1f(this.valueLoc, value);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PadPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  valueLoc: WebGLUniformLocation;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const coords = getChannels('rc', rank);\n    const source = getChannels('source', rank);\n    const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n    const innerDims =\n        rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n\n    const componentSetup = [\n      `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n      rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n      rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n    ];\n\n    const paddingArea = rank === 1 ?\n        'rc < start || rc >= end' :\n        'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n    let mainLoop = '';\n    for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n      mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(value);\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n    }\n    mainLoop += (rank === 1 ? `} ` : `}}`);\n\n    this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n      uniform float value;\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(value: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.valueLoc == null) {\n        this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n      }\n      gpgpu.gl.uniform1f(this.valueLoc, value);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, PadV2, PadV2Attrs, PadV2Inputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {PadProgram} from '../pad_gpu';\nimport {PadPackedProgram} from '../pad_packed_gpu';\n\nexport const padV2 =\n    (args: {inputs: PadV2Inputs, backend: MathBackendWebGL, attrs: PadV2Attrs}):\n        TensorInfo => {\n          const {inputs, backend, attrs} = args;\n          const {x} = inputs;\n          const {paddings, constantValue} = attrs;\n\n          const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n              new PadPackedProgram(x.shape, paddings, constantValue) :\n              new PadProgram(x.shape, paddings, constantValue);\n          const customSetup = program.getCustomSetupFunc(constantValue);\n          return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n        };\n\nexport const padV2Config: KernelConfig = {\n  kernelName: PadV2,\n  backendName: 'webgl',\n  kernelFunc: padV2 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Pow} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst POW = `\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;\n\nconst POW_PACKED = `\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const pow =\n    binaryKernelFunc({opSnippet: POW, packedOpSnippet: POW_PACKED});\n\nexport const powConfig: KernelConfig = {\n  kernelName: Pow,\n  backendName: 'webgl',\n  kernelFunc: pow as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, sumOutType, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {prodImplCPU} from '../kernel_utils/shared';\n\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendWebGL, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n  const toDispose = [];\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    toDispose.push(permutedX);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('prod', axes, xRank);\n\n  let res;\n  if (backend.shouldExecuteOnCPU([permutedX])) {\n    const xVals = backend.texData.get(permutedX.dataId).values as TypedArray;\n    const {outVals, outShape, outDtype} =\n        prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);\n    res = backend.makeTensorInfo(outShape, outDtype, outVals);\n  } else {\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = reshape(\n        {inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n    const outputDType = sumOutType(x.dtype);\n    const reduced = reduce(a2D, outputDType, 'prod', backend);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n\n    toDispose.push(a2D);\n    toDispose.push(reduced);\n  }\n\n  if (keepDims) {\n    toDispose.push(res);\n    const newShape = backend_util.expandShapeToKeepDim(res.shape, origAxes);\n    res = reshape({inputs: {x: res}, backend, attrs: {shape: newShape}});\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return res;\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'webgl',\n  kernelFunc: prod as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Range, RangeAttrs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {rangeImplCPU} from '../kernel_utils/shared';\n\nexport const range =\n    (args: {backend: MathBackendWebGL, attrs: RangeAttrs}): TensorInfo => {\n      const {backend, attrs} = args;\n      const {start, stop, step, dtype} = attrs;\n      const values = rangeImplCPU(start, stop, step, dtype);\n      return backend.makeTensorInfo([values.length], dtype, values);\n    };\n\nexport const rangeConfig: KernelConfig = {\n  kernelName: Range,\n  backendName: 'webgl',\n  kernelFunc: range as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Reciprocal} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst RECIPROCAL = `return 1.0 / x;`;\n\nexport const reciprocal = unaryKernelFunc({opSnippet: RECIPROCAL});\n\nexport const reciprocalConfig: KernelConfig = {\n  kernelName: Reciprocal,\n  backendName: 'webgl',\n  kernelFunc: reciprocal,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Relu} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\n\nconst RELU_PACKED = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const relu =\n    unaryKernelFunc({opSnippet: RELU, packedOpSnippet: RELU_PACKED});\n\nexport const reluConfig: KernelConfig = {\n  kernelName: Relu,\n  backendName: 'webgl',\n  kernelFunc: relu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Relu6} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\n\nconst RELU6_PACKED = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const relu6 =\n    unaryKernelFunc({opSnippet: RELU6, packedOpSnippet: RELU6_PACKED});\n\nexport const relu6Config: KernelConfig = {\n  kernelName: Relu6,\n  backendName: 'webgl',\n  kernelFunc: relu6 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC =\n          `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n          ` - vec2(0.5)`;\n    } else {\n      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * ` +\n          `effectiveInputOverOutputRatioRC - vec3(0.5)`;\n    } else {\n      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n\n    this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, ResizeBilinear, ResizeBilinearAttrs, ResizeBilinearInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeBilinearProgram} from '../resize_bilinear_gpu';\nimport {ResizeBilinearPackedProgram} from '../resize_bilinear_packed_gpu';\n\nexport function resizeBilinear(args: {\n  inputs: ResizeBilinearInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeBilinearAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images} = inputs;\n  const {alignCorners, halfPixelCenters, size} = attrs;\n\n  const [newHeight, newWidth] = size;\n\n  const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n      new ResizeBilinearPackedProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters) :\n      new ResizeBilinearProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters);\n  return backend.runWebGLProgram(program, [images], 'float32');\n}\n\nexport const resizeBilinearConfig: KernelConfig = {\n  kernelName: ResizeBilinear,\n  backendName: 'webgl',\n  kernelFunc: resizeBilinear as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      dyShape: [number, number, number, number],\n      inputShape: [number, number, number, number], alignCorners: boolean) {\n    this.outputShape = inputShape;\n    const [, xHeight, xWidth, ] = inputShape;\n    const [, yHeight, yWidth] = dyShape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeBilinearGrad, ResizeBilinearGradAttrs, ResizeBilinearGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeBilinearBackpropProgram} from '../resize_bilinear_backprop_gpu';\n\nexport function resizeBilinearGrad(args: {\n  inputs: ResizeBilinearGradInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeBilinearGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images, dy} = inputs;\n  const {alignCorners} = attrs;\n\n  const program = new ResizeBilinearBackpropProgram(\n      dy.shape as [number, number, number, number],\n      images.shape as [number, number, number, number], alignCorners);\n\n  return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\n\nexport const resizeBilinearGradConfig: KernelConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'webgl',\n  kernelFunc: resizeBilinearGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeighborProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = alignCorners ? '0.5' : '0.0';\n\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC =\n          `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n          `, vec2(0.0))`;\n    } else {\n      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeighborPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = alignCorners ? '0.5' : '0.0';\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * ` +\n          `effectiveInputOverOutputRatioRC, vec3(0.0))`;\n    } else {\n      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n\n    this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, ResizeNearestNeighbor, ResizeNearestNeighborAttrs, ResizeNearestNeighborInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeNearestNeighborProgram} from '../resize_nearest_neighbor_gpu';\nimport {ResizeNearestNeighborPackedProgram} from '../resize_nearest_neighbor_packed_gpu';\n\nexport function resizeNearestNeighbor(args: {\n  inputs: ResizeNearestNeighborInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeNearestNeighborAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images} = inputs;\n  const {alignCorners, halfPixelCenters, size} = attrs;\n\n  const [newHeight, newWidth] = size;\n\n  const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n      new ResizeNearestNeighborPackedProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters) :\n      new ResizeNearestNeighborProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters);\n  return backend.runWebGLProgram(program, [images], images.dtype);\n}\n\nexport const resizeNearestNeighborConfig: KernelConfig = {\n  kernelName: ResizeNearestNeighbor,\n  backendName: 'webgl',\n  kernelFunc: resizeNearestNeighbor as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeigborBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      dyShape: [number, number, number, number],\n      inputShape: [number, number, number, number], alignCorners: boolean) {\n    this.outputShape = inputShape;\n    const [, xHeight, xWidth, ] = inputShape;\n    const [, yHeight, yWidth] = dyShape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${effectiveXSize[0]}) *\n                (float(dyR) / float(${effectiveYSize[0]}));\n\n            float sourceFracCol =\n                float(${effectiveXSize[1]}) *\n                  (float(dyC) / float(${effectiveYSize[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${xHeight}) - 1),\n                ${alignCorners} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${xWidth}) - 1),\n                ${alignCorners} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeNearestNeighborGrad, ResizeNearestNeighborGradAttrs, ResizeNearestNeighborGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeNearestNeigborBackpropProgram} from '../resize_nearest_neighbor_backprop_gpu';\n\nexport function resizeNearestNeighborGrad(args: {\n  inputs: ResizeNearestNeighborGradInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeNearestNeighborGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images, dy} = inputs;\n  const {alignCorners} = attrs;\n\n  const program = new ResizeNearestNeigborBackpropProgram(\n      dy.shape as [number, number, number, number],\n      images.shape as [number, number, number, number], alignCorners);\n  return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\n\nexport const resizeNearestNeighborGradConfig: KernelConfig = {\n  kernelName: ResizeNearestNeighborGrad,\n  backendName: 'webgl',\n  kernelFunc: resizeNearestNeighborGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReverseProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n\n    if (rank === 1) {\n      this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${xShape[0]} - coord - 1));\n        }\n      `;\n      return;\n    }\n    const getInCoord = (i: number) => {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - coords[${i}] - 1`;\n      }\n      return `coords[${i}]`;\n    };\n    const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');\n    const type = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${type} coords = getOutputCoords();\n        setOutput(getX(${inCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReversePackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn =\n        `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels: string[]): string {\n      return getChannel(channels);\n    }\n\n    function getG(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels: string[]): string {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels: string[]): string {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i: number, channels1: string[]): string {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Reverse, ReverseAttrs, ReverseInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ReverseProgram} from '../reverse_gpu';\nimport {ReversePackedProgram} from '../reverse_packed_gpu';\n\nimport {identity} from './Identity';\n\nexport function reverse(args: {\n  inputs: ReverseInputs,\n  backend: MathBackendWebGL,\n  attrs: ReverseAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const $dims = util.parseAxisParam(dims, x.shape);\n  if (xRank === 0) {\n    return identity({inputs: {x}, backend});\n  }\n\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new ReversePackedProgram(x.shape, $dims) :\n      new ReverseProgram(x.shape, $dims);\n\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const reverseConfig: KernelConfig = {\n  kernelName: Reverse,\n  backendName: 'webgl',\n  kernelFunc: reverse as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class RotateProgram implements GPGPUProgram {\n  variableNames = ['Image'];\n  outputShape: number[] = [];\n  userCode: string;\n  paramsLoc: WebGLUniformLocation;\n  constructor(\n      imageShape: [number, number, number, number],\n      fillValue: number|[number, number, number]) {\n    const imageHeight = imageShape[1];\n    const imageWidth = imageShape[2];\n    this.outputShape = imageShape;\n\n    let fillSnippet = '';\n    if (typeof fillValue === 'number') {\n      fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;\n    } else {\n      fillSnippet = `\n        vec3 fill = vec3(${fillValue.join(',')});\n        float outputValue = fill[coords[3]];`;\n    }\n\n    this.userCode = `\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${fillSnippet}\n          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${\n        imageHeight}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n  }\n\n  getCustomSetupFunc(\n      centerX: number, centerY: number, sinFactor: number, cosFactor: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.paramsLoc == null) {\n        this.paramsLoc =\n            gpgpu.getUniformLocationNoThrow(webGLProgram, 'params');\n      }\n      gpgpu.gl.uniform4f(\n          this.paramsLoc, centerX, centerY, sinFactor, cosFactor);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Tensor4D} from '@tensorflow/tfjs-core';\nimport {RotateWithOffset, RotateWithOffsetAttrs, RotateWithOffsetInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {RotateProgram} from '../rotate_gpu';\n\nexport const rotateWithOffsetConfig: KernelConfig = {\n  kernelName: RotateWithOffset,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {image} = inputs as RotateWithOffsetInputs;\n    const {radians, fillValue, center} = attrs as {} as RotateWithOffsetAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const program = new RotateProgram((image as Tensor4D).shape, fillValue);\n    const [centerX, centerY] =\n        backend_util.getImageCenter(center, image.shape[1], image.shape[2]);\n    const customSetup = program.getCustomSetupFunc(\n        centerX, centerY, Math.sin(radians), Math.cos(radians));\n    const output = webglBackend.runWebGLProgram(\n        program, [image], image.dtype, customSetup);\n    return output;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Round} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst ROUND = `\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;\n\nexport const round = unaryKernelFunc({opSnippet: ROUND});\n\nexport const roundConfig: KernelConfig = {\n  kernelName: Round,\n  backendName: 'webgl',\n  kernelFunc: round,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Rsqrt} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {rsqrtImplCPU} from '../kernel_utils/shared';\n\nconst RSQRT = `return inversesqrt(x);`;\n\nexport const rsqrt =\n    unaryKernelFunc({opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU});\n\nexport const rsqrtConfig: KernelConfig = {\n  kernelName: Rsqrt,\n  backendName: 'webgl',\n  kernelFunc: rsqrt as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ScatterProgram implements GPGPUProgram {\n  variableNames = ['updates', 'indices', 'defaultValue'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      updateSize: number, sliceDim: number, indicesRank: number,\n      updatesRank: number, strides: number[], shape: number[],\n      summingDupeIndex = true) {\n    this.outputShape = shape;\n    const stridesType = getCoordsDataType(strides.length);\n    const dtype = getCoordsDataType(shape.length);\n    let indicesString = '';\n    if (indicesRank === 1) {\n      indicesString = 'i';\n    } else if (indicesRank === 2) {\n      indicesString = 'i, j';\n    }\n    const indicesSnippet = `getIndices(${indicesString})`;\n\n    let updatesString = '';\n    if (updatesRank === 1) {\n      updatesString = 'i';\n    } else if (updatesRank === 2) {\n      updatesString = 'i, coords[1]';\n    }\n    const updatesSnippet = `getUpdates(${updatesString})`;\n\n    const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n    this.userCode = `\n        ${stridesType} strides = ${stridesType}(${strides});\n\n        void main() {\n          ${dtype} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${updateSize}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${sliceDim}; j++) {\n              int index = round(${indicesSnippet});\n              flattenedIndex += index * ${strideString};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${updatesSnippet};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, ScatterNd, ScatterNdAttrs, ScatterNdInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ScatterProgram} from '../scatter_gpu';\nimport {reshape} from './Reshape';\n\nexport function scatterNd(args: {\n  inputs: ScatterNdInputs,\n  backend: MathBackendWebGL,\n  attrs: ScatterNdAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {indices, updates} = inputs;\n  const {shape} = attrs;\n\n  const {sliceRank, numUpdates, sliceSize, strides, outputSize} =\n      backend_util.calculateShapes(updates, indices, shape);\n\n  const flattenShape = [outputSize / sliceSize, sliceSize];\n\n  if (outputSize === 0) {\n    return backend.makeTensorInfo(shape, indices.dtype);\n  }\n\n  const flattenIndices = reshape(\n      {inputs: {x: indices}, backend, attrs: {shape: [numUpdates, sliceRank]}});\n  const flattenX = reshape(\n      {inputs: {x: updates}, backend, attrs: {shape: [numUpdates, sliceSize]}});\n\n  const defaultValue = backend.makeTensorInfo(\n      [], 'float32', new Float32Array([0]));  // scalar(0)\n  const program = new ScatterProgram(\n      numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length,\n      strides, flattenShape);\n  const res = backend.runWebGLProgram(\n      program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);\n\n  const reshaped = reshape({inputs: {x: res}, backend, attrs: {shape}});\n\n  backend.disposeIntermediateTensorInfo(flattenIndices);\n  backend.disposeIntermediateTensorInfo(flattenX);\n  backend.disposeIntermediateTensorInfo(res);\n  backend.disposeIntermediateTensorInfo(defaultValue);\n\n  return reshaped;\n}\n\nexport const scatterNdConfig: KernelConfig = {\n  kernelName: ScatterNd,\n  backendName: 'webgl',\n  kernelFunc: scatterNd as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SelectProgram implements GPGPUProgram {\n  variableNames = ['c', 'a', 'b'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(cRank: number, shape: number[], rank: number) {\n    this.outputShape = shape;\n\n    let cCoords;\n    let abCoords;\n    if (rank > 4) {\n      throw Error(`Where for rank ${rank} is not yet supported`);\n    }\n\n    if (rank === 1) {\n      abCoords = `resRC`;\n      cCoords = `resRC`;\n    } else {\n      const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n      const cCoordVars = [];\n      const abCoordVars = [];\n      for (let i = 0; i < shape.length; i++) {\n        abCoordVars.push(`${currentCoords[i]}`);\n        if (i < cRank) {\n          cCoordVars.push(`${currentCoords[i]}`);\n        }\n      }\n      cCoords = cCoordVars.join();\n      abCoords = abCoordVars.join();\n    }\n\n    const dtype = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        float cVal = getC(${cCoords});\n        if (cVal >= 1.0) {\n          setOutput(getA(${abCoords}));\n        } else {\n          setOutput(getB(${abCoords}));\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Select, SelectInputs, TensorInfo, upcastType} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SelectProgram} from '../select_gpu';\n\nexport function select(args: {inputs: SelectInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {condition, t, e} = inputs;\n\n  const program =\n      new SelectProgram(condition.shape.length, t.shape, t.shape.length);\n  return backend.runWebGLProgram(\n      program, [condition, t, e], upcastType(t.dtype, e.dtype));\n}\n\nexport const selectConfig: KernelConfig = {\n  kernelName: Select,\n  backendName: 'webgl',\n  kernelFunc: select as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Selu} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SELU = `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${backend_util.SELU_SCALEALPHA};\n  float scale = ${backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;\n\nexport const selu = unaryKernelFunc({opSnippet: SELU});\n\nexport const seluConfig: KernelConfig = {\n  kernelName: Selu,\n  backendName: 'webgl',\n  kernelFunc: selu,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sigmoid} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n\nexport const sigmoid = unaryKernelFunc({opSnippet: SIGMOID});\n\nexport const sigmoidConfig: KernelConfig = {\n  kernelName: Sigmoid,\n  backendName: 'webgl',\n  kernelFunc: sigmoid,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sign} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\n// Sign does not propagate NANs.\nconst SIGN = `\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;\n\nexport const sign = unaryKernelFunc({opSnippet: SIGN});\n\nexport const signConfig: KernelConfig = {\n  kernelName: Sign,\n  backendName: 'webgl',\n  kernelFunc: sign,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sin} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SIN = CHECK_NAN_SNIPPET_UNARY + `\n  return sin(x);\n`;\n\nexport const sin = unaryKernelFunc({opSnippet: SIN});\n\nexport const sinConfig: KernelConfig = {\n  kernelName: Sin,\n  backendName: 'webgl',\n  kernelFunc: sin,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sinh} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SINH = `\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\n\nexport const sinh = unaryKernelFunc({opSnippet: SINH});\n\nexport const sinhConfig: KernelConfig = {\n  kernelName: Sinh,\n  backendName: 'webgl',\n  kernelFunc: sinh,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Softplus} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SOFTPLUS = `\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;\n\nexport const softplus = unaryKernelFunc({opSnippet: SOFTPLUS});\n\nexport const softplusConfig: KernelConfig = {\n  kernelName: Softplus,\n  backendName: 'webgl',\n  kernelFunc: softplus,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SpaceToBatchND, SpaceToBatchNDAttrs, SpaceToBatchNDInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {padV2} from './PadV2';\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport const spaceToBatchND = (args: {\n  inputs: SpaceToBatchNDInputs,\n  backend: MathBackendWebGL,\n  attrs: SpaceToBatchNDAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockShape, paddings} = attrs;\n\n  util.assert(\n      x.shape.length <= 4,\n      () => 'spaceToBatchND for rank > 4 with a WebGL backend not ' +\n          'implemented yet');\n\n  const prod = blockShape.reduce((a, b) => a * b);\n\n  const completePaddings: Array<[number, number]> = [[0, 0]];\n  completePaddings.push(...paddings as Array<[number, number]>);\n  for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n    completePaddings.push([0, 0]);\n  }\n\n  const toDispose = [];\n\n  const paddedX = padV2({\n    inputs: {x},\n    backend,\n    attrs: {paddings: completePaddings, constantValue: 0}\n  });\n\n  const reshapedPaddedShape =\n      backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n\n  const permutedReshapedPaddedPermutation = backend_util.getPermuted(\n      reshapedPaddedShape.length, blockShape.length, false);\n\n  const flattenShape =\n      backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n\n  const reshapedPaddedX = reshape(\n      {inputs: {x: paddedX}, backend, attrs: {shape: reshapedPaddedShape}});\n\n  const paddedXT = transpose({\n    inputs: {x: reshapedPaddedX},\n    backend,\n    attrs: {perm: permutedReshapedPaddedPermutation}\n  });\n\n  const result =\n      reshape({inputs: {x: paddedXT}, backend, attrs: {shape: flattenShape}});\n\n  toDispose.push(paddedX);\n  toDispose.push(reshapedPaddedX);\n  toDispose.push(paddedXT);\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return result;\n};\n\nexport const spaceToBatchNDConfig: KernelConfig = {\n  kernelName: SpaceToBatchND,\n  backendName: 'webgl',\n  kernelFunc: spaceToBatchND as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, SparseFillEmptyRows, SparseFillEmptyRowsInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sparseFillEmptyRowsImplCPU} from '../kernel_utils/shared';\n\nexport function sparseFillEmptyRows(args: {\n  inputs: SparseFillEmptyRowsInputs,\n  backend: MathBackendWebGL\n}): [TensorInfo, TensorInfo, TensorInfo, TensorInfo] {\n  const {inputs, backend} = args;\n  const {indices, values, denseShape, defaultValue} = inputs;\n  if (denseShape.shape.length !== 1) {\n    throw new Error(`Dense shape must be a vector, saw:\n         ${denseShape.shape}`);\n  }\n  if (indices.shape.length !== 2) {\n    throw new Error(`Indices must be a matrix, saw:\n         ${indices.shape}`);\n  }\n  if (values.shape.length !== 1) {\n    throw new Error(`Values must be a vector, saw:\n         ${values.shape}`);\n  }\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(`Default value must be a scalar, saw:\n        ${defaultValue.shape}`);\n  }\n\n  const $indices = backend.readSync(indices.dataId) as TypedArray;\n  const $values = backend.readSync(values.dataId) as TypedArray;\n  const $denseShape = backend.readSync(denseShape.dataId) as TypedArray;\n  const $defaultValue =\n      backend.readSync(defaultValue.dataId)[0] as number;\n\n  const [outputIndices, outputIndicesShape, outputValues,\n         emptyRowIndicator, reverseIndexMap] =\n      sparseFillEmptyRowsImplCPU(\n          $indices, indices.shape, indices.dtype, $values, values.dtype,\n          $denseShape, $defaultValue);\n  return [\n    backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),\n    backend.makeTensorInfo(\n        [outputIndicesShape[0]], values.dtype, outputValues),\n    backend.makeTensorInfo(\n        [emptyRowIndicator.length], 'bool',\n        new Uint8Array(\n            emptyRowIndicator.map((value: boolean) => Number(value)))),\n    backend.makeTensorInfo(\n        [reverseIndexMap.length], indices.dtype,\n        new Int32Array(reverseIndexMap)),\n  ];\n}\n\nexport const sparseFillEmptyRowsConfig: KernelConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'webgl',\n  kernelFunc: sparseFillEmptyRows as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SparseReshape, SparseReshapeInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sparseReshapeImplCPU} from '../kernel_utils/shared';\n\nexport function sparseReshape(\n    args: {inputs: SparseReshapeInputs, backend: MathBackendWebGL}):\n    [TensorInfo, TensorInfo] {\n  const {inputs, backend} = args;\n  const {inputIndices, inputShape, newShape} = inputs;\n  if (inputIndices.shape.length !== 2) {\n    throw new Error(`Input indices should be a matrix but received shape ${\n        inputIndices.shape}`);\n  }\n  if (inputShape.shape.length !== 1) {\n    throw new Error(`Input shape should be a vector but received shape ${\n        inputShape.shape}`);\n  }\n\n  if (newShape.shape.length !== 1) {\n    throw new Error(\n        `Target shape should be a vector but received shape ${newShape.shape}`);\n  }\n\n  const $inputShape =\n      Array.from(backend.readSync(inputShape.dataId) as TypedArray);\n  const $inputIndices = backend.readSync(inputIndices.dataId) as TypedArray;\n  const targetShape =\n      Array.from(backend.readSync(newShape.dataId) as TypedArray);\n\n  const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU(\n      $inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape,\n      targetShape);\n  return [\n    backend.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),\n    backend.makeTensorInfo(\n        [outputShape.length], newShape.dtype, new Int32Array(outputShape)),\n  ];\n}\n\nexport const sparseReshapeConfig: KernelConfig = {\n  kernelName: SparseReshape,\n  backendName: 'webgl',\n  kernelFunc: sparseReshape,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SparseToDense, SparseToDenseAttrs, SparseToDenseInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ScatterProgram} from '../scatter_gpu';\nimport {reshape} from './Reshape';\n\nexport function sparseToDense(args: {\n  inputs: SparseToDenseInputs,\n  backend: MathBackendWebGL,\n  attrs: SparseToDenseAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {sparseIndices, sparseValues, defaultValue} = inputs;\n  const {outputShape} = attrs;\n\n  const {sliceRank, numUpdates, strides, outputSize} =\n      backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n\n  const sumDupeIndices = false;\n  const program = new ScatterProgram(\n      numUpdates, sliceRank, sparseIndices.shape.length,\n      sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);\n\n  const res = backend.runWebGLProgram(\n      program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);\n\n  const reshaped =\n      reshape({inputs: {x: res}, backend, attrs: {shape: outputShape}});\n\n  backend.disposeIntermediateTensorInfo(res);\n  return reshaped;\n}\n\nexport const sparseToDenseConfig: KernelConfig = {\n  kernelName: SparseToDense,\n  backendName: 'webgl',\n  kernelFunc: sparseToDense as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SplitV, SplitVAttrs, SplitVInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {slice} from './Slice';\n\nexport function splitV(\n    args:\n        {inputs: SplitVInputs, backend: MathBackendWebGL, attrs: SplitVAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {numOrSizeSplits, axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, x.shape)[0];\n  const splitSizes = backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);\n\n  const xRank = x.shape.length;\n  const begin = new Array(xRank).fill(0);\n  const size = x.shape.slice();\n\n  return splitSizes.map(s => {\n    const sliceSize = [...size];\n    sliceSize[$axis] = s;\n    const sliceT =\n        slice({inputs: {x}, backend, attrs: {begin, size: sliceSize}});\n    begin[$axis] += s;\n    return sliceT;\n  });\n}\n\nexport const splitVConfig: KernelConfig = {\n  kernelName: SplitV,\n  backendName: 'webgl',\n  kernelFunc: splitV as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Sqrt} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SQRT = `return sqrt(x);`;\n\nexport const sqrt = unaryKernelFunc({opSnippet: SQRT});\n\nexport const sqrtConfig: KernelConfig = {\n  kernelName: Sqrt,\n  backendName: 'webgl',\n  kernelFunc: sqrt as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Square} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SQUARE = `return x * x;`;\n\nexport const square = unaryKernelFunc({opSnippet: SQUARE});\n\nexport const squareConfig: KernelConfig = {\n  kernelName: Square,\n  backendName: 'webgl',\n  kernelFunc: square,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SquaredDifference} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\n\nexport const squaredDifference = binaryKernelFunc(\n    {opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE});\n\nexport const squaredDifferenceConfig: KernelConfig = {\n  kernelName: SquaredDifference,\n  backendName: 'webgl',\n  kernelFunc: squaredDifference,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Step, StepAttrs, TensorInfo, UnaryInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CHECK_NAN_SNIPPET, UnaryOpProgram} from '../unaryop_gpu';\n\nexport function step(\n    {inputs, attrs, backend}:\n        {inputs: UnaryInputs, attrs: StepAttrs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {x} = inputs;\n  const opSnippet = CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${attrs.alpha});\n  `;\n\n  const program = new UnaryOpProgram(x.shape, opSnippet);\n\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const stepConfig: KernelConfig = {\n  kernelName: Step,\n  backendName: 'webgl',\n  kernelFunc: step as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class StridedSliceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(begin: number[], strides: number[], size: number[]) {\n    this.outputShape = size;\n    const rank = size.length;\n    const inputDtype = getCoordsDataType(size.length);\n    const dtype = getCoordsDataType(size.length);\n\n    let newCoords = '';\n    if (rank === 1) {\n      newCoords = 'coords * strides + begin';\n    } else {\n      let outputAxis = 0;\n      newCoords =\n          size.map((_, i) => {\n                outputAxis++;\n                return size.length === 1 ?\n                    `coords * strides[${i}] + begin[${i}]` :\n                    `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n              })\n              .join(',');\n    }\n\n    this.userCode = `\n      ${inputDtype} begin = ${inputDtype}(${begin});\n      ${inputDtype} strides = ${inputDtype}(${strides});\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        setOutput(getX(${newCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, KernelConfig, KernelFunc, Rank, slice_util, StridedSlice, StridedSliceAttrs, StridedSliceInputs, TensorBuffer, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {stridedSliceImplCPU} from '../kernel_utils/shared';\nimport {StridedSliceProgram} from '../strided_slice_gpu';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nexport function stridedSlice(args: {\n  inputs: StridedSliceInputs,\n  backend: MathBackendWebGL,\n  attrs: StridedSliceAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {\n    begin,\n    end,\n    strides,\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  } = attrs;\n\n  const {nonStrided, $begin, $strides, size, newShape, outShape} =\n      slice_util.sliceInfo(\n          x.shape, begin, end, strides, beginMask, endMask, ellipsisMask,\n          newAxisMask, shrinkAxisMask);\n\n  const $x = reshape({inputs: {x}, backend, attrs: {shape: newShape}});\n\n  let result;\n  if (nonStrided) {\n    const sliced =\n        slice({inputs: {x: $x}, backend, attrs: {begin: $begin, size}});\n    result = reshape({inputs: {x: sliced}, backend, attrs: {shape: outShape}});\n\n    backend.disposeIntermediateTensorInfo(sliced);\n  } else if (outShape.some(axis => axis === 0)) {\n    result = backend.makeTensorInfo(outShape, x.dtype, []);\n  } else {\n    const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([$x]);\n    if (shouldExecuteOnCPU) {\n      const xTexData = backend.texData.get($x.dataId);\n      const values = xTexData.values as TypedArray;\n      const xBuf = buffer($x.shape, $x.dtype, values) as TensorBuffer<Rank>;\n      const resultValues =\n          stridedSliceImplCPU(outShape, xBuf, $strides, $begin);\n      result = backend.makeTensorInfo(outShape, $x.dtype, resultValues.values);\n    } else {\n      const program = new StridedSliceProgram($begin, $strides, outShape);\n      result = backend.runWebGLProgram(program, [$x], $x.dtype);\n    }\n  }\n\n  const resultReshaped =\n      reshape({inputs: {x: result}, backend, attrs: {shape: outShape}});\n\n  backend.disposeIntermediateTensorInfo($x);\n  backend.disposeIntermediateTensorInfo(result);\n\n  return resultReshaped;\n}\n\nexport const stridedSliceConfig: KernelConfig = {\n  kernelName: StridedSlice,\n  backendName: 'webgl',\n  kernelFunc: stridedSlice as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tan} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst TAN = `return tan(x);`;\n\nexport const tan = unaryKernelFunc({opSnippet: TAN});\n\nexport const tanConfig: KernelConfig = {\n  kernelName: Tan,\n  backendName: 'webgl',\n  kernelFunc: tan,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tanh} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst TANH = `\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;\n\nexport const tanh = unaryKernelFunc({opSnippet: TANH});\n\nexport const tanhConfig: KernelConfig = {\n  kernelName: Tanh,\n  backendName: 'webgl',\n  kernelFunc: tanh,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TileProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], reps: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[i] * reps[i];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\nfunction getSourceCoords(aShape: number[]): string {\n  const rank = aShape.length;\n  if (rank > 5) {\n    throw Error(`Tile for rank ${rank} is not yet supported`);\n  }\n  if (rank === 1) {\n    return `imod(resRC, ${aShape[0]})`;\n  }\n\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, KernelConfig, KernelFunc, TensorInfo, Tile, TileAttrs, TileInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {tileImplCPU} from '../kernel_utils/shared';\nimport {TileProgram} from '../tile_gpu';\n\nexport function tile(\n    params: {inputs: TileInputs, backend: MathBackendWebGL, attrs: TileAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = params;\n  const {x} = inputs;\n  const {reps} = attrs;\n\n  // tile gpu program cannot handle rank > 5 case.\n  if (x.dtype === 'string' || x.shape.length > 5) {\n    // Even thought string tensor is always on CPU, just to be consistent on how\n    // to access tensor data.\n    const data = backend.readSync(x.dataId);\n    const value = x.dtype === 'string' ?\n        (data as Uint8Array[]).map(d => util.decodeString(d)) :\n        data as TypedArray;\n    const buf = buffer(x.shape, x.dtype, value);\n    const outBuf = tileImplCPU(buf, reps);\n    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n  }\n\n  const program = new TileProgram(x.shape, reps);\n  const output = backend.runWebGLProgram(program, [x], x.dtype);\n\n  return output;\n}\n\nexport const tileConfig: KernelConfig = {\n  kernelName: Tile,\n  backendName: 'webgl',\n  kernelFunc: tile as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, NumericDataType, TensorInfo, TopK, TopKAttrs, TopKInputs, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {topKImplCPU} from '../kernel_utils/shared';\n\nexport function topK(\n    args: {inputs: TopKInputs, backend: MathBackendWebGL, attrs: TopKAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {k, sorted} = attrs;\n\n  const xVals = backend.readSync(x.dataId) as TypedArray;\n  const [allTopKVals, allTopKIndices] =\n      topKImplCPU(xVals, x.shape, x.dtype as NumericDataType, k, sorted);\n\n  return [\n    backend.makeTensorInfo(\n        allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n    backend.makeTensorInfo(\n        allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n  ];\n}\n\nexport const topKConfig: KernelConfig = {\n  kernelName: TopK,\n  backendName: 'webgl',\n  kernelFunc: topK as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class TransformProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Transforms'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      imageHeight: number, imageWidth: number,\n      interpolation: 'nearest'|'bilinear',\n      fillMode: 'constant'|'reflect'|'wrap'|'nearest', fillValue: number,\n      outShape: [number, number, number, number]) {\n    this.outputShape = outShape;\n    const interpolationModeId = interpolation === 'nearest' ? 1 : 2;\n    let fillModeId;\n    switch (fillMode) {\n      case 'constant':\n        fillModeId = 1;\n        break;\n      case 'reflect':\n        fillModeId = 2;\n        break;\n      case 'wrap':\n        fillModeId = 3;\n        break;\n      case 'nearest':\n        fillModeId = 4;\n        break;\n      default:\n        fillModeId = 1;\n        break;\n    }\n    this.userCode = `\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${fillModeId} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${fillModeId} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${fillModeId} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${\n        imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${fillValue});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${fillValue});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${imageWidth}));\n                float mapY = mapCoord(inY, float(${imageHeight}));\n\n                if (${interpolationModeId} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Transform, TransformAttrs, TransformInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {TransformProgram} from '../transform_gpu';\n\nexport function transform(args: {\n  inputs: TransformInputs,\n  backend: MathBackendWebGL,\n  attrs: TransformAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {image, transforms} = inputs;\n  const {interpolation, fillMode, fillValue, outputShape} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] =\n      outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape =\n      [batch, outHeight, outWidth,\n       numChannels] as [number, number, number, number];\n\n  const program = new TransformProgram(\n      imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);\n  return backend.runWebGLProgram(program, [image, transforms], 'float32');\n}\n\nexport const transformConfig: KernelConfig = {\n  kernelName: Transform,\n  backendName: 'webgl',\n  kernelFunc: transform as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Unique, UniqueAttrs, UniqueInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {uniqueImplCPU} from '../kernel_utils/shared';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function unique(\n    args:\n        {inputs: UniqueInputs, attrs: UniqueAttrs, backend: MathBackendWebGL}):\n    TensorInfo[] {\n  const {inputs, attrs, backend} = args;\n  const {axis} = attrs;\n  const {x} = inputs;\n  assertNotComplex(x, 'unique');\n\n  // For now, always forward calculation to the CPU backend.\n  console.warn(\n      'WARNING: ',\n      'UI might be locked temporarily as data is being downloaded');\n  const values = backend.readSync(x.dataId);\n  const {outputValues, outputShape, indices} =\n      uniqueImplCPU(values, axis, x.shape, x.dtype);\n  return [\n    backend.makeTensorInfo(outputShape, x.dtype, outputValues),\n    backend.makeTensorInfo([indices.length], 'int32', indices),\n  ];\n}\n\nexport const uniqueConfig: KernelConfig = {\n  kernelName: Unique,\n  backendName: 'webgl',\n  kernelFunc: unique as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Unpack, UnpackAttrs, UnpackInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nexport function unpack(\n    args:\n        {inputs: UnpackInputs, backend: MathBackendWebGL, attrs: UnpackAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {value} = inputs;\n  let {axis} = attrs;\n\n  if (axis < 0) {\n    axis += value.shape.length;\n  }\n\n  const x = value;\n  const xRank = x.shape.length;\n\n  const num = value.shape[axis];\n  const outShape: number[] = new Array(xRank - 1);\n  let outIndex = 0;\n  for (let i = 0; i < xRank; i++) {\n    if (i !== axis) {\n      outShape[outIndex++] = x.shape[i];\n    }\n  }\n\n  const toDispose = [];\n\n  const begin = new Array(xRank).fill(0);\n  const size = x.shape.slice();\n  size[axis] = 1;\n  const res: TensorInfo[] = new Array(num);\n  for (let i = 0; i < res.length; i++) {\n    begin[axis] = i;\n    const sliced = slice({inputs: {x}, backend, attrs: {begin, size}});\n    const reshaped =\n        reshape({inputs: {x: sliced}, backend, attrs: {shape: outShape}});\n    res[i] = reshaped;\n\n    toDispose.push(sliced);\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return res;\n}\n\nexport const unpackConfig: KernelConfig = {\n  kernelName: Unpack,\n  backendName: 'webgl',\n  kernelFunc: unpack as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class SegmentOpProgram implements GPGPUProgram {\n  variableNames = ['x', 'segmentIds'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      segOpInfo: backend_util.segment_util.SegOpInfo,\n      segOpType: 'unsortedSegmentSum') {\n    const windowSize = segOpInfo.windowSize;\n    const batchSize = segOpInfo.batchSize;\n    const inSize = segOpInfo.inSize;\n    const numSegments = segOpInfo.numSegments;\n    const outSize = numSegments * Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n\n    const initializationValue = '0.0';\n    const returnValue = `sumValue`;\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n\n    let checkValueOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n\n    let checkSegmentIdOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {KernelConfig, registerKernel} from '@tensorflow/tfjs-core';\n\nimport {_fusedMatMulConfig} from './kernels/_FusedMatMul';\nimport {absConfig} from './kernels/Abs';\nimport {acosConfig} from './kernels/Acos';\nimport {acoshConfig} from './kernels/Acosh';\nimport {addConfig} from './kernels/Add';\nimport {addNConfig} from './kernels/AddN';\nimport {allConfig} from './kernels/All';\nimport {anyConfig} from './kernels/Any';\nimport {argMaxConfig} from './kernels/ArgMax';\nimport {argMinConfig} from './kernels/ArgMin';\nimport {asinConfig} from './kernels/Asin';\nimport {asinhConfig} from './kernels/Asinh';\nimport {atanConfig} from './kernels/Atan';\nimport {atan2Config} from './kernels/Atan2';\nimport {atanhConfig} from './kernels/Atanh';\nimport {avgPoolConfig} from './kernels/AvgPool';\nimport {avgPool3DConfig} from './kernels/AvgPool3D';\nimport {avgPoolGrad3DConfig} from './kernels/AvgPool3DGrad';\nimport {avgPoolGradConfig} from './kernels/AvgPoolGrad';\nimport {batchMatMulConfig} from './kernels/BatchMatMul';\nimport {batchNormConfig} from './kernels/BatchNorm';\nimport {batchToSpaceNDConfig} from './kernels/BatchToSpaceND';\nimport {bincountConfig} from './kernels/Bincount';\nimport {castConfig} from './kernels/Cast';\nimport {ceilConfig} from './kernels/Ceil';\nimport {clipByValueConfig} from './kernels/ClipByValue';\nimport {complexConfig} from './kernels/Complex';\nimport {complexAbsConfig} from './kernels/ComplexAbs';\nimport {concatConfig} from './kernels/Concat';\nimport {conv2DConfig} from './kernels/Conv2D';\nimport {conv2DBackpropFilterConfig} from './kernels/Conv2DBackpropFilter';\nimport {conv2DBackpropInputConfig} from './kernels/Conv2DBackpropInput';\nimport {conv3DConfig} from './kernels/Conv3D';\nimport {conv3DBackpropFilterV2Config} from './kernels/Conv3DBackpropFilterV2';\nimport {conv3DBackpropInputConfig} from './kernels/Conv3DBackpropInputV2';\nimport {cosConfig} from './kernels/Cos';\nimport {coshConfig} from './kernels/Cosh';\nimport {cropAndResizeConfig} from './kernels/CropAndResize';\nimport {cumsumConfig} from './kernels/Cumsum';\nimport {denseBincountConfig} from './kernels/DenseBincount';\nimport {depthToSpaceConfig} from './kernels/DepthToSpace';\nimport {depthwiseConv2dNativeConfig} from './kernels/DepthwiseConv2dNative';\nimport {depthwiseConv2dNativeBackpropFilterConfig} from './kernels/DepthwiseConv2dNativeBackpropFilter';\nimport {depthwiseConv2dNativeBackpropInputConfig} from './kernels/DepthwiseConv2dNativeBackpropInput';\nimport {diagConfig} from './kernels/Diag';\nimport {dilation2DConfig} from './kernels/Dilation2D';\nimport {einsumConfig} from './kernels/Einsum';\nimport {eluConfig} from './kernels/Elu';\nimport {eluGradConfig} from './kernels/EluGrad';\nimport {equalConfig} from './kernels/Equal';\nimport {erfConfig} from './kernels/Erf';\nimport {expConfig} from './kernels/Exp';\nimport {expandDimsConfig} from './kernels/ExpandDims';\nimport {expm1Config} from './kernels/Expm1';\nimport {fftConfig} from './kernels/FFT';\nimport {fillConfig} from './kernels/Fill';\nimport {flipLeftRightConfig} from './kernels/FlipLeftRight';\nimport {floorConfig} from './kernels/Floor';\nimport {floorDivConfig} from './kernels/FloorDiv';\nimport {fromPixelsConfig} from './kernels/FromPixels';\nimport {fusedConv2DConfig} from './kernels/FusedConv2D';\nimport {fusedDepthwiseConv2DConfig} from './kernels/FusedDepthwiseConv2D';\nimport {gatherNdConfig} from './kernels/GatherNd';\nimport {gatherV2Config} from './kernels/GatherV2';\nimport {greaterConfig} from './kernels/Greater';\nimport {greaterEqualConfig} from './kernels/GreaterEqual';\nimport {identityConfig} from './kernels/Identity';\nimport {ifftConfig} from './kernels/IFFT';\nimport {imagConfig} from './kernels/Imag';\nimport {isFiniteConfig} from './kernels/IsFinite';\nimport {isInfConfig} from './kernels/IsInf';\nimport {isNaNConfig} from './kernels/IsNaN';\nimport {leakyReluConfig} from './kernels/LeakyRelu';\nimport {lessConfig} from './kernels/Less';\nimport {lessEqualConfig} from './kernels/LessEqual';\nimport {linSpaceConfig} from './kernels/LinSpace';\nimport {logConfig} from './kernels/Log';\nimport {log1pConfig} from './kernels/Log1p';\nimport {logicalAndConfig} from './kernels/LogicalAnd';\nimport {logicalNotConfig} from './kernels/LogicalNot';\nimport {logicalOrConfig} from './kernels/LogicalOr';\nimport {LRNConfig} from './kernels/LRN';\nimport {LRNGradConfig} from './kernels/LRNGrad';\nimport {maxConfig} from './kernels/Max';\nimport {maximumConfig} from './kernels/Maximum';\nimport {maxPoolConfig} from './kernels/MaxPool';\nimport {maxPool3DConfig} from './kernels/MaxPool3D';\nimport {maxPoolGrad3DConfig} from './kernels/MaxPool3DGrad';\nimport {maxPoolGradConfig} from './kernels/MaxPoolGrad';\nimport {maxPoolWithArgmaxConfig} from './kernels/MaxPoolWithArgmax';\nimport {meanConfig} from './kernels/Mean';\nimport {minConfig} from './kernels/Min';\nimport {minimumConfig} from './kernels/Minimum';\nimport {mirrorPadConfig} from './kernels/MirrorPad';\nimport {modConfig} from './kernels/Mod';\nimport {multinomialConfig} from './kernels/Multinomial';\nimport {multiplyConfig} from './kernels/Multiply';\nimport {negConfig} from './kernels/Neg';\nimport {nonMaxSuppressionV3Config} from './kernels/NonMaxSuppressionV3';\nimport {nonMaxSuppressionV4Config} from './kernels/NonMaxSuppressionV4';\nimport {nonMaxSuppressionV5Config} from './kernels/NonMaxSuppressionV5';\nimport {notEqualConfig} from './kernels/NotEqual';\nimport {oneHotConfig} from './kernels/OneHot';\nimport {onesLikeConfig} from './kernels/OnesLike';\nimport {packConfig} from './kernels/Pack';\nimport {padV2Config} from './kernels/PadV2';\nimport {powConfig} from './kernels/Pow';\nimport {preluConfig} from './kernels/Prelu';\nimport {prodConfig} from './kernels/Prod';\nimport {rangeConfig} from './kernels/Range';\nimport {realConfig} from './kernels/Real';\nimport {realDivConfig} from './kernels/RealDiv';\nimport {reciprocalConfig} from './kernels/Reciprocal';\nimport {reluConfig} from './kernels/Relu';\nimport {relu6Config} from './kernels/Relu6';\nimport {reshapeConfig} from './kernels/Reshape';\nimport {resizeBilinearConfig} from './kernels/ResizeBilinear';\nimport {resizeBilinearGradConfig} from './kernels/ResizeBilinearGrad';\nimport {resizeNearestNeighborConfig} from './kernels/ResizeNearestNeighbor';\nimport {resizeNearestNeighborGradConfig} from './kernels/ResizeNearestNeighborGrad';\nimport {reverseConfig} from './kernels/Reverse';\nimport {rotateWithOffsetConfig} from './kernels/RotateWithOffset';\nimport {roundConfig} from './kernels/Round';\nimport {rsqrtConfig} from './kernels/Rsqrt';\nimport {scatterNdConfig} from './kernels/ScatterNd';\nimport {selectConfig} from './kernels/Select';\nimport {seluConfig} from './kernels/Selu';\nimport {sigmoidConfig} from './kernels/Sigmoid';\nimport {signConfig} from './kernels/Sign';\nimport {sinConfig} from './kernels/Sin';\nimport {sinhConfig} from './kernels/Sinh';\nimport {sliceConfig} from './kernels/Slice';\nimport {softmaxConfig} from './kernels/Softmax';\nimport {softplusConfig} from './kernels/Softplus';\nimport {spaceToBatchNDConfig} from './kernels/SpaceToBatchND';\nimport {sparseFillEmptyRowsConfig} from './kernels/SparseFillEmptyRows';\nimport {sparseReshapeConfig} from './kernels/SparseReshape';\nimport {sparseToDenseConfig} from './kernels/SparseToDense';\nimport {splitVConfig} from './kernels/SplitV';\nimport {sqrtConfig} from './kernels/Sqrt';\nimport {squareConfig} from './kernels/Square';\nimport {squaredDifferenceConfig} from './kernels/SquaredDifference';\nimport {stepConfig} from './kernels/Step';\nimport {stridedSliceConfig} from './kernels/StridedSlice';\nimport {subConfig} from './kernels/Sub';\nimport {sumConfig} from './kernels/Sum';\nimport {tanConfig} from './kernels/Tan';\nimport {tanhConfig} from './kernels/Tanh';\nimport {tileConfig} from './kernels/Tile';\nimport {topKConfig} from './kernels/TopK';\nimport {transformConfig} from './kernels/Transform';\nimport {transposeConfig} from './kernels/Transpose';\nimport {uniqueConfig} from './kernels/Unique';\nimport {unpackConfig} from './kernels/Unpack';\nimport {unsortedSegmentSumConfig} from './kernels/UnsortedSegmentSum';\nimport {zerosLikeConfig} from './kernels/ZerosLike';\n\n// List all kernel configs here\nconst kernelConfigs: KernelConfig[] = [\n  LRNConfig,\n  LRNGradConfig,\n  _fusedMatMulConfig,\n  absConfig,\n  acosConfig,\n  acoshConfig,\n  addConfig,\n  addNConfig,\n  allConfig,\n  anyConfig,\n  argMaxConfig,\n  argMinConfig,\n  asinConfig,\n  asinhConfig,\n  atan2Config,\n  atanConfig,\n  atanhConfig,\n  avgPool3DConfig,\n  avgPoolConfig,\n  avgPoolGrad3DConfig,\n  avgPoolGradConfig,\n  batchMatMulConfig,\n  batchNormConfig,\n  batchToSpaceNDConfig,\n  bincountConfig,\n  castConfig,\n  ceilConfig,\n  clipByValueConfig,\n  complexAbsConfig,\n  complexConfig,\n  concatConfig,\n  conv2DBackpropFilterConfig,\n  conv2DBackpropInputConfig,\n  conv2DConfig,\n  conv3DBackpropFilterV2Config,\n  conv3DBackpropInputConfig,\n  conv3DConfig,\n  cosConfig,\n  coshConfig,\n  cropAndResizeConfig,\n  cumsumConfig,\n  denseBincountConfig,\n  depthToSpaceConfig,\n  depthwiseConv2dNativeBackpropFilterConfig,\n  depthwiseConv2dNativeBackpropInputConfig,\n  depthwiseConv2dNativeConfig,\n  diagConfig,\n  dilation2DConfig,\n  einsumConfig,\n  eluConfig,\n  eluGradConfig,\n  equalConfig,\n  erfConfig,\n  expConfig,\n  expandDimsConfig,\n  expm1Config,\n  fftConfig,\n  fillConfig,\n  flipLeftRightConfig,\n  floorConfig,\n  floorDivConfig,\n  fromPixelsConfig,\n  fusedConv2DConfig,\n  fusedDepthwiseConv2DConfig,\n  gatherNdConfig,\n  gatherV2Config,\n  greaterConfig,\n  greaterEqualConfig,\n  identityConfig,\n  ifftConfig,\n  imagConfig,\n  isFiniteConfig,\n  isInfConfig,\n  isNaNConfig,\n  leakyReluConfig,\n  lessConfig,\n  lessEqualConfig,\n  linSpaceConfig,\n  log1pConfig,\n  logConfig,\n  logicalAndConfig,\n  logicalNotConfig,\n  logicalOrConfig,\n  maxConfig,\n  maxPool3DConfig,\n  maxPoolConfig,\n  maxPoolGrad3DConfig,\n  maxPoolGradConfig,\n  maxPoolWithArgmaxConfig,\n  maximumConfig,\n  meanConfig,\n  minConfig,\n  minimumConfig,\n  mirrorPadConfig,\n  modConfig,\n  multinomialConfig,\n  multiplyConfig,\n  negConfig,\n  nonMaxSuppressionV3Config,\n  nonMaxSuppressionV4Config,\n  nonMaxSuppressionV5Config,\n  notEqualConfig,\n  oneHotConfig,\n  onesLikeConfig,\n  packConfig,\n  padV2Config,\n  powConfig,\n  preluConfig,\n  prodConfig,\n  rangeConfig,\n  realConfig,\n  realDivConfig,\n  reciprocalConfig,\n  relu6Config,\n  reluConfig,\n  reshapeConfig,\n  resizeBilinearConfig,\n  resizeBilinearGradConfig,\n  resizeNearestNeighborConfig,\n  resizeNearestNeighborGradConfig,\n  reverseConfig,\n  rotateWithOffsetConfig,\n  roundConfig,\n  rsqrtConfig,\n  scatterNdConfig,\n  selectConfig,\n  seluConfig,\n  sigmoidConfig,\n  signConfig,\n  sinConfig,\n  sinhConfig,\n  sliceConfig,\n  softmaxConfig,\n  softplusConfig,\n  spaceToBatchNDConfig,\n  sparseFillEmptyRowsConfig,\n  sparseReshapeConfig,\n  sparseToDenseConfig,\n  splitVConfig,\n  sqrtConfig,\n  squareConfig,\n  squaredDifferenceConfig,\n  stepConfig,\n  stridedSliceConfig,\n  subConfig,\n  sumConfig,\n  tanConfig,\n  tanhConfig,\n  tileConfig,\n  topKConfig,\n  transformConfig,\n  transposeConfig,\n  uniqueConfig,\n  unpackConfig,\n  unsortedSegmentSumConfig,\n  zerosLikeConfig\n];\n\nfor (const kernelConfig of kernelConfigs) {\n  registerKernel(kernelConfig);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, sumOutType, TensorInfo, UnsortedSegmentSum, UnsortedSegmentSumAttrs, UnsortedSegmentSumInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SegmentOpProgram} from '../segment_gpu';\n\nimport {range} from './Range';\nimport {reshape} from './Reshape';\nimport {tile} from './Tile';\nimport {transpose} from './Transpose';\n\nexport function unsortedSegmentSum(args: {\n  inputs: UnsortedSegmentSumInputs,\n  backend: MathBackendWebGL,\n  attrs: UnsortedSegmentSumAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, segmentIds} = inputs;\n  const {numSegments} = attrs;\n\n  const xRank = x.shape.length;\n\n  const toDispose = [];\n\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n\n  const outShape = backend_util.segment_util.computeOutShape(\n      permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  toDispose.push(a2D);\n\n  const outputDType = sumOutType(x.dtype);\n\n  const segOpCompute =\n      (x: TensorInfo, segOpType: 'unsortedSegmentSum', segmentIds: TensorInfo,\n       dtype: DataType, numSegments: number): TensorInfo => {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize =\n            backend_util.segment_util.segOpComputeOptimalWindowSize(\n                inSize, numSegments);\n        const segOpInfo = {windowSize, inSize, batchSize, numSegments};\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n          return output;\n        }\n        const rangeInfo = range({\n          backend,\n          attrs: {start: 0, stop: numSegments, step: 1, dtype: 'float32'}\n        });\n        const tileInfo = tile({\n          inputs: {x: rangeInfo},\n          backend,\n          attrs: {reps: [inSize / windowSize]}\n        });\n\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n\n        const result =\n            segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n      };\n\n  const segOpResult = segOpCompute(\n      a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n\n  const reshaped =\n      reshape({inputs: {x: segOpResult}, backend, attrs: {shape: outShape}});\n\n  let result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({inputs: {x: result}, backend, attrs: {perm}});\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\n\nexport const unsortedSegmentSumConfig: KernelConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum as {} as KernelFunc\n};\n","/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '3.6.0';\nexport {version};\n"],"names":["PackingScheme","TextureUsage","PhysicalTextureType","contexts","WEBGL_ATTRIBUTES","alpha","antialias","premultipliedAlpha","preserveDrawingBuffer","depth","stencil","failIfMajorPerformanceCaveat","setWebGLContext","webGLVersion","gl","getWebGLContext","newCtx","Error","canvas","OffscreenCanvas","document","createElement","createCanvas","addEventListener","ev","preventDefault","getContext","getWebGLRenderingContext","console","log","isContextLost","disable","DEPTH_TEST","STENCIL_TEST","BLEND","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","enable","SCISSOR_TEST","CULL_FACE","cullFace","BACK","getUnpackedMatrixTextureShapeWidthHeight","rows","columns","getDenseTexShape","shape","size","util","sizeFromShape","texelsNeeded","Math","ceil","sizeToSquarishShape","getPackedMatrixTextureShapeWidthHeight","max","getTextureConfig","textureHalfFloatExtension","internalFormatFloat","internalFormatHalfFloat","internalFormatPackedHalfFloat","internalFormatPackedFloat","textureFormatFloat","downloadUnpackNumChannels","defaultNumChannels","textureTypeHalfFloat","textureTypeFloat","glany","env","getNumber","R32F","R16F","RGBA16F","RGBA32F","RED","HALF_FLOAT","FLOAT","RGBA","HALF_FLOAT_OES","downloadTextureFormat","callAndCheck","func","returnValue","getBool","error","getError","NO_ERROR","getWebGLErrorMessage","checkWebGLError","canBeRepresented","num","abs","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","getExtensionOrThrow","extensionName","throwIfNull","getExtension","createVertexShader","vertexShaderSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","createFragmentShader","fragmentShaderSource","fragmentShader","FRAGMENT_SHADER","shaderInfoLog","lineNumberRegexResult","lineNumberRegex","exec","lineNumber","shaderLines","split","pad","length","toString","linesWithLineNumbers","map","line","rightPad","maxLineLength","i","beforeErrorLines","slice","errorLine","afterErrorLines","join","logShaderSourceAndInfoLog","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","createProgram","linkProgram","program","getProgramParameter","LINK_STATUS","getProgramInfoLog","validateProgram","VALIDATE_STATUS","createStaticVertexBuffer","data","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createStaticIndexBuffer","ELEMENT_ARRAY_BUFFER","createTexture","validateTextureSize","width","height","maxTextureSize","requested","createFramebuffer","bindVertexBufferToProgramAttribute","attribute","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","loc","getAttribLocation","vertexAttribPointer","enableVertexAttribArray","bindTextureUnit","texture","textureUnit","validateTextureUnit","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","getProgramUniformLocationOrThrow","uniformName","getUniformLocation","getProgramUniformLocation","bindTextureToProgramUniformSampler","uniformSamplerLocation","uniform1i","bindColorTextureToFramebuffer","framebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","getFramebufferErrorMessage","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","returnTOrNull","failureMessage","tOrNull","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","getBatchDim","dimsToSkip","getRowsCols","getShapeAs3D","shapeAs3D","getTextureShapeFromLogicalShape","logShape","isPacked","maxTexSize","d","nearestLargerEven","squeezeResult","squeezeShape","newShape","batchDim","cols","_a","isEven","n","isReshapeFree","shape1","shape2","arraysEqual","shape1Cols","shape2Cols","getWebGLMaxTextureSize","getParameter","getMaxTexturesInShader","MAX_TEXTURE_IMAGE_UNITS","min","getWebGLDisjointQueryTimerVersion","hasExtension","isWebGLVersionEnabled","e","isCapableOfRenderingToFloatTexture","createFloatTextureAndBindToFramebuffer","isDownloadFloatTextureEnabled","COLOR_BUFFER_HALF_FLOAT","texConfig","texImage2D","frameBuffer","isFrameBufferComplete","deleteTexture","deleteFramebuffer","createHalfFloatTextureAndBindToFramebuffer","isWebGLFenceEnabled","fenceSync","assertNotComplex","tensor","opName","Array","isArray","forEach","t","assert","dtype","viewport","scissor","ENV","getGlslDifferences","version","varyingVs","varyingFs","texture2D","output","defineOutput","defineSpecialNaN","defineSpecialInf","defineRound","getLogicalCoordinatesFromFlatIndex","coords","index","strides","computeStrides","stride","getFlatIndexFrom3D","registerFlag","get","device_util","isMobile","threshold","ENCODE_FLOAT_SNIPPET","outputShape","this","DENSE","texShape","glsl","userCode","shader_util.getLogicalCoordinatesFromFlatIndex","DOWNLOAD","inputIsUnsignedByte","shader_util.getFlatIndexFrom3D","mainLoop","row","col","channel","webgl_util.createVertexShader","createVertexBuffer","webgl_util.createStaticVertexBuffer","Float32Array","createIndexBuffer","webgl_util.createStaticIndexBuffer","Uint16Array","createAndConfigureTexture","internalFormat","textureFormat","textureType","webgl_util.validateTextureSize","webgl_util.createTexture","tex2d","webgl_util.callAndCheck","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","getInternalFormatForFloat32MatrixTexture","textureConfig","createFloat32MatrixTexture","getInternalFormatForFloat16MatrixTexture","createFloat16MatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","createUnsignedBytesMatrixTexture","UNSIGNED_BYTE","getInternalFormatForPackedMatrixTexture","createPackedMatrixTexture","getInternalFormatForFloat16PackedMatrixTexture","createFloat16PackedMatrixTexture","bindVertexProgramAttributeStreams","vertexBuffer","webgl_util.bindVertexBufferToProgramAttribute","uploadDenseMatrixToTexture","dataForUpload","texelDataType","Uint8Array","set","uploadPixelDataToTexture","pixels","createBufferFromOutputTexture","gl2","PIXEL_PACK_BUFFER","bufferSizeBytes","bytesPerFloat","STREAM_READ","readPixels","downloadFloat32MatrixFromBuffer","downloadTarget","getBufferSubData","downloadByteEncodedFloatMatrixFromOutputTexture","w","h","downloadPackedMatrixFromBuffer","batch","physicalRows","physicalCols","tex_util.getPackedRGBAArraySizeFromMatrixShape","downloadMatrixFromPackedOutputTexture","packedRGBA","glVersion","COLOR_BUFFER_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","webgl_util.getExtensionOrThrow","webgl_util.hasExtension","colorBufferFloatExtension","colorBufferHalfFloatExtension","gpgpu_util.createVertexBuffer","indexBuffer","gpgpu_util.createIndexBuffer","webgl_util.createFramebuffer","tex_util.getTextureConfig","Object","GPGPUContext","disposed","warn","outputTexture","finish","_this","deleteBuffer","throwIfDisposed","gpgpu_util.createFloat32MatrixTexture","gpgpu_util.createFloat16MatrixTexture","gpgpu_util.createUnsignedBytesMatrixTexture","gpgpu_util.uploadPixelDataToTexture","gpgpu_util.uploadDenseMatrixToTexture","gpgpu_util.createFloat16PackedMatrixTexture","gpgpu_util.createPackedMatrixTexture","webgl_util.unbindColorTextureFromFramebuffer","downloadMatrixDriver","gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture","gpgpu_util.downloadPackedMatrixFromBuffer","gpgpu_util.downloadFloat32MatrixFromBuffer","bindTextureToFrameBuffer","result","gpgpu_util.createBufferFromOutputTexture","unbindTextureToFrameBuffer","fenceContext","createFence","pollFence","query","isFencePassed","gl2_1","sync_1","SYNC_GPU_COMMANDS_COMPLETE","flush","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","gpgpu_util.downloadMatrixFromPackedOutputTexture","webgl_util.createFragmentShader","gpgpu_util.createVertexShader","webgl_util.createProgram","attachShader","webgl_util.linkProgram","debug","webgl_util.validateProgram","vertexAttrsAreBound","setProgram","gpgpu_util.bindVertexProgramAttributeStreams","deleteProgram","useProgram","shouldThrow","webgl_util.getProgramUniformLocationOrThrow","webgl_util.getProgramUniformLocation","inputMatrixTexture","uniformLocation","throwIfNoProgram","webgl_util.bindTextureToProgramUniformSampler","outputMatrixTexture","setOutputMatrixTextureDriver","outputPackedMatrixTexture","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","webgl_util.validateFramebuffer","debugValidate","drawElements","TRIANGLES","UNSIGNED_SHORT","disjointQueryTimerExtension","getQueryTimerExtension","ext_1","getQueryTimerExtensionWebGL2","query_1","createQuery","TIME_ELAPSED_EXT","ext","getQueryTimerExtensionWebGL1","createQueryEXT","beginQueryEXT","endQueryEXT","ext_2","repeatedTry","getQueryTime","queryTimerVersion","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","Promise","resolve","addItemToPoll","arr","linearSearchLastTrue","itemsToPoll","x","isDoneFn","resolveFn","push","pollItems","webgl_util.bindColorTextureToFramebuffer","downloadAndDecode","outputMatrixTextureMaybePacked","y","getBroadcastDims","makeShader","inputsInfo","usesPackedTextures","prefixSnippets","shapeInfo","logicalShape","isUniform","name","outputSamplingSnippet","floatTextureSetOutputSnippet","inputPrefixSnippet","inputSamplingSnippet","inInfo","outShapeInfo","res","getPackedSamplerFromInInfo","getSamplerFromInInfo","inShape","outShape","inputInfo","coordsSnippet","texName","texFuncSnippet","charAt","toUpperCase","funcName","inRank","outRank","broadcastDims","type","getCoordsDataType","rankDiff","fields","unpackedCoordsSnippet","s","isInputScalar","isOutputScalar","indexOf","getPackedSamplerAtOutputCoords","outTexShape","inTexShape","flatOffset","getSamplerAtOutputCoords","getInputSamplingSnippet","floatTextureSampleSnippet","getFloatTextureSampleSnippet","shaderPrefix","SAMPLE_1D_SNIPPET","SAMPLE_2D_SNIPPET","SAMPLE_3D_SNIPPET","getShaderPrefix","packedTexShape","getOutputPacked1DCoords","texelsInLogicalRow","getOutputPacked2DCoords","texelsInBatch","texelsInBatchN","batches","b","getOutputPackedNDCoords","getPackedOutputSamplingSnippet","getFloatTextureSetRGBASnippet","getOutput1DCoords","getOutput2DCoords","coordsFromIndexSnippet","getOutput4DCoords","getOutput5DCoords","getOutput6DCoords","getOutputSamplingSnippet","getFloatTextureSetRSnippet","SHADER_PACKED_PREFIX","texNumR","texNumC","_b","tNumR","tNumC","offset","getFlatOffsetUniformName","getSamplerScalar","getUniformSampler","getSampler1D","texNumR_1","keptDims","squeezedShape","params","squeezeInputInfo","getSqueezedParams","getSampler2D","stride0","stride1","getSampler3D","stride2","getSampler4D","stride3","getSampler5D","stride4","getSampler6D","getPackedSampler1D","valuesPerRow","getPackedSampler2D","getPackedSampler3D","rank","getPackedSamplerND","inSize","newInputInfo","JSON","parse","stringify","validateBinaryAndProgram","shapeInfos","inputs","shapeA","input","shapeB","texShapeA","texShapeB","texData","createSimpleBinaryKernelImpl","op","aShape","bShape","aVals","bVals","backend_util","assertAndGetBroadcastShape","resultRank","resultStrides","resultSize","getTypedArrayFromDType","aRank","bRank","aStrides","bStrides","aBroadcastDims","bBroadcastDims","indexToLoc","aLoc","aIndex","locToIndex","bLoc","bIndex","addImpl","a","createSimpleUnaryImpl","values","attrs","newValues","ceilImpl","xi","expImpl","exp","expm1Impl","expm1","floorImpl","floor","greaterImpl","lessImpl","logImpl","maximumImpl","aValue","bValue","minimumImpl","multiplyImpl","rsqrtImpl","sqrt","subImpl","addImplCPU","bincountImplCPU","xVals","weightsVals","weightsDtype","weightsShape","weightsSize","outVals","makeZerosTypedArray","value","bincountReduceImplCPU","xBuf","weightsBuf","binaryOutput","numCols","outBuf","j","ceilImplCPU","concatImplCPU","simplyConcat","getArrayFromDType","vals","colOffset","decodedData","fromUint8ToStringArray","tIdx","resIdx","expImplCPU","expm1ImplCPU","floorImplCPU","gatherV2ImplCPU","indicesBuf","flattenOutputShape","originalLoc","batchIdx","indicesIdx","indicesIndex","originalIndex","greaterImplCPU","lessImplCPU","linSpaceImplCPU","start","stop","step","logImplCPU","maxImplCPU","reduceSize","maximumImplCPU","minimumImplCPU","multiplyImplCPU","negImplCPU","xShape","xDtype","minusOne","createScalarValue","prodImplCPU","reductionAxes","reduceShape","computeOutAndReduceShapes","outDtype","upcastType","prod","rangeImplCPU","numElements","rsqrtImplCPU","simpleAbsImplCPU","resultValues","sliceImplCPU","begin","isContinous","slice_util","isSliceContinous","xStrides","computeFlatOffset","subarray","inBuf","outLoc","inLoc","idx","fromStringArrayToUint8","sparseFillEmptyRowsImplCPU","indices","indicesShape","indicesDType","valuesDType","denseShape","defaultValue","indicesCount","denseRows","emptyRowIndicator","reverseIndexMap","rowsAreOrdered","lastIndicesRow","csrOffset","fill","allRowsFull","rowEmpty","outputIndices","outputValues","fullIndicesCount","filledCount","outputI","startingIndex","sparseReshapeImplCPU","inputIndices","inputIndicesShape","inputDType","inputShape","targetShape","denseSize","nnz","outputRank","product","unknownIndex","missing","trunc","outputSize","inputRank","inputStrides","outputStrides","newIndices","id","stridedSliceImplCPU","newLoc","subImplCPU","tileImplCPU","reps","topKImplCPU","k","sorted","lastDim","allTopKVals","allTopKIndices","valAndInd","sort","outOffset","topKVals","topKIndices","transposeImplCPU","perm","xRank","xSize","newStrides","uniqueImplCPU","axis","$axis","parseAxisParam","uniqueElements","Int32Array","inputBuffer","TensorBuffer","uniqueIndices","is1DTensor","element","axisValues","m","undefined","uniqueIndex","keys","outputTmpShape","outputBuffer","uniqueElementIndex","getVecChannels","getChannels","channels","outOfBoundsCondition","dims","cond","getOutOfBoundsCondition","setup","innerDims","getSetup","sourceCoords","coord","getSourceCoordsArr","getOutput","thisRC","gpgpu","TextureManager","shapeRC","usage","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","freeTextures","usedTextures","newTexture","texBytes","computeBytes","numFreeTextures","numUsedTextures","_numBytesFree","newTexture_1","shift","PACKED_2X2_FLOAT32","PACKED_2X2_FLOAT16","UNPACKED_FLOAT32","UNPACKED_FLOAT16","PACKED_4X1_UNSIGNED_BYTE","_numBytesAllocated","logicalTexType","deleteTexThreshold","deleteMatrixTexture","texList","texIndex","splice","logEnabled","total","freeRatio","round","tex","internalFormatForPhysicalTexType","numBytesForInternalFormat","UPLOAD","RENDER","getPhysicalTextureForRendering","PIXELS","shapeRowsCol","opSnippet","CHECK_NAN_SNIPPET","ABS","CLONE","getSourceCoords","whereImpl","kernel_impls","binaryCaches","_super","WeakMap","WeakSet","binaryCache","gpgpuCreatedLocally","textureManager","numMBBeforeWarning","global","screen","window","devicePixelRatio","DataStorage","engine","tslib_1.__extends","MathBackendWebGL","nextDataId","numDataIds","pendingDeletes","checkNumericalProblems","dataId","refCount","has","tensorInfo","disposeData","complexTensorInfos","UnaryOpPackedProgram","unary_op.CLONE","UnaryOpProgram","runWebGLProgram","readSync","disposeIntermediateTensorInfo","convertAndCacheOnCPU","shouldTimeProgram","activeTimers","now","realValues","real","imagValues","imag","mergeRealAndImagArrays","getValuesFromTexture","downloadWaitMs","pendingRead","subscribers_1","read","tmpDownloadTarget","decode","tmpData","createBufferFromTexture","tex_util.getDenseTexShape","createAndWaitForFence","all","ps","dTypeVals","subscribers","delete","pendingDisposal","removeDataId","decodeString","webgl_util.canBeRepresented","tmpTarget","tmpData_1","vals_1","downloadMatrixFromPackedTexture","shouldUsePackedProgram","webgl_util.getShapeAs3D","EncodeFloatPackedProgram","EncodeFloatProgram","f","oldActiveTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","flatten","filter","flattenedActiveTimerNames","uploadWaitMs","kernelMs","wallMs","kernelMs_1","sum","ms","unreliable","numBytesInGPU","numBytesInGPUAllocated","numBytesAllocated","numBytesInGPUFree","numBytesFree","startMs","endMs","waitForQueryAndGetTime","timerQuery","force","add","releaseGPUData","key","origDataId","dataRefCount","releaseTexture","uploadToGPU","sizeThreshold","every","condition","condVals","dataSync","outInfo","compileAndRun","makeTensorFromDataId","shouldExecuteOnCPU","outValues","makeOutput","packedUnaryOp","unary_op.ABS","isString","encodedValues","encodeString","write","UnpackProgram","PackProgram","afterShape","input3DShape","webgl_util.getBatchDim","webgl_util.getRowsCols","input3D","afterShapeAs3D","ReshapePackedProgram","DecodeMatrixPackedProgram","DecodeMatrixProgram","outputDtype","customSetup","preventEagerUnpackingOfOutput","makeTensorInfo","outData","packedOutput","outPackingScheme","tex_util.PackingScheme","texelShape","outTexUsage","dataToDispose","inputsData","packedInputs","uniformValues","unpackTensor","packTensor","webgl_util.isReshapeFree","savedInput","packedReshape","outputData","keyInputs","concat","hasOffset","keyUserCode","constructor","gpgpu_math.makeShaderKey","binary","getAndSaveBinary","inputInfos","variableNames","inShapeInfos","source","shader_compiler.makeShader","webGLProgram","infLoc","nanLoc","uniformLocations","varName","gpgpu_math.compileProgram","startTimer","outTex","setOutputPackedMatrixTexture","setOutputMatrixTexture","uniform1f","Infinity","NaN","varLoc","varOffsetLoc","uniform1fv","setInputMatrixTexture","executeProgram","gpgpu_math.runProgram","info","endTimer","glFlushThreshold","time","lastGlFlushTime","unpacked","getBinary","dispose","HTMLCanvasElement","remove","floatPrecisionValue","tidy","debugFlag","underflowCheckValue","scalar","floatPrecision","webgl_util.getTextureShapeFromLogicalShape","isByteArray","EncodeMatrixPackedProgram","EncodeMatrixProgram","tempDenseInputHandle","getTexture","encodedOutputTarget","outputTexData","acquireTexture","float32Values","float32ToTypedArray","texType","warnedAboutMemory","mb","toFixed","bytesPerElement","KernelBackend","forceHalfFloat","isBrowser","registerBackend","webgl","checkOutOfBounds","checkOutOfBoundsString","identity","args","backend","incRef","identityConfig","kernelName","Identity","backendName","kernelFunc","complex","complexInfo","realTensorInfo","imagTensorInfo","complexConfig","Complex","LEAKYRELU","LEAKYRELU_PACKED","leakyReluConfig","LeakyRelu","$alpha","BinaryOpPackedProgram","BinaryOpProgram","PRELU","PRELU_PACKED","preluConfig","Prelu","unaryKernelFunc","packedOpSnippet","cpuKernelImpl","webglBackend","$dtype","xData","binaryKernelFunc","_c","supportsComplex","aData","bData","complexOutput","_d","out","mapActivationToShaderProgram","activation","packed","transposeA","transposeB","addBias","hasPreluActivation","hasLeakyreluActivation","sharedDim","sharedDimensionPacked","aSample","bSample","aSwizzle","bSwizzle","activationSnippet","applyActivationSnippet","addBiasSnippet","batchASnippet","batchBSnippet","COMPLEX_MULTIPLY","MUL","multiply","realProgram","BinaryOpComplexProgram","binaryop_complex_gpu.COMPLEX_MULTIPLY","imagProgram","inputs_1","realPart","imagPart","multiplyConfig","Multiply","reshape","$shape","inferFromImplicitShape","$xSize","xTexData","reshapeConfig","Reshape","reduceInfo","divisor","windowSize","batchSize","outSize","windowSizeNearestVec4","windowSizeVec4Remainder","updateSnippet","denominator","isInt","toPrecision","reduceType","initializationValue","compareOp","vecType","reduce","reductionType","reductionStages","stages","computeOptimalWindowSize","getReductionStages","previousResult","MeanProgram","ReduceProgram","newDim","switched","originalOrder","switchedCoords","getSwitchedCoords","outputOrder","switchedOrder","nextColumn","getc","transposeImpl","TransposePackedProgram","TransposeProgram","keepDims","reductionIndices","origAxes","axes","permutedAxes","getAxesPermutation","sumInputIsTransposed","sumInput","getInnerMostAxes","assertAxesAreInnerMostDims","sumOutShape","expandShapeToKeepDim","reshapedInput","reduced","sumOutType","sumImpl","sumConfig","Sum","transpose","cpuTranspose","transposeConfig","Transpose","batchMatMulImpl","bias","preluActivationWeights","leakyreluAlpha","_e","innerShapeA","innerShapeB","outerShapeA","outerShapeB","outerDimsA","outerDimsB","batchDimA","batchDimB","batchDimsCompatible","a3dShape","b3dShape","a3d","b3d","intermediates","hasBias","hasPreluActivationWeights","hasLeakyreluAlpha","fusedActivation","aVec","bVec","shouldReshapeB","aVec3d","bVec3d","MatMulPackedProgram","$leakyreluAlpha","outReshaped","intermediates_1","_i","_fusedMatMulConfig","_FusedMatMul","absConfig","Abs","acos","acosConfig","Acos","acosh","acoshConfig","Acosh","ADD","addKernelFunc","cpuAdd","addConfig","Add","shapes","_","snippets","variable","operation","addNConfig","AddN","addN","tensors","midIndex","leftSide","rightSide","d1","d2","AddNPackedProgram","AddNProgram","allConfig","All","permutedX","a2D","anyConfig","Any","firstPass","compOp","indexSnippet","sourceLocSetup","sourceRank","sourceLocDType","inChannel","intChannels","srcRCoords","srcGCoords","srcBCoords","srcACoords","fetchCandidateIdx","fetchValue","getBestIndicesAChannelSnippet","argReduce","bestIndicesA","ArgMinMaxProgram","argReducePacked","ArgMinMaxPackedProgram","argMinMaxReduce","intermediateTensorInfos","reshaped","argMaxConfig","ArgMax","$x","argMinConfig","ArgMin","asin","asinConfig","Asin","asinh","asinhConfig","Asinh","atan","atanConfig","Atan","atan2","CHECK_NAN_SNIPPET_BINARY","atan2Config","Atan2","atanh","atanhConfig","Atanh","convInfo","poolType","computePositions","flattenPositions","includeBatchInIndex","filterWidth","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","isAvgPool","batchFlattenPositionStr","inHeight","inWidth","inChannels","flattenPositionStr","filterWidthNearestVec4","filterWidthVec4Remainder","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","inDepth","avgPoolConfig","AvgPool","filterSize","dimRoundingMode","eitherStridesOrDilationsAreOne","computePool2DInfo","filterHeight","avgPoolProgram","Pool2DProgram","avgPool3DConfig","AvgPool3D","dataFormat","computePool3DInfo","Pool3DProgram","avgMultiplier","outHeight","outWidth","filterDepth","outDepth","avgPoolGrad3DConfig","AvgPool3DGrad","dy","avgPoolBackpropProgram","AvgPool3DBackpropProgram","avgPoolGradConfig","AvgPoolGrad","AvgPool2DBackpropProgram","batchMatMulConfig","BatchMatMul","meanShape","varianceShape","offsetShape","scaleShape","varianceEpsilon","offsetSnippet","scaleSnippet","batchNormConfig","FusedBatchNorm","mean","variance","scale","finalInputs","BatchNormPackedProgram","BatchNormProgram","destSize","body","uniformPart","getCoords","SliceProgram","startLoc","getUniformLocationNoThrow","uniform1iv","sourceLoc","getChannel","upperRow","lowerRow","SlicePackedProgram","$begin","$size","assertParamsValid","getCustomSetupFunc","newTexData","assign","shallowSlice","sliceConfig","Slice","batchToSpaceNDConfig","BatchToSpaceND","blockShape","crops","getReshaped","permuted","getPermuted","reshapedPermuted","getReshapedPermuted","sliceBeginCoords","getSliceBeginCoords","sliceSize","getSliceSize","toDispose","reshapedIntermediate","transposedIntermediate","reshapedIntermediate2","sliced","bincountConfig","Bincount","weights","notEqual","notEqualConfig","NotEqual","realConfig","Real","castConfig","Cast","cast","zerosTensor","tf.zeros","floatX","hasEncodingLoss","int","zerosTensorInfo","CEIL","ceilConfig","Ceil","ClipProgram","minLoc","maxLoc","ClipPackedProgram","clipByValueConfig","ClipByValue","clipValueMin","clipValueMax","makeComplexComponentTensorInfo","complexTensor","complexPart","complexAbsConfig","ComplexAbs","ComplexAbsProgram","programInputs","computeOutShape","offsets","lastIndex","lastShift","lastChannels","allChannels","getValueSnippet","shift_1","shiftedChannels","channelIdx","c","imagConfig","Imag","concatImpl","reals","imags","realConcated","imagConcated","result_1","r","runOnCpu","tensors2D_1","innerSize","inputsValShapes","outShape_1","finalOutShape","result_2","program_1","ConcatPackedProgram","tensors2D","ConcatProgram","reshapedResult","$inputs","assertParamsConsistent","concatConfig","Concat","inputDepthNearestVec4","inputDepthVec4Remainder","isChannelsLast","rowDim","colDim","channelDim","itemsPerBlockRow","unrolled","conv2dByMatMul","sharedMatMulDim","outerShapeX","outerShapeFilter","outChannels","batchMatMulWillBeUnpacked","reshapeWillBeExpensive","xReshaped_1","originalXTexDataShape","filterReshaped","pointwiseConv","pointwiseConvTexData","xReshaped","conv2dWithIm2Row","x2ColShape","xSqueezed","w2Row","im2ColProgram","Im2ColPackedProgram","im2Col","im2ColReshaped","matmulProgram","intermediates_2","conv2DConfig","Conv2D","dilations","$dataFormat","convertConv2DDataFormat","computeConv2DInfo","Conv2DProgram","filterShape","conv2DBackpropFilterConfig","Conv2DBackpropFilter","Conv2DDerFilterProgram","conv2DBackpropInputConfig","Conv2DBackpropInput","Conv2DDerInputProgram","conv3DConfig","Conv3D","computeConv3DInfo","Conv3DProgram","conv3DBackpropFilterV2Config","Conv3DBackpropFilterV2","Conv3DDerFilterProgram","conv3DBackpropInputConfig","Conv3DBackpropInputV2","Conv3DDerInputProgram","cos","CHECK_NAN_SNIPPET_UNARY","cosConfig","Cos","cosh","coshConfig","Cosh","imageShape","boxShape","cropSize","method","extrapolationValue","imageHeight","imageWidth","numBoxes","cropHeight","cropWidth","methodId","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","cropAndResizeConfig","CropAndResize","image","boxes","boxInd","CropAndResizeProgram","exclusive","reverse","val","idxString","getFinalCoord","CumSumProgram","cumsumConfig","Cumsum","permutation","permutedAxis","log2","prevResult","reverseTransposedResult","getUndoAxesPermutation","denseBincountConfig","DenseBincount","bufferSync","blockSize","getHeightCoordString","getWidthCoordString","getDepthCoordString","getOutputDepthSize","getInputSamplingString","DepthToSpaceProgram","depthToSpaceConfig","DepthToSpace","inputHeight","inputWidth","inputDepth","outputHeight","outputWidth","outputDepth","hasLeakyReluAlpha","xNumRows","xNumCols","channelMul","texelsAcross","texelC","colIndex","nextTexelOffset","depthwiseConv2dNativeConfig","DepthwiseConv2dNative","$dilations","DepthwiseConvPacked2DProgram","DepthwiseConv2DProgram","depthwiseConv2dNativeBackpropFilterConfig","DepthwiseConv2dNativeBackpropFilter","DepthwiseConv2DDerFilterProgram","depthwiseConv2dNativeBackpropInputConfig","DepthwiseConv2dNativeBackpropInput","DepthwiseConv2DDerInputProgram","diagConfig","Diag","flat","DiagProgram","dilation2DConfig","Dilation2D","computeDilation2DInfo","Dilation2DProgram","einsumConfig","Einsum","equation","allDims","summedDims","idDims","checkEinsumDimSizes","path","steps","nSteps","numDimsRemaining","tensorsToDispose","idTerm","dimsToExpand","isIdentityPermutation","tensorsToDispose_1","elu","eluConfig","Elu","eluGradConfig","EluGrad","equal","equalConfig","Equal","erf","ERF_P","ERF_A1","ERF_A2","ERF_A3","ERF_A4","ERF_A5","erfConfig","Erf","EXP","expConfig","Exp","expandDims","dim","$dim","expandDimsConfig","ExpandDims","EXPM1","expm1Config","Expm1","component","inverse","innerDim","opString","exponentMultiplierSnippet","PI","resultDenominator","fftImpl","inputSize","innerDimensionSize","input2D","FFTProgram","complexOutputReshaped","fftConfig","FFT","FillProgram","valueLoc","inferDtype","fromPixels2DContext","fillConfig","Fill","flipLeftRightConfig","FlipLeftRight","FlipLeftRightProgram","FLOOR","floorConfig","Floor","floorDiv","floorDivConfig","FloorDiv","fromPixelsConfig","FromPixels","numChannels","isVideo","HTMLVideoElement","isImage","HTMLImageElement","drawImage","tempPixelHandle","FromPixelsPackedProgram","FromPixelsProgram","fusedConv2DConfig","FusedConv2D","fusedDepthwiseConv2DConfig","FusedDepthwiseConv2D","shouldPackDepthwiseConv","sliceDim","stridesType","strideString","gatherNdConfig","GatherNd","sliceRank","resultShape","numSlices","flattenIndices","flattenX","GatherNDProgram","currentCoords","gatherV2Config","GatherV2","batchDims","parsedAxis","segment_util","collectGatherOpShapeInfo","indicesSize","outerSize","dimSize","flattenIndex","GatherProgram","greater","greaterConfig","Greater","greaterEqual","greaterEqualConfig","GreaterEqual","ifftConfig","IFFT","isFinite","isFiniteConfig","IsFinite","isInf","isInfConfig","IsInf","isNaN","isNaNConfig","IsNan","less","lessConfig","Less","lessEqual","lessEqualConfig","LessEqual","linSpaceConfig","LinSpace","logConfig","Log","log1p","log1pConfig","Log1p","logicalAnd","logicalAndConfig","LogicalAnd","logicalNot","logicalNotConfig","LogicalNot","logicalOr","logicalOrConfig","LogicalOr","radius","beta","powOperator","rad","maxD","basis","LRNConfig","LRN","depthRadius","LRNPackedProgram","LRNProgram","LRNGradConfig","LRNGrad","LRNGradProgram","maxInputIsTransposed","maxInput","maxInputValues","maxOutShape","reshapedOutput","maxImpl","maxConfig","Max","maximum","maximumConfig","Maximum","maxPoolConfig","MaxPool","maxPoolProgram","maxPool3DConfig","MaxPool3D","maxPoolGrad3DConfig","MaxPool3DGrad","maxPool3dPositionsProgram","maxPool3dPositions","maxPoolBackpropProgram","MaxPool3DBackpropProgram","maxPoolGradConfig","MaxPoolGrad","maxPoolPositionsProgram","maxPoolPositions","maxPoolBackPropProgram","MaxPool2DBackpropProgram","maxPoolWithArgmaxConfig","MaxPoolWithArgmax","poolOutput","meanConfig","Mean","meanInputIsTransposed","meanInput","meanInputValues","meanOutShape","meanImpl","minConfig","Min","minimum","minimumConfig","Minimum","paddings","mode","p","end","unpackedCoords","padSetup","cLimit","mirrorPadConfig","MirrorPad","MirrorPadPackedProgram","MirrorPadProgram","mod","modConfig","Mod","numOutcomes","numSamples","MultinomialProgram","seed","seedLoc","realDiv","realDivConfig","RealDiv","SUB","sub","cpuSub","subConfig","Sub","softmax","logits","maxLogit","expandedShape","maxLogitsReshaped","sumExp","sumExpReshaped","softmaxConfig","Softmax","multinomialConfig","Multinomial","normalized","probs","NEG","negConfig","Neg","nonMaxSuppressionV3Impl","nonMaxSuppressionV3Config","NonMaxSuppressionV3","scores","maxOutputSize","iouThreshold","scoreThreshold","boxesVals","scoresVals","selectedIndices","nonMaxSuppressionV4Impl","nonMaxSuppressionV4Config","NonMaxSuppressionV4","padToMaxOutputSize","validOutputs","nonMaxSuppressionV5Impl","nonMaxSuppressionV5Config","NonMaxSuppressionV5","softNmsSigma","selectedScores","numIndices","onValue","offValue","oneHotConfig","OneHot","OneHotProgram","zerosLike","zerosLikeConfig","ZerosLike","onesLikeConfig","OnesLike","onesLike","packConfig","Pack","assertShapesMatch","expandedT","constantValue","PadProgram","componentSetup","paddingArea","PadPackedProgram","padV2","padV2Config","PadV2","pow","powConfig","Pow","prodConfig","Prod","range","rangeConfig","Range","reciprocal","reciprocalConfig","Reciprocal","relu","reluConfig","Relu","relu6","relu6Config","Relu6","newHeight","newWidth","alignCorners","halfPixelCenters","oldHeight","oldWidth","sourceFracIndexRC","effectiveInSize","effectiveOutSize","resizeBilinearConfig","ResizeBilinear","images","ResizeBilinearPackedProgram","ResizeBilinearProgram","dyShape","xHeight","xWidth","yHeight","yWidth","effectiveXSize","effectiveYSize","invHeightScale","invWidthScale","winHeight","winWidth","resizeBilinearGradConfig","ResizeBilinearGrad","ResizeBilinearBackpropProgram","roundBase","resizeNearestNeighborConfig","ResizeNearestNeighbor","ResizeNearestNeighborPackedProgram","ResizeNearestNeighborProgram","resizeNearestNeighborGradConfig","ResizeNearestNeighborGrad","ResizeNearestNeigborBackpropProgram","inCoords","getInCoord","nextRow","inCoordsArray","channels1","getR","getG","getB","getA","reverseConfig","Reverse","$dims","ReversePackedProgram","ReverseProgram","fillValue","fillSnippet","RotateProgram","centerX","centerY","sinFactor","cosFactor","paramsLoc","uniform4f","rotateWithOffsetConfig","RotateWithOffset","radians","center","sin","roundConfig","Round","rsqrt","rsqrtConfig","Rsqrt","updateSize","indicesRank","updatesRank","summingDupeIndex","indicesString","indicesSnippet","updatesString","updatesSnippet","scatterNdConfig","ScatterNd","updates","numUpdates","flattenShape","ScatterProgram","cRank","cCoords","abCoords","cCoordVars","abCoordVars","selectConfig","Select","SelectProgram","selu","SELU_SCALEALPHA","SELU_SCALE","seluConfig","Selu","sigmoid","sigmoidConfig","Sigmoid","sign","signConfig","Sign","sinConfig","Sin","sinh","sinhConfig","Sinh","softplus","softplusConfig","Softplus","spaceToBatchNDConfig","SpaceToBatchND","completePaddings","paddedX","reshapedPaddedShape","permutedReshapedPaddedPermutation","reshapedPaddedX","paddedXT","sparseFillEmptyRowsConfig","SparseFillEmptyRows","$indices","$values","$denseShape","$defaultValue","outputIndicesShape","Number","sparseReshapeConfig","SparseReshape","$inputShape","from","$inputIndices","sparseToDenseConfig","SparseToDense","sparseIndices","sparseValues","splitVConfig","SplitV","numOrSizeSplits","splitSizes","prepareSplitSize","sliceT","sqrtConfig","Sqrt","square","squareConfig","Square","SQUARED_DIFFERENCE","squaredDifference","squaredDifferenceConfig","SquaredDifference","stepConfig","Step","inputDtype","newCoords","outputAxis_1","stridedSliceConfig","StridedSlice","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","nonStrided","$strides","some","StridedSliceProgram","resultReshaped","tan","tanConfig","Tan","tanh","tanhConfig","Tanh","tile","buf","TileProgram","tileConfig","Tile","topKConfig","TopK","interpolation","fillMode","fillModeId","interpolationModeId","transformConfig","Transform","transforms","TransformProgram","uniqueConfig","Unique","unpackConfig","Unpack","outIndex","segOpInfo","segOpType","numSegments","checkValueOutOfBounds","checkSegmentIdOutOfBounds","kernelConfigs_1","UnsortedSegmentSum","segmentIds","outputDType","segOpCompute","segOpComputeOptimalWindowSize","SegmentOpProgram","rangeInfo","tileInfo","kernelConfig","registerKernel"],"mappings":"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"}